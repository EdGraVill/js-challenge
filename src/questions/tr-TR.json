[
  {
    "answer": 3,
    "explanation": [
      "Fonksiyonun içinde, önce `var` anahtar kelimesi ile `name` değişkenini tanımladık. Bu demektir ki, değişken varsayılan değeri olan `undefined` ile \"hoisting\" (hafızada alan oluşturma aşaması) olur, ta ki gerçekten değişkene değer ataması yaptığımız satıra varana dek. `name` değişkenini loglayama çalıştığımız satırda henüz değişkeni tanımlamadık, bu yüzden hala `undefined` değerini saklıyor.",
      "`let` (ve `const`) anahtar kelimelerine sahip değişkenler de \"hoisted\" olur, ama `var`'ın aksine <i>ilk değer ataması</i> yapılmaz. Değişkenleri tanımladığımız (ilk değer ataması yaptığımız) satırdan önce erişilebilir değillerdir. Bu, \"geçici ölü alan / geçici değişmez çıktı alanı\", \"temporal dead zone\", olarak adlandırılır. Değişkenlere, tanımlanmadan önce erişmeye çalıştığımız zaman, Javascript `ReferenceError` hatası fırlatır.\n</p>\n</details>"
    ],
    "id": 0,
    "options": [
      "`Lydia` ve `undefined`",
      "`Lydia` ve `ReferenceError`",
      "`ReferenceError` ve `21`",
      "`undefined` ve `ReferenceError`"
    ],
    "problem": "function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = \"Lydia\";\n  let age = 21;\n}\n\nsayHi();\n",
    "question": "Çıktısı nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Javascript'deki olay kuyruğundan dolayı, `setTimeout` callback fonksiyonu, döngü uygulandıktan _sonra_ çağrılır. `i` değişkeni, ilk döngü sırasında `var` anahtar kelimesi ile tanımlandığından, bu değişken globaldir. Döngü boyunca, `++` unary operatörünü kullanarak, `i`'nin değerini her seferinde `1` arttırdık. İlk örnekte, `setTimeout` callback fonksiyonu çağrıldığı zaman, `i`'nin değeri `3`'e eşitti.",
      "İkinci döngüde, `i` değişkeni `let` anahtar kelimesi kullanılarak tanımlandı: `let` (ve `const`) ile tanımlanan değişkenler \"block-scope\"dur (block `{}` arasındaki herhangi bir şeydir). Her bir tekrarda, `i` yeni değere sahip olacak ve her değer döngü içinde \"scoped\" olacak.\n</p>\n</details>"
    ],
    "id": 1,
    "options": [
      "`0 1 2` ve `0 1 2`",
      "`0 1 2` ve `3 3 3`",
      "`3 3 3` ve `0 1 2`"
    ],
    "problem": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`diameter` sıradan bir fonksiyonken, `perimeter`'in arrow fonksiyon olduğuna dikkat edin.",
      "Arrow fonksiyonlarda, `this` anahtar kelimesi, sıradan fonksiyonların aksine, kendi sardığı mevcut scope'u referans alır. Bu demektir ki, `perimeter`'i çağırdığımız zaman, `shape` objesini değil, kendi sardığı scope'u referans alıyor (örneğin window).",
      "Bu objede, `radius` değeri olmadığından `undefined` döndürüyor."
    ],
    "id": 2,
    "options": [
      "`20` ve `62.83185307179586`",
      "`20` ve `NaN`",
      "`20` ve `63`",
      "`NaN` ve `63`"
    ],
    "problem": "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Artı (unary plus), işlemeye çalıştığı değişkeni sayıya çevirmeye çalışır. `true` `1` ve `false` `0` demektir.",
      "`'Lydia'` harf dizisi doğrusal (\"truthy\") bir değerdir. Aslında sorduğumuz şey, \"bu doğrusal değer yanlış-ımsı (\"falsy\") mı?\". Bu da `false` döndürür. \n</p>\n</details>"
    ],
    "id": 3,
    "options": [
      "`1` and `false`",
      "`false` and `NaN`",
      "`false` and `false`"
    ],
    "problem": "+true;\n!\"Lydia\";\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Javascript'te, tüm nesne keyleri string'dir (Symbol olmadıkları müddetçe). Keyleri, string olarak _yazmadıysak_ bile, arka planda string'e çevrilirler.",
      "Javascript, ifadeleri yorumlar (ya da açar (\"unboxes\")). Köşeli parentez notasyonu kullandığımız zaman, Javascript ilk `[` görür ve `]` bulana kadar devam eder. Ancak ondan sonra ifadeyi hesaplar.",
      "`mouse[bird.size]`: Önce `bird.size` çalıştırılır, o da `\"small\"` demektir. `mouse[\"small\"]`, `true` döndürür.",
      "Ancak, nokta notasyonunda bu gerçekleşmez. `mouse`, `bird` diye bir keye sahip değildir ki bu da `mouse.bird`, `undefined` demektir. Sonra, nokta notasyonunu kullanarak `size`'a ulaşmak istiyoruz: `mouse.bird.size`. `mouse.bird`, `undefined` olduğundan, aslında ulaşmaya çalıştığımız `undefined.size`. Bu geçerli değil ve `Cannot read property \"size\" of undefined`'a benzer bir hata fırlatacaktır.\n</p>\n</details>"
    ],
    "id": 4,
    "options": [
      "`mouse.bird.size` geçerli değildir",
      "`mouse[bird.size]` geçerli değildir",
      "`mouse[bird[\"size\"]]` geçerli değildir",
      "Hepsi geçerlidir"
    ],
    "problem": "const bird = {\n  size: \"small\"\n};\n\nconst mouse = {\n  name: \"Mickey\",\n  small: true\n};\n",
    "question": "Hangisi doğru?"
  },
  {
    "answer": 0,
    "explanation": [
      "Javascript'te tüm nesneler, birbirlerine eşitlendikleri zaman _referansları_ ile etkileşime girerler.",
      "Önce, `c` değişkeni bir nesnenin değerini tutuyor. Sonra, `d`'ye aynı referansı atadık ki bu referans da `c`'nin sahip olduğu nesnedir.\n<img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\">",
      "Bir nesneyi değiştirdiğiniz zaman, hepsini değiştirirsiniz."
    ],
    "id": 5,
    "options": [
      "`Hello`",
      "`Hey!`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "let c = { greeting: \"Hey!\" };\nlet d;\n\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "`new Number()` yerleşik bir yapıcı fonksiyondur (\"function constructor\"). Sayı (\"number\") gibi gözükse de gerçekten bir sayı değil: bir kaç ekstra özelliğe sahip ve o bir nesne.",
      "`==` operatörünü kullandığımız zaman, sadece aynı _değer_'e sahip olup olmadığını kontrol eder. İkisi de `3` değerine sahip, yani `true` döndürür.",
      "Ancak, `===` kullandığımız zaman değer _ve_ tip aynı olmalıdır. Öyle değil: `new Number()`, sayı (\"number\") değildir, **nesne**dir. İkisi de `false` döndürür.\n</p>\n</details>"
    ],
    "id": 6,
    "options": [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`"
    ],
    "problem": "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "`colorChange` fonksiyonu statiktir. Statik methodlar, sadece oluşturuldukları kurucuda var olmak için tasarlanmıştır ve herhangi bir \"children\"a aktarılamaz. `freddie`, \"child\" olduğundan, fonksiyon aktarılmadı ve `freddie` üzerinden erişilebilir değil: `TypeError` hatası fırlatılır.\n</p>\n</details>"
    ],
    "id": 7,
    "options": [
      "`orange`",
      "`purple`",
      "`green`",
      "`TypeError`"
    ],
    "problem": "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = \"green\" } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: \"purple\" });\nconsole.log(freddie.colorChange(\"orange\"));\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Nesneyi loglar çünkü global nesne üzerinde boş bir nesne oluşturduk. `greeting`'i `greetign` olarak yanlış yazdığımız zaman, JS yorumlayıcısı bunu `global.greetign = {}` olarak gördü (ya da tarayıcı içinde `window.greetign = {}`).",
      "Bundan kaçınmak için, `\"use strict\"` kullanabiliriz. Bu, bir değişkene herhangi bir atama yapmadan önce tanımladığınızdan emin olmanızı sağlar.\n</p>\n</details>"
    ],
    "id": 8,
    "options": [
      "`{}`",
      "`ReferenceErrorgreetign is not defined`",
      "`undefined`"
    ],
    "problem": "let greeting;\ngreetign = {}; // Yazım hatası!\nconsole.log(greetign);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Javascript'te bu mümkün, çünkü fonksiyonlar nesnedir! (Primitive tiplere nazaran her şey nesnedir)",
      "Fonksiyon özel bir nesne tipidir. Yazdığınız kod asıl fonksiyon değil. Fonksiyon, özelliklere sahip bir nesnedir. Bu özellik çalıştırabilme kapasitesine sahiptir (\"invocable\")."
    ],
    "id": 9,
    "options": [
      "Hiç bir şey, tamamen iyi!",
      "`SyntaxError`. Fonksiyonlara bu şekilde özellik atayamazsın.",
      "`\"Woof\"` şeklinde loglanır.",
      "`ReferenceError`"
    ],
    "problem": "function bark() {\n  console.log(\"Woof!\");\n}\n\nbark.animal = \"dog\";\n",
    "question": "Bunu yaptığımız zaman ne gerçekleşir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Sıradan fonksiyonlarla yaptığınız gibi bir yapıcıya (\"constructor\") özellik ekleyemezsiniz. Eğer, tek seferde tüm nesnelere özellik eklemek isterseniz, bunun yerine prototype kullanmalısınız. Yani bu durumda,",
      "`member.getFullName()` çalışmış olacak. Bu neden faydalı? Diyelim ki, yapıcının kendisine bu methodu ekledik. Belki de tüm `Person` instance'leri bu methoda ihtiyaç duymuyor. Bu özelliğe sahip olduklarından dolayı, her bir instance hafızadan yer alır, bu da bir sürü hafıza israfı demek. Bunun yerine, eğer sadece prototype'a eklersek, hafızadan sadece bir tek yer alırız ve yine de tüm instanceler bu özelliğe erişebilir!"
    ],
    "id": 10,
    "options": [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`"
    ],
    "problem": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`sarah` için `new` anahtar kelimesi kullanmadık. `new` kullandığınız zaman, oluşturduğumuz yeni boş nesneyi referans gösterir. Lakin, `new`'i eklemezseniz, **global nesne**'yi referans gösterir!",
      "`this.firstName`, `\"Sarah\"`'a eşittir ve `this.lastName`, `\"Smith\"`'e eşittir dedik. Aslında yaptığımız, `global.firstName = 'Sarah'` ve `global.lastName = 'Smith'` diye tanımlamaydı. `sarah`'ın kendisi `undefined` olarak kalır.\n</p>\n</details>"
    ],
    "id": 11,
    "options": [
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` ve `undefined`",
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` ve `Person {firstName\"Sarah\", lastName\"Smith\"}`",
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` ve `{}`",
      "\"Lydia\", lastName\"Hallie\"}` ve `ReferenceError`"
    ],
    "problem": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person(\"Lydia\", \"Hallie\");\nconst sarah = Person(\"Sarah\", \"Smith\");\n\nconsole.log(lydia);\nconsole.log(sarah);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "**capturing** aşaması süresince, olay ata (\"ancestor) elemanlardan hedef elemana doğru gider. Daha sonra **target** elemana ulaşır ve **bubbling** başlar.",
      "<img src=\"https://i.imgur.com/N18oRgd.png\" width=\"200\">"
    ],
    "id": 12,
    "options": [
      "Target > Capturing > Bubbling",
      "Bubbling > Target > Capturing",
      "Target > Bubbling > Capturing",
      "Capturing > Target > Bubbling"
    ],
    "problem": "",
    "question": "Olay silsilesinin (event propagation) üç aşaması nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Bütün nesneler prototiplere (\"prototypes\") sahiptir, **temel nesne**, **base object**, hariç. Temel nesne, kullanıcı tarafından oluşturulmuş nesnedir, ya da `new` anahtar kelimesi kullanarak oluşturulmuş bir nesnedir. Temel nesne bazı method ve özelliklere erişebilir, `.toString` gibi. Yerleşik gelen Javascript methodlarını kullanabilme sebebi budur! Buna benzer tüm methodlar prototip üzerinden erişebilir. Her ne kadar Javascript, methodu direkt olarak nesneniz üzerinden bulamasa da, prototip zinciri üzerinden aşağıya doğru gider ve orada bulur, böylece sizin için erişebilir yapar.\n</p>\n</details>"
    ],
    "id": 13,
    "options": [
      "doğru",
      "yanlış"
    ],
    "problem": "",
    "question": "Bütün nesneler prototiplere sahiptir."
  },
  {
    "answer": 2,
    "explanation": [
      "Javascript **dinamik tipli dil**dir: değişkenlerin hangi tip olduğunu belirtmeyiz. Değerler otomatik olarak diğer tipi bilmeden dönüştürebilir, bu _implicit type coercion_, _örtük tip dönüşümü_, olarak adlandırılır. **Coercion** bir tipi diğer bir tipe dönüştürmektir.",
      "Bu örnekte, JavaScript sayı olan `1`'i string'e dönüştürüyor, fonksiyonun mantıklı olması ve değer döndürmesi için. Sayısal tip (`1`) ve string tip (`2`)'nin toplanması sırasında, sayıya string olarak muamele edilir. Stringleri `\"Hello\" + \"World\"` şeklinde birleştirebiliriz, yani burada olan `\"1\" + \"2\"` ki bu da `\"12\"` döndürür."
    ],
    "id": 14,
    "options": [
      "`NaN`",
      "`TypeError`",
      "`\"12\"`",
      "`3`"
    ],
    "problem": "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, \"2\");\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "**son ek**, **postfix**, `++` unary operatörü:",
      "Değer döndürür (`0` döndürür)",
      "Değeri arttırır (sayı şimdi `1`)",
      "**ön ek**, **prefix**, `++` unary operatörü:",
      "Değeri arttırır (sayı şimdi `2`)",
      "Değeri döndürür (`2` döndürür)",
      "Burada `0 2 2` döner."
    ],
    "id": 15,
    "options": [
      "`1` `1` `2`",
      "`1` `2` `2`",
      "`0` `2` `2`",
      "`0` `1` `2`"
    ],
    "problem": "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Eğer \"tagged template literals\" kullanırsanoz, ilk argumanın değeri her zaman string değerler dizisidir. Geriye kalan argumanlar, ifadeye geçilen değerleri alır."
    ],
    "id": 16,
    "options": [
      "`\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`",
      "`[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`",
      "`\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`"
    ],
    "problem": "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = \"Lydia\";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Eşitliği test ederken, nesneler _referanslarına_ göre kıyaslanırken primitifler _değerlerine_ göre kıyaslanır. Javascript, nesnelerin referanslarının hafızada aynı konumda olup olmadığını kontrol eder.",
      "Kıyasladığımız iki nesne bu şekilde değilse: parametre olarak geçtiğimiz nesne, hafızada eşitliğini kontrol ettiğimiz nesneden farklı bir konumu referans gösterir.",
      "Bu sebepten, `{ age: 18 } === { age: 18 }` ve `{ age: 18 } == { age: 18 }`, ikisi de `false` döndürür."
    ],
    "id": 17,
    "options": [
      "`You are an adult!`",
      "`You are still an adult.`",
      "`Hmm.. You don't have an age I guess`"
    ],
    "problem": "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log(\"You are an adult!\");\n  } else if (data == { age: 18 }) {\n    console.log(\"You are still an adult.\");\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Yayma operatorü, \"spread operator\", (`...args`) argumanların dahil olduğu bir dizi döndürür. Dizi bir nesnedir, bu yüzden `typeof args` `\"object\"` döndürür."
    ],
    "id": 18,
    "options": [
      "`\"number\"`",
      "`\"array\"`",
      "`\"object\"`",
      "`\"NaN\"`"
    ],
    "problem": "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "`\"use strict\"` ile, yanlışlıkla global değişkenler tanımlamadığınızdan emin olabilirsiniz. `age` değişkenini hiç tanımlamadık ve `\"use strict\"` kullandığımızdan, referans hatası fırlatacaktır. Eğer `\"use strict\"` kullanmasaydık, `age` özelliği global nesneye eklenmiş olacağından, çalışmış olacaktı."
    ],
    "id": 19,
    "options": [
      "`21`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "function getAge() {\n  \"use strict\";\n  age = 21;\n  console.log(age);\n}\n\ngetAge();\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`eval`, string olarak geçilen kodu çalıştırır. Eğer bir ifadeyse, bu durumdaki gibi, ifadeyi çalıştırır. İfade `10 * 10 + 5`. Bu `105` sayısını döndürür."
    ],
    "id": 20,
    "options": [
      "`105`",
      "`\"105\"`",
      "`TypeError`",
      "`\"10*10+5\"`"
    ],
    "problem": "const sum = eval(\"10*10+5\");\n",
    "question": "`sum`'ın değeri nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`sessionStorage` içinde saklanan veri _sekme_ kapatıldıktan sonra kaldırılır.",
      "Eğer `localStorage` kullandıysanız, veri sonsuza kadar orada olacaktır, örnek olarak `localStorage.clear()` çalıştırılmadığı sürece."
    ],
    "id": 21,
    "options": [
      "Sonsuza kadar, veri kaybolmaz.",
      "Kullanıcı sekmeyi kapatınca.",
      "Kullanıcı tamamen tarayıcıyı kapattığı zaman, sadece sekmeyi değil.",
      "Kullanıcı bilgisayarını kapattığı zaman."
    ],
    "problem": "sessionStorage.setItem(\"cool_secret\", 123);\n",
    "question": "cool_secret ne kadar süre boyunca erişebilinir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`var` anahtar kelimesi ile aynı isme sahip birden çok değişken tanımlayabilirsiniz. O halde değişken son değeri tutacak.",
      "Bunu `let` ya da `const` ile yapamazsınız, \"block-scoped\" olduklarından dolayı."
    ],
    "id": 22,
    "options": [
      "`8`",
      "`10`",
      "`SyntaxError`",
      "`ReferenceError`"
    ],
    "problem": "var num = 8;\nvar num = 10;\n\nconsole.log(num);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Tüm nesne anahtarları (Symbol'ler hariç) arka planda string'dir, kendiniz string olarak yazmasanız bile. Bu sebepten `obj.hasOwnProperty('1')` da `true` döndürür.",
      "Set için bu şekilde çalışmaz. Setimizde `'1'` yok: `set.has('1')` `false` döndürür. Setimiz sayısal tip `1`'e sahip, `set.has(1)` `true` döndürür."
    ],
    "id": 23,
    "options": [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`"
    ],
    "problem": "const obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(\"1\");\nobj.hasOwnProperty(1);\nset.has(\"1\");\nset.has(1);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Eğer aynı ada sahip iki tane anahtarınız, \"key\", varsa, anahtar değiştirilecektir. Hala ilk konumunda olacaktır ama son belirtilen değerle birlikte."
    ],
    "id": 24,
    "options": [
      "`{ a\"one\", b\"two\" }`",
      "`{ b\"two\", a\"three\" }`",
      "`{ a\"three\", b\"two\" }`",
      "`SyntaxError`"
    ],
    "problem": "const obj = { a: \"one\", b: \"two\", a: \"three\" };\nconsole.log(obj);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Temel yürütme konteksti, global yürütme kontekstidir: kodunuzda her yerde erişilebilir olan şeydir."
    ],
    "id": 25,
    "options": [
      "doğru",
      "yanlış",
      "değişir"
    ],
    "problem": "",
    "question": "JavaScript global yürütme konteksti, \"global execution context\", sizin için iki şey oluşturur: global nesne, ve \"this\" anahtar kelimesi."
  },
  {
    "answer": 2,
    "explanation": [
      "Eğer belirli şart `true` döndürürse, `continue` ifadesi yinelemeyi, \"iteration\", atlar."
    ],
    "id": 26,
    "options": [
      "`1` `2`",
      "`1` `2` `3`",
      "`1` `2` `4`",
      "`1` `3` `4`"
    ],
    "problem": "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`String`, özellikler de ekleyebileceğimiz tümleşik bir yapıcıdır. Prototipine bir method ekledim sadece. Primitif stringler, string prototip fonksiyonu tarafından üretilen string nesnesine otomatik olarak dönüştürülür. Bu yüzden, tüm stringler (string nesneleri) bu methoda erişebilir!"
    ],
    "id": 27,
    "options": [
      "`\"Just give Lydia pizza already!\"`",
      "`TypeErrornot a function`",
      "`SyntaxError`",
      "`undefined`"
    ],
    "problem": "String.prototype.giveLydiaPizza = () => {\n  return \"Just give Lydia pizza already!\";\n};\n\nconst name = \"Lydia\";\n\nname.giveLydiaPizza();\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Nesne keyleri otomatik olarak stringe dönüştürülür. `a` nesnesine değeri `123` olacak şekilde, bir nesneyi key olarak atamaya çalışıyoruz.",
      "Ancak, bir nesnesi string hale getirince, `\"[object Object]\"` olur. Dolayısıyla burada söylediğimiz, `a[\"object Object\"] = 123`. Sonra, aynı şeyi tekrar yapmayı deniyoruz. `c`, dolaylı olarak string hale getirdiğimiz başka bir nesne. O halde, `a[\"object Object\"] = 456`.",
      "Sonra, `a[b]`'yi logluyoruz, ki aslında o da `a[\"object Object\"]`. Onu da `456` olarak atamıştık, o yüzden `456` döndürür."
    ],
    "id": 28,
    "options": [
      "`123`",
      "`456`",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "const a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Bir `setTimeout` fonksiyonumuz var ve ilk onu çalıştırdık. Yine de en son loglandı.",
      "Bunun nedeni tarayıcılarda, \"runtime engine\"'a sahip olmamamızdan, `WebAPI` denilen bir şeye sahibiz. `WebAPI`, örneğin DOM ile çalışması için bize, `setTimeout` fonksiyonunu verir.",
      "_callback_ WebAPI'a eklendikten sonra, `setTimeout` fonksiyonun kendisi (callback hariç!) hafıza bloğundan atılır, \"popped off the stack\".",
      "<img src=\"https://i.imgur.com/X5wsHOg.png\" width=\"200\">",
      "Şimdi, `foo` çalıştı ve `\"First\"` loglandı.",
      "<img src=\"https://i.imgur.com/Pvc0dGq.png\" width=\"200\">",
      "`foo` hafıza bloğundan atıldı ve `baz` çalıştı. `\"Third\"` loglandı.",
      "<img src=\"https://i.imgur.com/WhA2bCP.png\" width=\"200\">",
      "WebAPI, her ne zaman bir şeyler hazırsa hafıza bloğuna öylece ekleyemez. Onun yerine callback fonksiyonunu, _queue_ diye adlandıralan bir şeye ekler.",
      "<img src=\"https://i.imgur.com/NSnDZmU.png\" width=\"200\">",
      "Burası olay döngüsünün çalışmaya başlayacapı yerdir. **olay döngüsü**, **event loop**, hafıza bloğuna ve iş kuyruğuna, \"task queue\", bakar. Eğer hafıza bloğu boşsa, kuyruktaki ilk şeyi alır ve hafıza bloğuna ekler.",
      "<img src=\"https://i.imgur.com/uyiScAI.png\" width=\"200\">",
      "`bar` çalıştı, `\"Second\"` loglandı ve hafıza bloğundan atıldı."
    ],
    "id": 29,
    "options": [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`"
    ],
    "problem": "const foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"));\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Olaya sebep olan en derindeki iç eleman, olayın hedefidir (\"event.target\"). `event.stopPropagation` kullanarak \"bubbling\"'i durdurabilirsiniz."
    ],
    "id": 30,
    "options": [
      "Dıştaki `div`",
      "İçteki `div`",
      "`button`",
      "İç içe olan tüm elemanlar listesi."
    ],
    "problem": "<div onclick=\"console.log('first div')\">\n  <div onclick=\"console.log('second div')\">\n    <button onclick=\"console.log('button')\">\n      Click!\n    </button>\n  </div>\n</div>\n",
    "question": "Butona tıklandığında, event.target nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Eğer `p`'ye tıklarsak, iki log görürüz: `p` ve `div`. Olay silsilesi, \"event propagation\", sırasında, 3 aşama vardır: \"capturing\", \"target\", ve \"bubbling\". Varsayılan olarak, olay işleyiciler, \"event handlers\", \"bubbling\" aşamasında (`useCapture`'ı `true` olarak ayarlanmadığı müddetçe) çalıştırılır. En derin elemandan dışa doğru gider."
    ],
    "id": 31,
    "options": [
      "`p` `div`",
      "`div` `p`",
      "`p`",
      "`div`"
    ],
    "problem": "<div onclick=\"console.log('div')\">\n  <p onclick=\"console.log('p')\">\n    Click here!\n  </p>\n</div>\n",
    "question": "Paragrafa tıkladığınız zaman, çıktı olarak ne loglanır?"
  },
  {
    "answer": 3,
    "explanation": [
      "İkisinde de, `this` anahtar kelimesinin referans olmasını istediğimiz nesneyi geçebiliriz. Ancak, `.call` _anında çalıştırılır_!",
      "`.bind.` fonksiyonun _kopyasını_ döndürür, ama konteksle bağlı şejilde. Anında çalıştırılmaz."
    ],
    "id": 32,
    "options": [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`"
    ],
    "problem": "const person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`sayHi` fonksiyonu, anında çalıştırılan fonksiyonun, \"immediately invoked function (IIFE)\", döndürdüğü değeri döndürür. Bu fonksiyon `0` döndürdü, k, tipi `\"number\"`'dır.",
      "Bilginize; 7 tane tümleşik tip vardır: `null`, `undefined`, `boolean`, `number`, `string`, `object`, ve `symbol`. Fonksiyonlar nesne olduklarından, `\"function\"` tip değildir. Fonksiyonun tipi `\"object\"`'dir."
    ],
    "id": 33,
    "options": [
      "`\"object\"`",
      "`\"number\"`",
      "`\"function\"`",
      "`\"undefined\"`"
    ],
    "problem": "function sayHi() {\n  return (() => 0)();\n}\n\nconsole.log(typeof sayHi());\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Sadece 6 tane yanlış-ımsı, \"falsy\", değer vardır:",
      "`undefined`",
      "`null`",
      "`NaN`",
      "`0`",
      "`''` (empty string)",
      "`false`",
      "Fonksiyon yapıcıları, `new Number` ve `new Boolean` gibi, doğrusaldır."
    ],
    "id": 34,
    "options": [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      "All of them are falsy"
    ],
    "problem": "0;\nnew Number(0);\n(\"\");\n(\" \");\nnew Boolean(false);\nundefined;\n",
    "question": "Bu değerlerden hangileri yanlış-ımsıdır (falsy)?"
  },
  {
    "answer": 1,
    "explanation": [
      "`typeof 1` `\"number\"` döndürür.\n`typeof \"number\"` `\"string\"` döndürür."
    ],
    "id": 35,
    "options": [
      "`\"number\"`",
      "`\"string\"`",
      "`\"object\"`",
      "`\"undefined\"`"
    ],
    "problem": "console.log(typeof typeof 1);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Dizi içinde, dizinin uzunluğunu aşan bir elemana değer atadığınızda, JavaScript \"boş alanlar, \"empty slots\", denilen bir şey oluşturur. Bunların değeri aslında `undefined` olsa da şöyle bir şey görürsünüz:",
      "`[1, 2, 3, 7 x empty, 11]`",
      "nerede çalıştırdığınıza bağlı olarak (her tarayıcı, node, vb... için farklıdır.)"
    ],
    "id": 36,
    "options": [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`"
    ],
    "problem": "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`catch` bloğu `x` argumanını alıyor. Argumanları geçtiğimiz zaman, bu değişken olan `x` ile aynı değildir. Bu `x` değişkeni block-scoped'dur.",
      "Sonra, bu block-scoped değişkeni `1`'e eşit olarak ayarladık ve `y` değişkeninin değerini ayarladık. Block-scoped `x` değişkenini logladık, ki değeri `1`'e eşitti.",
      "`catch` bloğunun dışında, `x` hala `undefined`, ve `y` `2`'dir. `catch` bloğunun dışında, `console.log(x)` çalıştırmak istediğimizde `undefined` döndürür ve `y` `2` döndürür."
    ],
    "id": 37,
    "options": [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`"
    ],
    "problem": "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "JavaScript sadece primitif ve nesne tiplerine sahiptir.",
      "Primitif tipler, `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, ve `symbol`.",
      "Primitif ve nesneyi birbirinden ayıran, primitif tiplerin herhangi bir özelliğie ya da methoda sahip olmamasıdır; ancak, fark edeceğiniz üzere `'foo'.toUpperCase()` `'FOO'` olarak değer döndürür ve `TypeError` ile sonuçlanmaz. Bunun sebebi, string gibi primitif bir tip üzerinde özelliğe ya da methoda erişmeye çalıştığınızda, JavaScript sarıcı sınıflardan, \"wrapper classes\", birini kullanarak nesneyi dolaylı şekilde sarar, örneğin `String`, ve sonrasında ifade çalıştıktan sonra anında sarıcıyı ayırır. `null` ve `undefined` dışındaki tüm primitifler bu şekilde davranır."
    ],
    "id": 38,
    "options": [
      "primitifdir ya da nesnedir",
      "fonksiyondur or nesnedir",
      "tuzak soru! sadece nesnedir",
      "sayıdır (number) ya da nesnedir"
    ],
    "problem": "",
    "question": "JavaScript'teki her şey ya bir..."
  },
  {
    "answer": 2,
    "explanation": [
      "`[1, 2]` başlangıç değerimizdir. Başladığımız değer budur ve `acc`'nin en ilk değeridir. İlk tur süresince, `acc` `[1,2]`'dir ve `cur` `[0, 1]`'dir. Onları birleştiririz ve `[1, 2, 0, 1]` olarak sonuçlanır.",
      "Sonra, `acc` `[1, 2, 0, 1]`'dir ve `cur` `[2, 3]`'dür. Onları birleştiririz ve `[1, 2, 0, 1, 2, 3]` elde ederiz."
    ],
    "id": 39,
    "options": [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`"
    ],
    "problem": "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`null` yanlış-ımsıdır, \"falsy\". `!null` `true` döndürür. `!true` `false` döndürür.",
      "`\"\"` yanlış-ımsıdır. `!\"\"` `true` döndürür. `!true` `false` döndürür.",
      "`1` doğrusaldır. `!1` `false` döndürür. `!false` `true` döndürür."
    ],
    "id": 40,
    "options": [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`"
    ],
    "problem": "!!null;\n!!\"\";\n!!1;\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Benzersiz bir id döndürür. Bu id, süre aralığını, \"interval\", `clearInterval()` fonksiyonu ile temizlemek için kullanılabilinir."
    ],
    "id": 41,
    "options": [
      "benzersiz bir id",
      "belirtilen milisayine tutarı",
      "gönderilen fonksiyon",
      "`undefined`"
    ],
    "problem": "setInterval(() => console.log(\"Hi\"), 1000);\n",
    "question": "`setInterval` methodu tarayıcıda ne döndürür?"
  },
  {
    "answer": 0,
    "explanation": [
      "String, yinelenebilirdir, \"iterable\". Yayma operatörü, yenilenebilirin her bir karakterini bir elemana eşler."
    ],
    "id": 42,
    "options": [
      "`[\"L\", \"y\", \"d\", \"i\", \"a\"]`",
      "`[\"Lydia\"]`",
      "`[[], \"Lydia\"]`",
      "`[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`"
    ],
    "problem": "[...\"Lydia\"];\n",
    "question": "Ne döndürür?"
  },
  {
    "answer": 2,
    "explanation": [
      "Sıradan fonksiyonlar yürütmenin başlamasının ardından yarı yolda durdurulamaz. Ancak, bir generator fonksiyon yarı yolda \"durdurabilir\" ve sonra nerede kaldıysa devam edebilir. Bir generator fonksiyon ne zaman `yield` anahtar kelimesiyle karşılaşsa, yield'de belirtilen değeri verir. Dikkat edin, generator fonksiyon değeri _döndürmez_ (_return_), değeri _verir_ (_yield_).",
      "Önce, generator fonksiyonu `i`'yi `10`'a eşitleyerek başlatıyoruz. `next()` methodunu kullanarak generator fonksiyonu çalıştırıyoruz. İlk kez generator fonksiyonu çalıştırdığımızda, `i` `10`'a eşit. Fonksiyon ilk `yield` anahtar kelimesi ile karşılaşıyor: `i`'nin değerini veriyor. Generatır şimdi \"durdu\", ve `10` loglandı.",
      "Sonra, `next()` methodunu kullanarak fonksiyonu tekrar çalıştırıyoruz. Fonksiyon önceki kaldığı yerden çalışmaya devam ediyor, `i` hala `10`'a eşit. Şimdi, fonksiyon sıraki `yield` anahtar kelimesi ile karşılaşıyor, ve `i * 2`'yi veriyor, yani fonksiyon `10 * 2` veriyor, ki o da `20`'dir. `10, 20` şeklinde sonuçlanıyor."
    ],
    "id": 43,
    "options": [
      "`[0, 10], [10, 20]`",
      "`20, 20`",
      "`10, 20`",
      "`0, 10 and 10, 20`"
    ],
    "problem": "function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`Promise.race` methoduna birçok promise geçtiğimiz zaman, _ilk_ çözümlenen/reddedilen, \"resolves/rejects\", promise'i çözümler/reddeder . `setTimeout` methoduna, zamanlayıcı, \"timer\", geçtik: ilk promise (`firstPromise`) için 500ms, ve ikinci promise (`secondPromise`) için 100ms. Bu demektir ki `secondPromise` `'two'` değeriyle birlikte önce çözümlenir. `res` sakladığı `'two'` değeriyle loglanır."
    ],
    "id": 44,
    "options": [
      "`\"one\"`",
      "`\"two\"`",
      "`\"two\" \"one\"`",
      "`\"one\" \"two\"`"
    ],
    "problem": "const firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, \"one\");\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, \"two\");\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\n",
    "question": "Ne döndürür?"
  },
  {
    "answer": 3,
    "explanation": [
      "Önce, `person` değişkenini, `name` özelliğine sahip bir nesne değeriyle birlikte tanımlarız.",
      "<img src=\"https://i.imgur.com/TML1MbS.png\" width=\"200\">",
      "Sonra, `members` olarak adlandırdığımız değişkeni tanımlarız. Bu dizinin ilk elemanını, `person` değişkeninin değerine eşit olarak ayarlarız. Nesneler, birbirlerine eşitlendiklerinde, _referans_ üzerinden etkileşime girer. Bir referansı, bir değişkenden diğerine atadığınız zaman, o referansın _kopyasını_ oluşturursunuz. (değişkenlerin _aynı_ referansa sahip olmadığına dikkat edin!)",
      "<img src=\"https://i.imgur.com/FSG5K3F.png\" width=\"300\">",
      "Sonra, `person` değişkenini `null`'a eşit olarak ayarlarız.",
      "<img src=\"https://i.imgur.com/sYjcsMT.png\" width=\"300\">",
      "Sadece `person` değişkeninin değerini değiştiriyoruz, dizideki ilk elemanı değil, ilk eleman nesneyi gösteren farklı (kopyalanmış) bir referansa sahip. `members` içindeki ilk eleman hala orijinal nesneyi gösteren referansını saklıyor. `members` dizisini logladığımız zaman, ilk elemanın hala sakladığı nesnenin değeri loglanır."
    ],
    "id": 45,
    "options": [
      "`null`",
      "`[null]`",
      "`[{}]`",
      "`[{ name\"Lydia\" }]`"
    ],
    "problem": "let person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`for-in` döngüsüyle, nesne keyleri boyunca ileryebiliriz, bu durumda `name` ve `age`. Temelde, nesne keyleri stringdir (eğer Symbol değilse). Her döngüde, `item`'in değerini, döngü sırasındaki geçerli key olarak eşitleriz. Önce, `item` `name`'e eşittir, ve loglanır. Sonra loglanan `item`, `age`'e eşittir."
    ],
    "id": 46,
    "options": [
      "`{ name\"Lydia\" }, { age21 }`",
      "`\"name\", \"age\"`",
      "`\"Lydia\", 21`",
      "`[\"name\", \"Lydia\"], [\"age\", 21]`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n};\n\nfor (const item in person) {\n  console.log(item);\n}\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Operatör birleşme özelliği, \"operator associativity, derleyicinin ifadeleri çalıştırdığı sıradır, ya soldan sağa ya da sağdan soladır. Bu sadece, eğer tüm operatörler _aynı_ önceliğe sahipse gerçekleşir. Sadece tek tip operatörümüz var: `+`. Toplama için birleşme özelliği soldan sağadır.",
      "`3 + 4` önce çalıştırılır. `7` sayısı olarak sonuçlanır.",
      "Tip baskısından, \"coercion\", dolayı `7 + '5'`, `\"75\"` olarak sonuçlanır. JavaScript `7` sayısını string'e çevirir, 15. soruya bakabilirsiniz. İki string'i `+` operatörünü kullanarak birleştirebiliriz. `\"7\" + \"5\"` `\"75\"` olarak sonuçlanır."
    ],
    "id": 47,
    "options": [
      "`\"345\"`",
      "`\"75\"`",
      "`12`",
      "`\"12\"`"
    ],
    "problem": "console.log(3 + 4 + \"5\");\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Sadece string içindeki ilk sayılar döndürülür. _Sayı tabanına_ (hangi tipte sayıya çözümlemek istediğimizi belirtmek için geçilen ikinci argüman: 10'lu, onaltılı, sekizli, ikili tabanda vb...) bağlı olarak, `parseInt` string içindeki hangi karakterlerin geçerli olduğunu kontrol eder. Sayı tabanında, geçerli olmayan bir karaktere denk geldiğinde, çözümleyi durdurur ve sonraki gelen karakterleri görmezden gelir.",
      "`*` geçerli bir sayı değil. `parseInt` sadece `\"7\"`'yi ondalık sistemde `7`'ye çözümler. `num`, `7` değerini saklıyor artık."
    ],
    "id": 48,
    "options": [
      "`42`",
      "`\"42\"`",
      "`7`",
      "`NaN`"
    ],
    "problem": "const num = parseInt(\"7*6\", 10);\n",
    "question": "`num` ın değeri nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Dizi üzerinde eşleme yaparken, `num`'ın değeri, o anda döngüye giren elemanın değerine eşittir. Bu durumda, elemanlar sayı, yani `typeof num === \"number\"` koşul ifadesi `true` durdurur. map fonksiyonu yeni bir dizi oluşturur ve fonksiyondan dönen değerleri yerleştirir.",
      "Ancak, biz değer döndürmüyoruz. Bir fonksiyondan değer döndürmediğimiz zaman, fonksiyon `undefined` döndürür. Dizideki her eleman için, fonksiyon bloğu çağrılır, yani her bir eleman için `undefined` döndürürüz."
    ],
    "id": 49,
    "options": [
      "`[]`",
      "`[null, null, null]`",
      "`[undefined, undefined, undefined]`",
      "`[ 3 x empty ]`"
    ],
    "problem": "[1, 2, 3].map(num => {\n  if (typeof num === \"number\") return;\n  return num * 2;\n});\n",
    "question": "Çıktısı Nedir`?"
  },
  {
    "answer": 0,
    "explanation": [
      "Argümanlar _değer_ olarak geçilir, değerleri nesne olmadıkları müddetçe, eğer öyleyse _referans_ olarak geçilir. `birthYear` nesne değil string olduğundan değer olarak geçilir. Argümanları değer olarak geçtiğimizde, o değerin bir _kopyası_ oluşturulur (46. soruya göz atın).",
      "`birthYear` değişkeni `\"1997\"` değeri için referansa sahip. `year` argümanı da ayrıca `\"1997\"` değeri için referansa sahip, ama `birthYear`'ın sahip olduğu referansın değeri ile aynı değer değil. `year`'ın değerini `\"1998\"`'e eşit olarak ayarlayıp güncellediğimizde, sadece `year`'ın değerini güncelleriz. `birthYear` hala `\"1997\"`'e eşittir.",
      "`person`'ın değeri bir nesnedir. `member` argümanı _aynı_ nesne için (kopyalanmış) referansa sahip. `member` nesnesinin özelliğini değiştirdiğimizde, `person`'ın değeri de ayrıca değişmiş olacaktır, ikisi de aynı nesne için referansa sahip olduklarından. `person`'ın `name` özelliği şimdi `\"Lydia\"` değerine eşittir."
    ],
    "id": 50,
    "options": [
      "`{ name\"Lydia\" }, \"1997\"`",
      "`{ name\"Sarah\" }, \"1998\"`",
      "`{ name\"Lydia\" }, \"1998\"`",
      "`{ name\"Sarah\" }, \"1997\"`"
    ],
    "problem": "function getInfo(member, year) {\n  member.name = \"Lydia\";\n  year = \"1998\";\n}\n\nconst person = { name: \"Sarah\" };\nconst birthYear = \"1997\";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "`throw` ifadesi ile, özelleştirilmiş hatalar oluşturabiliriz. Bu ifade ile, hatalar fırlatabilirsiniz. Hata durumu, \"exception\", bir <b>string</b>, <b>sayı</b>, <b>doğru/yanlış</b> ya da <b>nesne</b> olabilir. Bu durumda, bizim hata durumumuz string olan `'Hello world'`.",
      "`catch` ifadesi ile, eğer `try` bloğunda bir hata durumu fırlatılmışsa ne yapacağımızı belirtebiliriz. Bir hata durumu fırlatıldı: `'Hello world'` string'i. `e` artık bu string'e eşit, ki onu logluyoruz. `'Oh an error: Hello world'` olarak sonuç veriyor."
    ],
    "id": 51,
    "options": [
      "`\"It worked! Hello world!\"`",
      "`\"Oh no an errorundefined`",
      "`SyntaxErrorcan only throw Error objects`",
      "`\"Oh no an errorHello world!`"
    ],
    "problem": "function greeting() {\n  throw \"Hello world!\";\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log(\"It worked!\", data);\n  } catch (e) {\n    console.log(\"Oh no an error!\", e);\n  }\n}\n\nsayHi();\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Bir özellik döndürdüğünüz zaman, özelliğin değeri _döndürülen_ değere eşittir, yapıcı fonksiyon içinde atanmış değere değil. `\"Maserati\"` string'ini döndürüyoruz, yani `myCar.make` `\"Maserati\"`'ye eşittir."
    ],
    "id": 52,
    "options": [
      "`\"Lamborghini\"`",
      "`\"Maserati\"`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "function Car() {\n  this.make = \"Lamborghini\";\n  return { make: \"Maserati\" };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`let x = y = 10;` aslında şunun için kısa yazımdır:",
      "`y`'yi `10`'a eşit olarak ayarladığımızda, aslında global nesneye `y` özelliğini ekliyoruz (tarayıcıda `window`, Node içinde `global`). Tarayıcıda, `window.y` artık `10`'a eşit.",
      "Sonra, `x` değişkenini `y`'nin değeri ile birlkte tanımlıyoruz ki o da `10`. `let` anahtar kelimesi ile tanımlanan değişkenler _block scope_'dur, onlar sadece tanımlandıkları blok içinde sınırlıdır; bu durumda anında çalıştırılan fonksiyon, \"immediately-invoked function (IIFE)\", ile sınırlı. `typeof` operatörünü kullandığımız zaman, `x` operandı tanımlı değil: `x`'e tanımlandığı bloğun dışından erişmeye çalışıyoruz. Bu, `x` tanımlanmadı demektir. Bir değer ataması yapılmamış ya da tanımlanmamış değerlerin tipi `\"undefined\"`'dır. `console.log(typeof x)` `\"undefined\"` döndürür.",
      "Ancak, `y`'yi `10`'a eşitlerken global değişken `y`'yi oluşturduk. Bu değer kodunuzun herhangi bir yerinden erişilebilinir. `y` tanımlı ve `\"number\"` tipinde değeri saklıyor. `console.log(typeof y)` `\"number\"` döndürür."
    ],
    "id": 53,
    "options": [
      "`\"undefined\", \"number\"`",
      "`\"number\", \"number\"`",
      "`\"object\", \"number\"`",
      "`\"number\", \"undefined\"`"
    ],
    "problem": "(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`delete` anahtar kelimesini kullanarak özellikleri hem nesnelerden hem de prototip üzerinden silebiliriz. Prototip üzerindeki bir özellik silindiğinde, artık prototip zincirinde kullanıma müsait değildir. Bu durumda, `bark` fonksiyonu, `delete Dog.prototype.bark` ardından, prototip üzerinden kullanılabilir değildir fakat yine de erişmeye çalışıyoruz.",
      "Fonksiyon olmayan bir şeyi çalıştırmayı denediğimiz zaman, `TypeError` fırlatılır. Bu durumda, `pet.bark` `undefined` olduğundan, `TypeError: pet.bark is not a function` fırlatıldı."
    ],
    "id": 54,
    "options": [
      "`\"Woof I am Mara\"`, `TypeError`",
      "`\"Woof I am Mara\"`,`\"Woof I am Mara\"`",
      "`\"Woof I am Mara\"`, `undefined`",
      "`TypeError`, `TypeError`"
    ],
    "problem": "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog(\"Mara\");\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "`Set` nesnesi _benzersiz_ değerlerin koleksiyonudur: bir değer, set içinde sadece bir kez bulunabilir.",
      "Yinelenebilir `[1, 1, 2, 3, 4]`'i çift `1` değeriyle birlikte geçtik. Set içinde aynı değere iki kere sahip olamayacağımızdan, bir tanesi kaldırıldı. Sonuç, `{1, 2, 3, 4}`."
    ],
    "id": 55,
    "options": [
      "`[1, 1, 2, 3, 4]`",
      "`[1, 2, 3, 4]`",
      "`{1, 1, 2, 3, 4}`",
      "`{1, 2, 3, 4}`"
    ],
    "problem": "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "İçe aktarılan, \"imported\", modul _salt okur_'dur: içe aktarılan modulü değiştiremezsiniz. Sadece, dışa aktarım yapan modul değerini değiştirebilir.",
      "`myCounter`'ın değerini arttırmaya çalıştığımız zaman, hata fırlatır: `myCounter` salt okurdur ve değiştirilemez."
    ],
    "id": 56,
    "options": [
      "`10`",
      "`11`",
      "`Error`",
      "`NaN`"
    ],
    "problem": "// counter.js\nlet counter = 10;\nexport default counter;\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`delete` operatörü doğru/yanlış, \"boolean\", değer döndürür: silme başarılıysa `true`, değilse `false` döndürecektir. Ancak, `var`, `const` ya da `let` anahtar kelimeleri ile tanımlanan değişkenler, `delete` kullanılarak silinemez.",
      "`name` değişkeni `const` anahtar kelimesi ile tanımlandı, yani silinme işlemi başarılı değil: `false` döndü. `age`'i `21`'e eşitlediğimizde, global nesneye `age` diye özellik ekledik aslında. Bu yöntemle, sorunsuz şekilde nesnelerden özellikleri silebilirsiniz, böylelikle `delete age` `true` döndürür."
    ],
    "id": 57,
    "options": [
      "`false`, `true`",
      "`\"Lydia\"`, `21`",
      "`true`, `true`",
      "`undefined`, `undefined`"
    ],
    "problem": "const name = \"Lydia\";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Listelerden değerleri ya da nesnelerden özellikleri, yıkım yoluyla, \"destructuring\", çıkarabiliriz. Örneğin:",
      "<img src=\"https://i.imgur.com/ADFpVop.png\" width=\"200\">",
      "`a`'nın değeri `1` ve `b`'nin değeri `2`'dir. Bu soruda aslında yaptığımız şuydu:",
      "<img src=\"https://i.imgur.com/NzGkMNk.png\" width=\"200\">",
      "Bu demektir ki, `y`'nin değeri dizideki ilk değere eşit, o da `1` sayısıdır. `y`'yi logladığımız zaman, `1` döndürülür."
    ],
    "id": 58,
    "options": [
      "`[[1, 2, 3, 4, 5]]`",
      "`[1, 2, 3, 4, 5]`",
      "`1`",
      "`[1]`"
    ],
    "problem": "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Nesneleri `...` yayma operatörü kullanarak birleştirmek, kombine etmek, mümkündür. Bir nesnenin key/değer kopyasını oluşturmanıza olanak sunar, ve key/değerleri diğer nesneye ekler. Bu durumda, `user` nesnesinin kopyasını oluşturuyoruz, ve onları `admin` nesnesine ekliyoruz. `admin` nesnesi şimdi kopyalanan key/değerleri de içeriyor, ki bu da `{ admin: true, name: \"Lydia\", age: 21 }` olarak sonuç verir."
    ],
    "id": 59,
    "options": [
      "`{ admintrue, user{ name\"Lydia\", age21 } }`",
      "`{ admintrue, name\"Lydia\", age21 }`",
      "`{ admintrue, user[\"Lydia\", 21] }`",
      "`{ admintrue }`"
    ],
    "problem": "const user = { name: \"Lydia\", age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`defineProperty` methodu ile, nesnelere yeni özellikler ekleyebiliriz, ya da var olanları değiştirebiliriz. `defineProperty` methodu kullanarak bir nesneye özellik eklediğimiz zaman, varsayılan olarak _sıralanabilir değildir_, \"_not enumerable_\". `Object.keys` methodu, bir nesneden tüm _sıralanabilir_ özelliklerin adını döndürür, bu durumda sadece `\"name\"`.",
      "`defineProperty` methodu kullanılarak eklenen özellikler, varsayılan olarak değişmezdir. Bu davranışı `writable`, `configurable` ve `enumerable` kullaranak ezebilirsiniz. Bu yöntemle, `defineProperty` methodu nesnelere eklediğiniz özellikler üzerinde size çok daha fazla kontrol verir."
    ],
    "id": 60,
    "options": [
      "`{ name\"Lydia\", age21 }`, `[\"name\", \"age\"]`",
      "`{ name\"Lydia\", age21 }`, `[\"name\"]`",
      "`{ name\"Lydia\"}`, `[\"name\", \"age\"]`",
      "`{ name\"Lydia\"}`, `[\"age\"]`"
    ],
    "problem": "const person = { name: \"Lydia\" };\n\nObject.defineProperty(person, \"age\", { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`JSON.stringify`'ın ikinci argumanı _değiştiricidir_, _\"replacer\"_. Değiştirici bir fonksiyon ya da bir dizi olabilir, ve değerlerin hangilerinin ve nasıl string'e dönüşeceğini kontrol etmenize izin verir.",
      "Eğer değiştirici _dizi_ ise, sadece dizi içinde ismi geçem özellikler JSON string'e dahil edilmiş olur. Bu durumda, sadece  `\"level\"` ve `\"health\"` isimli özellikler dahil edildi, `\"username\"` dışarıda bırakıldı. `data`, `\"{\"level\":19, \"health\":90}\"` eşittir.",
      "Eğer değiştirici _fonksiyon_ ise, stringe dönüştürülen her özellik için bu fonksiyon çağrılır. Bu fonksiyondan dönen değer, JSON stringe eklenmiş olacak özelliğin değeri olacaktır. Eğer değer `undefined`'sa, bu özellik JSON stringe dahil edilmez."
    ],
    "id": 61,
    "options": [
      "`\"{\"level\":19, \"health\":90}\"`",
      "`\"{\"username\"\"lydiahallie\"}\"`",
      "`\"[\"level\", \"health\"]\"`",
      "`\"{\"username\"\"lydiahallie\", \"level\":19, \"health\":90}\"`"
    ],
    "problem": "const settings = {\n  username: \"lydiahallie\",\n  level: 19,\n  health: 90\n};\n\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\nconsole.log(data);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`++` unary operatörü _önce_ operandın değerini döndürür, _sonra_ operandın değerini arttırır. `increaseNumber` fonksiyonu önce değeri `10` olan `num`'ın değerini döndürdüğünden, `num1`'ın değeri `10`'dur, ve `num`'ın değeri ancak bundan sonra artar.",
      "`increasePassedNumber`'a `num1`'i geçtiğimizden, `num2`'nin değeri `10`'dur. `number` `10`'a eşittir (`num1`'ın değeri. Bir kez daha, `++` operatörü _önce_ operandın değerini döndürür, _sonra_ operandın değerini arttırır. `number`'ın değeri `10`, yani `num2` `10`'a eşittir.)"
    ],
    "id": 62,
    "options": [
      "`10`, `10`",
      "`10`, `11`",
      "`11`, `11`",
      "`11`, `12`"
    ],
    "problem": "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "ES6'da, parametrelere varsayılan değer atayabiliriz. Eğer fonksiyona değer geçilmezse ya da parametrenin değeri `undefined` ise, parametrenin değeri varsayılan değer olacaktır. Bu örnekte, `value` nesnesinin özelliklerini yeni nesneye yaydık, böylece `x` varsayılan değer olarak `{ number: 10}`'a sahip.",
      "Varsayılan argüman _çağrı sırasında_, \"_call time_\", çalıştırılır. Fonksiyonu her çağırdığımızda, _yeni_ bir nesne oluşturulur. `multiply` fonksiyonunu ilk iki seferde değer geçmeden çağırdık: `x` varsayılan değeri olan `{ number: 10 }`'a sahip. Sonra, bu sayının çarpılmış değerini logluyoruz, o da `20`.",
      "Üçüncü kez, `multiply`'ı çağırdığımız zaman, argüman geçiyoruz: `value` isimli nesne. `*=` operatörü aslında `x.number = x.number * 2` için kısa yazımdır: `x.number`'ın değerini değiştiriyoruz ve çarpılmış değer olan `20`'yi logluyoruz.",
      "Dördüncü kez, `value` nesnesini tekrar geçiyoruz. `x.number` önceden `20`'ye değiştirilmişti, yani `x.number *= 2` `40` loglar."
    ],
    "id": 63,
    "options": [
      "`20`, `40`, `80`, `160`",
      "`20`, `40`, `20`, `40`",
      "`20`, `20`, `20`, `40`",
      "`NaN`, `NaN`, `20`, `40`"
    ],
    "problem": "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number * 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "`reduce` methodunun aldığı ilk argüman _biriktiricidir_, \"_accumulator_\", bu örnekte `x`. İkinci argüman _o anki değerdir_, `y`. reduce methodu ile, dizideki her eleman üzerinde callback fonksiyonunu çalıştırırız, bu da en sonunda tek bir değer sonuçlanabilir.",
      "Bu örnekte, geriye bir değer döndürmüyoruz, sadece biriktiricinin değerini ve o anki değeri logluyoruz.",
      "Biriktiricinin değeri, bir önceki callback fonksiyonunun dönen değerine eşittir. Eğer, opsiyonel olan `initialValue` agümanını `reduce` methoduna geçmezseniz, biriktiricinin değeri, ilk çağrılışta gelen elemana eşit olur.",
      "İlk çağrılışta, biriktirici (`x`) `1`'dir, ve `y`'nin o anki değeri `2`'dir. callback fonksiyonundan bir şey döndürmüyoruz, biriktiriciyi ve o anki değeri logluyoruz: `1`  ve `2` loglanır.",
      "Eğer bir fonksiyondan değer döndürmezseniz, fonksiyon `undefined` döndürür. Sonraki çağrılışta, biriktirici `undefined`, ve o anki geçerli değer `3`'tür. `undefined` ve `3` loglanır.",
      "Dördündü çağrıda, tekrar callback fonksiyonundan değer döndürmüyoruz. Biriktirici tekrar `undefined`, ve o anki geçerli değer `4`. `undefined` ve `4` loglanır."
    ],
    "id": 64,
    "options": [
      "`1` `2` and `3` `3` and `6` `4`",
      "`1` `2` and `2` `3` and `3` `4`",
      "`1` `undefined` and `2` `undefined` and `3` `undefined` and `4` `undefined`",
      "`1` `2` and `undefined` `3` and `undefined` `4`"
    ],
    "problem": "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Türetilmiş bir sınıfta, `super`'i çağırmadan önce `this` anahtar kelimesine erişemezsiniz. Eğer erişmeyi denerseniz, ReferenceError fırlatır: 1 ve 4 referans hatası fırlatır.",
      "`super` anahtar kelimesiyle, parent sınıfın yapıcı methodunu verilen argümanlarla beraber çağırırız. Parent sınıfın yapıcısı `name` argümanını alıyor, bu yüzden `super`'e `name`'i vermemiz gerek.",
      "`Dog` sınıfı iki argüman alıyor, `name` `Animal` sınıfından türediğinden, ve `size` `Dog` sınıfı üzerinde ekstra özellik olarak. İkisinin de `Dog` yapıcı methoduna  geçilmesi gerek, bu da 2. yapıcı methodda doğru şekilde kullanılarak yapılmıştır."
    ],
    "id": 65,
    "options": [
      "1",
      "2",
      "3",
      "4"
    ],
    "problem": "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1 \n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4 \n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};\n",
    "question": "Hangi yapıcı method (constructor) ile `Dog` sınıfından başarılı şekilde kalıtım yapabiliriz?"
  },
  {
    "answer": 1,
    "explanation": [
      "`import` anahtar kelimesiyle, tüm içe aktarılan modüller _ilk çözümlenir_, \"_pre-parsed_\". Bu şu demektir, içe aktarılan modüller _önce_ çalışır, içe aktarım yapan dosyadaki kodlar _sonra_ çalıştırılır.",
      "CommonJS'deki `require()` ve `import` arasındaki fark budur! `require()` ile, bağımlılıkları kod çalışmaya başladığında yükleyebilirsiniz. `import` yerine `require` kullanmış olsaydık, `running index.js`, `running sum.js`, `3` konsolda loglanmış olacaktı."
    ],
    "id": 66,
    "options": [
      "`running index.js`, `running sum.js`, `3`",
      "`running sum.js`, `running index.js`, `3`",
      "`running sum.js`, `3`, `running index.js`",
      "`running index.js`, `undefined`, `running sum.js`"
    ],
    "problem": "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Her Symbol tamamen benzersizdir. Symbol'e geçilen argümanın amacı, Symbol'e bir açıklama vermektir. Symbol'ün değeri geçilen argümana bağlı değildir. Eşitliği test ederken, tamamen yeni iki symbol oluşturuyoruz: ilki `Symbol('foo')` ve ikincisi `Symbol('foo')`. Bu iki değer benzersiz ve birbirlerine eşit değil, `Symbol('foo') === Symbol('foo')` `false` döndürür."
    ],
    "id": 67,
    "options": [
      "`true`, `true`, `false`",
      "`false`, `true`, `false`",
      "`true`, `false`, `true`",
      "`true`, `true`, `true`"
    ],
    "problem": "console.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol('foo') === Symbol('foo'))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "`padStart` methoduyla, bir string'in başlangıcına dolgu yapabiliriz. Bu methoda geçilen değer, dolguyla beraber string'in _toplam_ uzunluğudur. `\"Lydia Hallie\"`'in uzunluğu `12`, `name.padStart(13)` string'in başlangıcına 1 boşluk eker, çünkü 12 + 1 = 13.",
      "Eğer `padStart` methoduna geçilen argüman, string'in uzunluğundan daha azsa, dolgu yapılmaz."
    ],
    "id": 68,
    "options": [
      "`\"Lydia Hallie\"`, `\"Lydia Hallie\"`",
      "`\"           Lydia Hallie\"`, `\"  Lydia Hallie\"` (`\"[13x whitespace]Lydia Hallie\"`, `\"[2x whitespace]Lydia Hallie\"`)",
      "`\" Lydia Hallie\"`, `\"Lydia Hallie\"` (`\"[1x whitespace]Lydia Hallie\"`, `\"Lydia Hallie\"`)",
      "`\"Lydia Hallie\"`, `\"Lyd\"`,"
    ],
    "problem": "const name = \"Lydia Hallie\"\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`+` operatörü ile stringleri birleştirebilirsiniz. Bu örnekte, `\"🥑\"` ile `\"💻\"` birleştiriyoruz, `\"🥑💻\"` olarak sonuçlanıyor.\n</p>\n</details>"
    ],
    "id": 69,
    "options": [
      "`\"🥑💻\"`",
      "`257548`",
      "Emojilerin kod numaralarını gösteren string",
      "Hata"
    ],
    "problem": "console.log(\"🥑\" + \"💻\");\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Generator fonksiyon `yield` anahtar kelimesini gördüğünde çalışmasını \"durdurur\". Öncelikle, fonksiyonun \"Do you love JavaScript?\" stringini vermesini sağlamamız gerek ki bu `game.next().value` çağrılarak yapılabilir.",
      "İlk `yield` anahtar kelimesi bulunana dek her satır çalıştırılır. Fonksiyonun içinde, ilk satırda `yield` anahtar kelimesi var: çalışma ilk yield ile durur. _Bu demektir ki `answer` değişkeni henüz tanımlanmadı!_",
      "`game.next(\"Yes\").value` çağırdığımız zaman, önceki `yield` `next()` fonksiyonuna geçilen parametlerin değeri ile değiştirilir, bu durumda `\"Yes\"`. `answer` değişkeninin değeri artık `\"Yes\"`'e eşit. if ifadesi `false` döndürür, ve `JavaScript loves you back ❤️` loglanır."
    ],
    "id": 70,
    "options": [
      "`game.next(\"Yes\").value` ve `game.next().value`",
      "`game.next.value(\"Yes\")` ve `game.next.value()`",
      "`game.next().value` ve `game.next(\"Yes\").value`",
      "`game.next.value()` ve `game.next.value(\"Yes\")`"
    ],
    "problem": "function* startGame() {\n  const answer = yield \"Do you love JavaScript?\";\n  if (answer !== \"Yes\") {\n    return \"Oh wow... Guess we're gone here\";\n  }\n  return \"JavaScript loves you back ❤️\";\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️\n",
    "question": "console.log ifadesinden sonra yorum satırı olarak gelen değerleri nasıl loglayabiliriz?"
  },
  {
    "answer": 2,
    "explanation": [
      "`String.raw` kaçış karakterlerinin (`\\n`, `\\v`, `\\t` vb.) göz ardı edildiği bir string döndürür. Ters bölü işareti şöyle bir şey gibi sonuçlanabileceğinden sorun olabilir:",
      "`` const path = `C:\\Documents\\Projects\\table.html` ``",
      "Şöyle sonuçlanır:",
      "`\"C:DocumentsProjects able.html\"`",
      "`String.raw` ile, kaçış karakteri basitçe göz ardı edilir ve yazdırılır:",
      "`C:\\Documents\\Projects\\table.html`",
      "Bu örnekte, string `Hello\\nworld`, dolayısıyla `Hello\\nworld` olarak loglanır."
    ],
    "id": 71,
    "options": [
      "`Hello world!`",
      "`Hello` <br />&nbsp; &nbsp; &nbsp;`world`",
      "`Hello\\nworld`",
      "`Hello\\n` <br /> &nbsp; &nbsp; &nbsp;`world`"
    ],
    "problem": "console.log(String.raw`Hello\\nworld`);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Asenkron bir fonksiyon her zaman promise döndürür. `await` promise'ı çözmek için beklemeli: `getData()`'yı `data`'ya eşitlemek için çağırdığımız zaman bekleyen promise döndürülür.",
      "Çözülmüş değer olan `\"I made it\"`'e erişmek isteseydik, `data` üzerinde `.then()` methodunu kullanabilirdik:",
      "`data.then(res => console.log(res))`",
      "Bu `\"I made it!\"` loglardı."
    ],
    "id": 72,
    "options": [
      "`\"I made it!\"`",
      "`Promise {<resolved>\"I made it!\"}`",
      "`Promise {<pending>}`",
      "`undefined`"
    ],
    "problem": "async function getData() {\n  return await Promise.resolve(\"I made it!\");\n}\n\nconst data = getData();\nconsole.log(data);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`push()` methodu yeni dizinin _uzunluğunu_ döndürür. Önceden, dizi bir eleman içeriyordu (`\"banana\"`) ve uzunluğu 1'di. Diziye `\"apple\"`'ı ekledikten sonra, dizi iki eleman içerir ve uzunluğu `2`'dir. `addToList` fonksiyonundan döndürülen budur.",
      "`push` methodu orijinal diziyi değiştirir. Eğer _dizinin uzunluğunu_ değil de _diziyi_ döndürmek isterseniz, `item`'i ekledikten sonra `list`'i döndürmelisiniz."
    ],
    "id": 73,
    "options": [
      "`['apple', 'banana']`",
      "`2`",
      "`true`",
      "`undefined`"
    ],
    "problem": "function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList(\"apple\", [\"banana\"]);\nconsole.log(result);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`Object.freeze` bir nesneye özellik eklemeyi, silmeyi ya da değiştirmeyi olanaksız kılar (özelliğin değeri başka bir nesneye ait olmadıkça)",
      "`shape` değişkenini oluşturup, donmuş `box` nesnesine eşitlediğimiz zaman, `shape` de ayrıca donmuş nesneyi referans eder. `Object.isFrozen` kullanarak bir nesnenin dondurulmuş olup olmadığını kontrol edebilirsiniz. Bu örnekte, `shape` değişkeni donmuş bir nesneyi referans gösterdiğinden, `Object.isFrozen(shape)` `true` döndürür.",
      "`shape` donmuş olduğundan, ve `x`'in değeri bir nesne olmadığından, `x` özelliğini değiştiremeyiz. `x` hala `10`'a eşit, ve `{ x: 10, y: 20 }` loglanır."
    ],
    "id": 74,
    "options": [
      "`{ x100, y20 }`",
      "`{ x10, y20 }`",
      "`{ x100 }`",
      "`ReferenceError`"
    ],
    "problem": "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "Eşitliğin sağ tarafındaki nesneden `name` özelliğini çıkarttığımız zaman, `myName` isimli değişkene, o özelliğin değeri olan `\"Lydia\"`'yı atıyoruz.",
      "`{ name: myName }` ile, JavaScript'e diyoruz ki; eşitliğin sağ tarafındaki `name` özelliğinin değeriyle birlikte `myName` diye bir değişken tanımlamak istiyoruz.",
      "`name`'i loglamayı denediğimizden dolayı, ki bu değişken tanımlanmamış, ReferenceError fırlatılır."
    ],
    "id": 75,
    "options": [
      "`\"Lydia\"`",
      "`\"myName\"`",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "const { name: myName } = { name: \"Lydia\" };\n\nconsole.log(name);\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "Saf fonksiyon, aynı argümanlar geçildiği zaman, _her zaman_ aynı sonucu döndüren fonksiyondur.",
      "`sum` fonksiyonu her zaman aynı sonucu döndürür. Eğer `1` ve `2` geçersek, _her zaman_ `3` döndürecektir. Eğer `5` ve `10` geçersek, _her zaman_ `15` döndürür, bunun gibi devam eder... Saf fonksiyonun tanımlaması budur."
    ],
    "id": 76,
    "options": [
      "Evet",
      "Hayır"
    ],
    "problem": "function sum(a, b) {\n  return a + b;\n}\n",
    "question": "Bu bir saf (pure) fonksiyon mu?"
  },
  {
    "answer": 2,
    "explanation": [
      "`add` fonksiyonu _ezberlenmiş_, \"_memoized_\", bir fonksiyondur. Ezberleme ile, fonksiyonun sonuçlarını, fonksiyonun daha hızlı çalışması için cache'leyebiliriz. Bu örnekte, önceki dönen değerleri saklayan bir `cache` nesnesi oluşturuyoruz.",
      "Eğer `addFunction` fonksiyonunu aynı argüman ile tekrar çağırırsak, önce cache içinde o değerin hali hazırda olup olmadığını kontrol eder. Eğer varsa, cache değeri döndürülecektir ki böylece çalışma zamanından tasarruf sağlanır. Eğer yoksa, cache'lenmemişse, değeri hesaplayıp ardından saklayacaktır.",
      "`addFunction` fonksiyonunu üç kez aynı değer ile çağırıyoruz: ilk çağırmada, `num` `10`'a eşit olduğu zaman fonksiyonun değeri henüz cache'lenmemiş. `num in cache` if ifadesi `false` döndürür\n ve else bloğu çalıştırılır: `Calculated! 20` loglanır, ve sonuç cache nesnesine eklenir. `cache` şimdi şuna benziyor; `{ 10: 20 }`",
      "İkincide, `cache` nesnesi `10` için döndürülen değeri içeriyor. `num in cache` if ifadesi `true` döndürür, ve `'From cache! 20'` loglanır.",
      "Üçüncü sefer de, fonksiyona `5 * 2` geçiyoruz ki bu da `10` olarak değerlendirilir. `cache` nesnesi `10` için döndürülen değeri içeriyor. `num in cache` if ifadesi `true` döndürür, ve `'From cache! 20'` loglanır."
    ],
    "id": 77,
    "options": [
      "`Calculated! 20` `Calculated! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `From cache! 20`",
      "`Calculated! 20` `From cache! 20` `Error`"
    ],
    "problem": "const add = () => {\n  const cache = {};\n  return num => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));\n",
    "question": "Çıktısı nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "_for-in_ döngüsü ile, **sayılabilir** (**enumerable**) özellikler üzerinde iterasyon yapabiliriz. Dizilerde, sayılabilir özellikler dizi elemanlarının \"keyleridir\", ki bu keyler aslında dizinin indeksidir. Diziyi şöyle görebilirsiniz:",
      "`{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`",
      "Burada keyler, sayılabilir özelliklerdir. `0` `1` `2` `3` loglanır.",
      "_for-of_ döngüsü ile, **yinelenebilirler** (**iterables**) üzerinde iterasyon yapabiliriz. Dizi, yinelebilirdir. Dizi üzerinde iterasyon yaptığımız zaman, `item` değişkeni o anda iterasyon yapılan elemana eşittir, `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` loglanır."
    ],
    "id": 78,
    "options": [
      "`0` `1` `2` `3` ve `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`",
      "`\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` ve `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`",
      "`\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` ve `0` `1` `2` `3`",
      " `0` `1` `2` `3` ve `{0\"☕\", 1\"💻\", 2\"🍷\", 3\"🍫\"}`"
    ],
    "problem": "const myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"]\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Dizi elemanları herhangi bir değeri tutabilir. Sayılar, stringler, nesneler, başka diziler, null, doğru/yanlış değerler, undefined, ve date, fonksiyonlar, hesaplamalar gibi başka ifadeler.",
      "Eleman dönen değere eşit olacaktır. `1 + 2` `3` döndürür, `1 * 2` `2` döndürür, ve `1 / 2` `0.5` döndürür."
    ],
    "id": 79,
    "options": [
      "`[\"1 + 2\", \"1 * 2\", \"1 / 2\"]`",
      "`[\"12\", 2, 0.5]`",
      "`[3, 2, 0.5]`",
      " `[1, 1, 1]`"
    ],
    "problem": "const list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Varsayılan olarak, fonksiyona bir değer geçilmedikçe, argümanlar `undefined` değerine sahiptir. Bu örnekte, `name` argümanı için bir değer geçmedik.",
      "ES6'da, bu varsayılan `undefined` değerini varsayılan parametreler ile ezebiliriz. Örneğin;",
      "`function sayHi(name = \"Lydia\") { ... }`",
      "Bu örnekte, eğer bir değer geçmeseydik ya da `undefined` geçseydik, `name` her zaman `Lydia`'a eşit olacaktı."
    ],
    "id": 80,
    "options": [
      "`Hi there, `",
      "`Hi there, undefined`",
      "`Hi there, null`",
      " `ReferenceError`"
    ],
    "problem": "function sayHi(name) {\n  return `Hi there, ${name}`\n}\n\nconsole.log(sayHi())\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`this` anahtar kelimesinin değeri, onu nerede kullandığınıza bağlıdır. **method** içinde, `getStatus` methodu gibi, `this` anahtar kelimesi _methodun bağlı olduğu nesneyi_ referans gösterir. Method `data` nesnesine ait, bu yüzden `this` `data` nesnesini referans gösterir. `this.status`'ü logladığımız zaman, `data` nesnesindeki `status` özelliği loglanır, ki o da `\"🥑\"`.",
      "`call` methodu ile, `this` anahtar kelimesinin referans gösterdiği nesneyi değiştirebiliriz. **fonksiyon** içinde, `this` anahtar kelimesi _fonksiyonun ait olduğu nesneyi_ referans gösterir. _global nesne_ üzerinde `setTimeout` fonksiyonu tanımladık, yani `setTimeout` fonksiyonu içinde, `this` anahtar kelimesi _global nesneyi_ referans gösterir. Global nesnede, değeri `\"😎\"` olan _status_ olarak adlandırılmış bir değişken var. `this.status`'ü logladığımız zaman, `\"😎\"` loglanır."
    ],
    "id": 81,
    "options": [
      "`\"🥑\"` ve `\"😍\"`",
      "`\"🥑\"` ve `\"😎\"`",
      "`\"😍\"` ve `\"😎\"`",
      "`\"😎\"` ve `\"😎\"`"
    ],
    "problem": "var status = \"😎\"\n\nsetTimeout(() => {\n  const status = \"😍\"\n\n  const data = {\n    status: \"🥑\",\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`city` değişkenini, `person` nesnesindeki `city` özelliğinin değerine eşitledik. `person` nesnesinde `city` diye isimlendirilmiş bir özellik yok, bu yüzden `city` değişkeni `undefined` değerine sahip olur.",
      "`person` nesnesinin kendisini referans _göstermediğimize_ dikkat edin! Sadece `city` değişkenini, `person` nesnesindeki `city` özelliğinin o andaki değerine eşitledik.",
      "Sonra, `city`'i `\"Amsterdam\"` string'ine eşitledik. Bu `person` nesnesini değiştirmez: bu nesneye referans yok.",
      "`person` nesnesini logladığımız zaman, değişikliğe uğramamış nesne döndürülür."
    ],
    "id": 82,
    "options": [
      "`{ name\"Lydia\", age21 }`",
      "`{ name\"Lydia\", age21, city\"Amsterdam\" }`",
      "`{ name\"Lydia\", age21, cityundefined }`",
      "`\"Amsterdam\"`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nlet city = person.city\ncity = \"Amsterdam\"\n\nconsole.log(person)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "`const` ve `let` anahtar kelimesine sahip değişkenler _block-scoped_'dur. Blok süslü parantezler (`{}`) arasındaki herhangi bir şeydir. Bu örnekte, if/else ifadesindeki süslü parantezlerdir. Bir değişkene, tanımlandığı blok dışından erişemezsiniz, ReferenceError fırlatılır."
    ],
    "id": 83,
    "options": [
      "`\"Sorry, you're too young.\"`",
      "`\"Yay! You're old enough!\"`",
      "`ReferenceError`",
      "`undefined`"
    ],
    "problem": "function checkAge(age) {\n  if (age < 18) {\n    const message = \"Sorry, you're too young.\"\n  } else {\n    const message = \"Yay! You're old enough!\"\n  }\n\n  return message\n}\n\nconsole.log(checkAge(21))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "İkinci `.then` içindeki `res`'in değeri bir önceki `.then`'den dönen değere eşittir. Bunun gibi, değerlerin bir sonraki yöneticiye (handler) geçileceği şekilde, `.then`'leri birbirlerine bağlayabilirsiniz,"
    ],
    "id": 84,
    "options": [
      "`fetch` methodunun sonucu.",
      "`fetch` methodunun ikinci kez çağrılmasından dönen sonuç.",
      "Bir önceki `.then()`'in sonucu.",
      "Her zaman `undefined` olacaktır."
    ],
    "problem": "fetch('https://www.website.com/api/user/1')\n  .then(res => res.json())\n  .then(res => console.log(res))\n",
    "question": "Loglanacak değer ne tür olur?"
  },
  {
    "answer": 0,
    "explanation": [
      "`!!name` ile, `name`'in değerinin doğrusal ya da yanlış-ımsı olup olmadığını belirleriz. Eğer `name` doğrusalsa, ki test etmek istediğimiz bu, `!name` `false` döndürür. `!false` (bu da `!!name` ne demekse o demektir gerçekte) `true` döndürür.",
      "`hasName`'i `name`'e eşitleyerek, `hasName`'i `getName` fonksiyonuna hangi değeri geçtiyseniz ona eşitlersiniz, `true` değerine değil.",
      "`new Boolean(true)` nesne (object wrapper) döndürür, doğru/yanlış (boolean) değerinin kendisini değil.",
      "`name.length` geçilen argümanın uzunluğunu döndürür, `true` olup olmadığını değil."
    ],
    "id": 85,
    "options": [
      "`!!name`",
      "`name`",
      "`new Boolean(name)`",
      "`name.length`"
    ],
    "problem": "function getName(name) {\n  const hasName = //\n}\n",
    "question": "`true`'yu argüman olarak geçemediğiniz durumda, hangi seçenek `hasName`'i `true`'ya eşitlemenin yoludur?"
  },
  {
    "answer": 1,
    "explanation": [
      "Bir string içindeki belli bir indeksteki karakteri almak için, köşeli parantez notasyonunu kullanabilirsiniz. String içindeki ilk karakterin indeksi 0'dır, ve böylece devam eder. Bu örnekte indeksi 0 olan elemanı istiyoruz, `\"I\"` karakteri, loglanır.",
      "Bu yöntemin IE7 ve altında desteklenmediğine dikkat edin. Bu durumda, `.charAt()` kullanabilirsiniz."
    ],
    "id": 86,
    "options": [
      "`\"\"\"`",
      "`\"I\"`",
      "`SyntaxError`",
      "`undefined`"
    ],
    "problem": "console.log(\"I want pizza\"[0])\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Varsayılan parametrenin değerini fonksiyonun başka parametresine eşitleyebilirsiniz, varsayılan parametreden _önce_ tanımladıkları müddetçe. `sum` fonksiyonuna `10` değerini geçtik. Eğer `sum` fonksiyonu sadece 1 argüman alırsa, `num2` değeri geçilmedi demektir, ve `num1`'ın değeri geçtiğimiz `10` değerine eşittir bu durumda. `num2`'nun varsayılan değeri `num1`'dır ki o da `10`'dur. `num1 + num2` `20` döndürür.",
      "Eğer varsayılan parametrenin değerini, _sonrasında_ (sağında) tanımlanmış bir parametreye eşitlemeye çalışıyorsanız, parametrenin değeri henüz oluşturulmamıştır, hata fırlatacaktır."
    ],
    "id": 87,
    "options": [
      "`NaN`",
      "`20`",
      "`ReferenceError`",
      "`undefined`"
    ],
    "problem": "function sum(num1, num2 = num1) {\n  console.log(num1 + num2)\n}\n\nsum(10)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`import * as name` yazımı ile, `module.js` dosyası içindeki _tüm `export`'ları_ `index.js` dosyası içinde `data` olarak adlandırdığımız yeni bir nesneye aktarıyoruz. `module.js` dosyası içinde, iki `export` var: varsayılan export ve isimlendirilmiş export. Varsayılan export `\"Hello World\"` string'i döndüren bir fonksiyon ve isimlendirilmiş export `\"Lydia\"` değerine sahip `name` olarak isimlendirilmiş değişken.",
      "`data` nesnesi varsayılan exportlar için `default` özelliğine, isilendirilmiş exportlar için isimlendirilmiş export'un ismi olan ve değeri isimlendirilmiş export'un değeri olan özelliklere sahiptir."
    ],
    "id": 88,
    "options": [
      "`{ defaultfunction default(), name\"Lydia\" }`",
      "`{ defaultfunction default() }`",
      "`{ default\"Hello world\", name\"Lydia\" }`",
      "`module.js`'e ait global nesne"
    ],
    "problem": "// module.js \nexport default () => \"Hello world\"\nexport const name = \"Lydia\"\n\n// index.js \nimport * as data from \"./module\"\n\nconsole.log(data)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "Sınıflar fonksiyon yapıcıları için \"syntactical sugar\"dır. `Person` sınıfına denk olan sınıf yapıcısı şöyle olabilirdi:",
      "Bir fonksiyon yapıcısını `new` ile çağırmak `Person` \"instance\" oluşturur, `typeof` anahtar kelimesi instance için `\"object\"` döndürür. `typeof member` `\"object\"` döndürür."
    ],
    "id": 89,
    "options": [
      "`\"class\"`",
      "`\"function\"`",
      "`\"object\"`",
      "`\"string\"`"
    ],
    "problem": "class Person {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nconst member = new Person(\"John\")\nconsole.log(typeof member)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "`.push` methodu dizinin _yeni uzunluğunu_ döndürür, dizinin kendisini değil! `newList`'i  `[1, 2, 3].push(4)`'a eşitleyerek, `newList`'i dizinin yeni uzunluğuna eşitledik: `4`.",
      "Sonra, `.push` methodunu `newList` üzerinde kullanmayo denedik. `newList` sayısal değer `4` olduğundan, `.push` methodunu kullanamayız: TypeError fırlatılır."
    ],
    "id": 90,
    "options": [
      "`[1, 2, 3, 4, 5]`",
      "`[1, 2, 3, 5]`",
      "`[1, 2, 3, 4]`",
      "`Error`"
    ],
    "problem": "let newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "Sıradan fonksiyonlar, `giveLydiaPizza` gibi, `constructor` özelliği olan `prototype` nesnesi özelliğine sahiptir. Ancak ok fonksiyonlar (arrow functions), `giveLydiaChocolate` gibi, bu `prototype` özelliğine sahip değildir. `giveLydiaChocolate.prototype` ile `prototype` özelliğine erişmeye çalışıldığında `undefined` döndürülür."
    ],
    "id": 91,
    "options": [
      "`{ constructor...}` `{ constructor...}`",
      "`{}` `{ constructor...}`",
      "`{ constructor...}` `{}`",
      "`{ constructor...}` `undefined`"
    ],
    "problem": "function giveLydiaPizza() {\n  return \"Here is pizza!\"\n}\n\nconst giveLydiaChocolate = () => \"Here's chocolate... now go hit the gym already.\"\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`Object.entries(person)` key ve nesneleri içeren dizilerden oluşan dizi döndürür:",
      "`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]`",
      "`for-of` döngüsünü kullanarak, dizi içindeki her bir elemanı gezebiliriz, alt dizileri bu örnekte. for-of döngüsü içinde alt dizileri `const [x, y]` kullanarak parçalayabiliriz. `x` alt dizideki ilk elemana, `y` alt dizideki ikinci elemana eşittir.",
      "İlk alt dizi `[ \"name\", \"Lydia\" ]`, `x` `\"name\"`'e ve `y` `\"Lydia\"`'ya eşittir.\nİkinci alt dizi `[ \"age\", 21 ]`, `x` `\"age\"`'e ve `y` `21`'a eşittir."
    ],
    "id": 92,
    "options": [
      "`name` `Lydia` and `age` `21`",
      "`[\"name\", \"Lydia\"]` and `[\"age\", 21]`",
      "`[\"name\", \"age\"]` and `undefined`",
      "`Error`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y)\n}\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "`...args` bir \"rest\" parametredir. \"Rest\" parametresinin değeri geriye kalan tüm argümanları içeren bir dizidir, ve **sadece son parametre olabilir.** Bu örnekte, rest parametresi ikindi parametreydi. Bu mümkün değildir ve syntax hatası fırlatılacaktır.",
      "Yukarıdaki örnek çalışır. `[ 'banana', 'apple', 'orange', 'pear' ]` dizisini döndürür."
    ],
    "id": 93,
    "options": [
      "`[\"banana\", \"apple\", \"pear\", \"orange\"]`",
      "`[[\"banana\", \"apple\"], \"pear\", \"orange\"]`",
      "`[\"banana\", \"apple\", [\"pear\"], \"orange\"]`",
      "`SyntaxError`"
    ],
    "problem": "function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "JavaScript'te, noktalı virgülü (`;`) özellikle yazmak _zorunda değiliz_, ancak JavaScript motoru ifadelerden sonra noktalı virgül eklemektedir. bu **Automatic Semicolon Insertion**, **Otomatik Noktalı Virgül Ekleme**, olarak adlandırılır. İfade, örneğin, değişkenler ya da `throw`, `return`, `break`, vb. gibi anahtar kelimeler olabilir.",
      "Burada, bir `return` ifadesi yazdık, ve _yeni bir satırda_ başka bir değer olarak `a + b`. Ancak, `a + b` yeni satırda olduğundan, JavaScript motoru onun aslında bizim döndürmek istediğimiz değer olduğunu bilmiyor. Onun yerine, `return`'den sonra otomatik olarak noktalı virgül ekliyor. Şöyle düşünebilirsiniz:",
      "Fonksiyon `return` anahtar kelimesinden sonra çalışmayı durduracağından, `a + b` asla ulaşılamaz demektir. Eğer hiçbir değer döndürülmezse, fonksiyon `undefined` döndürür. Dikkat etmeniz gereken, `if/else` ifadelerinden sonra otomatik ekleme yapılmadığıdır!"
    ],
    "id": 94,
    "options": [
      "`a is bigger`, `6` ve `b is bigger`, `3`",
      "`a is bigger`, `undefined` ve `b is bigger`, `undefined`",
      "`undefined` ve `undefined`",
      "`SyntaxError`"
    ],
    "problem": "function nums(a, b) {\n  if\n  (a > b)\n  console.log('a is bigger')\n  else \n  console.log('b is bigger')\n  return \n  a + b\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "Sınıfları diğer sınıf/fonksiyon yapıcılara eşitleyebiliriz. Bu örnekte, `Person`'ı `AnotherPerson`'a eşitliyoruz. Bu yapıcıdaki `name` `Sarah`'dır, yani `Person` instance'ı olan `member` üzerindeki `name` özelliği `\"Sarah\"`'tır."
    ],
    "id": 95,
    "options": [
      "`\"Lydia\"`",
      "`\"Sarah\"`",
      "`Errorcannot redeclare Person`",
      "`SyntaxError`"
    ],
    "problem": "class Person {\n  constructor() {\n    this.name = \"Lydia\"\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = \"Sarah\"\n  }\n}\n\nconst member = new Person()\nconsole.log(member.name)\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 3,
    "explanation": [
      "Symbol _sayılabilir_, \"_enumerable_\" değildir. Object.keys methodu nesne üzerindeki tüm _sayılabilir_ özellikleri döndürür. Symbol gizli kalır ve boş bir dizi döndürülür. Tüm nesne loglandığı zaman, bütün özellikler görülebilir, sayılabilir olmayanlar bile.",
      "Bu symbol'ün birçok  özelliğinden birisidir: tamamen benzersiz bir değer temsil etmenin yanında (ki nesneler üzerindeki kazara isim çakışmasını önler, örneğin aynı nesneye özellikler eklemek isteyen 2 kütüphaneyle çalışırken), ayrıca bu yolla nesne üzerindeki özellikleri \"saklayabilirsiniz\" (gerçi tamamen değil. `Object.getOwnPropertySymbols()` methodunu kullanarak symbol'lere hala erişebilirsiniz)."
    ],
    "id": 96,
    "options": [
      "`{Symbol('a')'b'}` ve `[\"{Symbol('a')\"]`",
      "`{}` ve `[]`",
      "`{ a\"b\" }` ve `[\"a\"]`",
      "`{Symbol('a')'b'}` ve `[]`"
    ],
    "problem": "const info = {\n  [Symbol('a')]: 'b'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 0,
    "explanation": [
      "`getList` fonksiyonu argüman olarak bir dizi alır. `getList` fonksiyonunun parentezleri arasında, bu diziyi anında parçalıyoruz. Şu şekilde görebilirsiniz:",
      "`[x, ...y] = [1, 2, 3, 4]`",
      "`...y` rest parametresi ile, dizi içinde \"geriye kalan\" tüm argümanları topluyoruz. Geriye kalan argümanlar `2`, `3`, ve `4` bu durumda. `y`'nin değeri tüm rest parametleri içeren bir dizi. `x`'in değeri `1`'a eşit, yani `[x, y]` logladığımız zaman, `[1, [2, 3, 4]]` loglanır.",
      "`getUser` fonksiyonu bir nesne alıyor. Ok fonksiyonlar ile, eğer sadece bir değer döndürmek istiyorsak süslü parentezleri yazmak _zorunda değiliz._ Ancak, bir ok fonksiyondan bir _nesne_ döndürmek istiyorsanız, parentezler arasında yazmak zorundasınız, aksi halde değer döndürülmez! Aşağıdaki fonksiyon bir nesne döndürecektir:",
      "```const getUser = user => ({ name: user.name, age: user.age })```",
      "Bu örnekte değer döndürülmediği için, fonksiyon `undefined` döndürür."
    ],
    "id": 97,
    "options": [
      "`[1, [2, 3, 4]]` ve `undefined`",
      "`[1, [2, 3, 4]]` ve `{ name\"Lydia\", age21 }`",
      "`[1, 2, 3, 4]` ve `{ name\"Lydia\", age21 }`",
      "`Error` ve `{ name\"Lydia\", age21 }`"
    ],
    "problem": "const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: \"Lydia\", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "`name` değişkeni string bir değer saklıyor, ki bu bir fonksiyon değil, bu yüzden çağrılamaz.",
      "TypeError'lar bir değer beklenilen tipte olmadığı zaman fırlatılır. `name`'i çağırmaya çalıştığımızdan, JavaScript `name`'in bir fonksiyon olmasını bekliyor. Ancak o bir string, bu yüzden TypeError fırlatılır: name is not a function!",
      "SyntaxError'lar JavaScript'in geçerli olmadığı bir şeyler yazdığız zaman fırlatılır, örneğin `return`'ü `retrun` olarak yazdığınız zaman.",
      "ReferenceError'lar erişmeye çalıştığınız değer için JavaScript referans bulamadığı zaman fırlatılır."
    ],
    "id": 98,
    "options": [
      "`SyntaxError`",
      "`ReferenceError`",
      "`TypeError`",
      "`undefined`"
    ],
    "problem": "const name = \"Lydia\"\n\nconsole.log(name())\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 1,
    "explanation": [
      "`[]` doğrusal bir değerdir. `&&` operatörü ile, eğer soldaki değer doğrusal bir değerse sağdaki değer döndürülür. Bu örnekte, soldaki değer `[]` doğrusal bir değerdir, böylece `\"Im\"` döndürülür.",
      "`\"\"` yanlış-ımsı bir değerdir. Eğer soldaki değer yanlış-ımsı ise, bir şey döndürülmez. `n't` döndürülmedi."
    ],
    "id": 99,
    "options": [
      "`possible! You should see a therapist after so much JavaScript lol`",
      "`Impossible! You should see a therapist after so much JavaScript lol`",
      "`possible! You shouldn't see a therapist after so much JavaScript lol`",
      "`Impossible! You shouldn't see a therapist after so much JavaScript lol`"
    ],
    "problem": "// 🎉✨ 100. soru! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`\n",
    "question": "Çıktısı Nedir?"
  },
  {
    "answer": 2,
    "explanation": [
      "`||` operatörü ile, ile doğrusal operand'ı döndürebiliriz. Eğer tüm değerler yanlış-ımsı ise, son operand döndürülür.",
      "`(false || {} || null)`: boş nesne `{}` doğrusal bir değerdir. İlk (ve tek) doğrusal değer, döndürülür. `one` `{}` eşittir.",
      "`(null || false || \"\")`: tüm operand'lar yanlış-ımsı. Bu demektir ki son operand, `\"\"` döndürülür. `two` `\"\"` eşittir.",
      "`([] || 0 || \"\")`: boş dizi `[]` doğrusal bir değerdir. Bu ilk doğrusal değer, döndürülür. `three` `[]` eşittir."
    ],
    "id": 100,
    "options": [
      "`false` `null` `[]`",
      "`null` `\"\"` `true`",
      "`{}` `\"\"` `[]`",
      "`null` `null` `true`"
    ],
    "problem": "const one = (false || {} || null)\nconst two = (null || false || \"\")\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)\n",
    "question": "Çıktısı Nedir?"
  }
]