[
  {
    "answer": 3,
    "explanation": [
      "Усередині функції ми спершу визначаємо змінну `name` за допомогою ключового слова `var`. Це означає, що змінна буде знайдена (область пам'яті під змінну буде виділена під час створення) зі значенням `undefined` за замовчуванням, до тих пір поки виконання коду не дійде до рядка, де визначається змінна. Ми ще не визначили значення `name`, коли намагаємося вивести її в консоль, тому в консолі буде `undefined`.",
      "Змінні, визначені за допомогою `let` (і `const`), також знаходяться, але на відміну від `var`, не <i>створюються</i>. Доступ до них неможливий до тих пір, поки не виконається рядок їх визначення (ініціалізації). Це називається \"тимчасова мертва зона\". Коли ми намагаємося звернутися до змінних до того моменту як вони визначені, JavaScript видає `ReferenceError`."
    ],
    "id": 0,
    "options": [
      "`Lydia` та `undefined`",
      "`Lydia` та `ReferenceError`",
      "`ReferenceError` та `21`",
      "`undefined` та `ReferenceError`"
    ],
    "problem": "function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = \"Lydia\";\n  let age = 21;\n}\n\nsayHi();\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "Через черги подій в JavaScript, функція `setTimeout` викликається _після того_ як цикл буде завершено. Так як змінна `i` в першому циклі була визначена за допомогою `var`, вона буде глобальною. У циклі ми кожен раз збільшуємо значення `i` на `1`, використовуючи унарний оператор `++.` До моменту виконання функції `setTimeout` значення `i` дорівнюватиме `3`, як показано в першому прикладі.",
      "У другому циклі змінна `i` визначена за допомогою `let`. Такі змінні (а також `const`) мають блочну область видимості (блок це що завгодно між `{}`). З кожної итерацией `i` матиме нове значення, і кожне значення буде замкнуто в своїй області видимості всередині циклу."
    ],
    "id": 1,
    "options": [
      "`0 1 2` та `0 1 2`",
      "`0 1 2` та `3 3 3`",
      "`3 3 3` та `0 1 2`"
    ],
    "problem": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 1,
    "explanation": [
      "Зауваж, що `diameter` це звичайна функція, в той час як `perimeter` це функція стрілки.",
      "У стрілочних функцій значення `this` вказує на навколишню область видимості, на відміну від звичайних функцій! Це означає, що при виклику `perimeter` значення `this` у цій функції вказує не на об'єкт `shape`, а на зовнішню область видимості (наприклад, window).",
      "У цього об'єкта немає ключа `radius`, тому повертається `undefined`."
    ],
    "id": 2,
    "options": [
      "`20` та `62.83185307179586`",
      "`20` та `NaN`",
      "`20` та `63`",
      "`NaN` та `63`"
    ],
    "problem": "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nshape.diameter();\nshape.perimeter();\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "Унарний плюс призводить операнд до числа. `true` це `1`, а `false` це `0`.",
      "Строка `'Lydia'` це \"справжнє\" значення. Ми запитуємо \"справжнє значення є помилковим\"? Відповідь: `false`."
    ],
    "id": 3,
    "options": [
      "`1` та `false`",
      "`false` та `NaN`",
      "`false` та `false`"
    ],
    "problem": "+true;\n!\"Lydia\";\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript все ключі об'єкта є рядками (крім `Symbol`). І хоча ми не _набираємо_ їх як рядки, вони завжди перетворюються до рядків під капотом.",
      "JavaScript інтерпретує (або розпаковує) оператори. При використанні квадратних дужок JS зауважує `[` і продовжує поки не зустріне `]`. Тільки після цього він вирахує то, що знаходиться всередині дужок.",
      "`mouse[bird.size]`: Спершу визначається `bird.size`, що дорівнює `\"small\"`. `mouse[\"small\"]` повертає `true`.",
      "Але із записом через точку так не відбувається. У `mouse` немає ключа `bird`. Таким чином, `mouse.bird` дорівнює `undefined`. Потім ми запитуємо ключ `size`, використовуючи точкову нотацію: `mouse.bird.size`. Так як `mouse.bird` це `undefined`, ми запитуємо `undefined.size`. Це не є дійсним, і ми отримуємо помилку типу: `Can not read property \"size\" of undefined`."
    ],
    "id": 4,
    "options": [
      "`mouse.bird.size` не є коректно",
      "`mouse[bird.size]` не є коректно",
      "`mouse[bird[\"size\"]]` не є коректно",
      "Все варіант коректні"
    ],
    "problem": "const bird = {\n  size: \"small\"\n};\n\nconst mouse = {\n  name: \"Mickey\",\n  small: true\n};\n",
    "question": "Що з цього не є коректним?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript всі об'єкти є _посилальними_ типами даних.",
      "Спершу змінна `c` вказує на об'єкт. Потім ми вказуємо змінної `d` посилатися на той самий об'єкт, що і `c`.",
      "<img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\">",
      "Коли ти змінюєш один об'єкт, то змінюються значення всіх посилань, що вказують на цей об'єкт."
    ],
    "id": 5,
    "options": [
      "`Hello`",
      "`Hey`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "let c = { greeting: \"Hey!\" };\nlet d;\n\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "`new Number()` це вбудований конструктор функції. І хоча він виглядає як число, це не справжнє число: у нього є ряд додаткових фіч і це об'єкт.",
      "Оператор `==` призводить типи даних до якогось одного і перевіряє рівність _значень_. Обидва значення рівні `3`, тому повертається `true`.",
      "При використанні оператора `===` значення і тип повинні бути однаковими. Але в нашому випадку це не так: `new Number()` це не число, це **об'єкт**. Тому обидва повертають `false`."
    ],
    "id": 6,
    "options": [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`"
    ],
    "problem": "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 3,
    "explanation": [
      "Функція `colorChange` є статичною. Статичні методи не мають доступу до екземплярів класу. Так як `freddie` це екземпляр, то статичний метод там не доступний. Тому результатом є помилка `TypeError`."
    ],
    "id": 7,
    "options": [
      "`orange`",
      "`purple`",
      "`green`",
      "`TypeError`"
    ],
    "problem": "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = \"green\" } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: \"purple\" });\nfreddie.colorChange(\"orange\");\n",
    "question": "Яким буде результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "В консолі виведеться об'єкт, тому що ми тільки що створили порожній об'єкт в глобальному об'єкті! Коли ми замість `greeting` написали `greetign`, інтерпретатор JS насправді виконав `global.greetign = {}` (або `window.greetign = {}` в браузері).",
      "Потрібно використовувати `\"use strict\"`, щоб уникнути такої поведінки. Ця запис допоможе бути впевненим в тому, що змінна була визначена перед тим як їй присвоїли значення."
    ],
    "id": 8,
    "options": [
      "`{}`",
      "`ReferenceErrorgreetign is not defined`",
      "`undefined`"
    ],
    "problem": "let greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript це можливо, тому що функції це об'єкти! (Все є об'єктами крім примітивів).",
      "Функція - це спеціальний тип об'єкта, який можна викликати. Крім того, функція - це об'єкт з властивостями. Властивість такого об'єкта не можна викликати, так як воно не є функцією."
    ],
    "id": 9,
    "options": [
      "Нічого, все ок.",
      "`SyntaxError`. Не можна додавати властивості функцій таким способом.",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "function bark() {\n  console.log(\"Woof!\");\n}\n\nbark.animal = \"dog\";\n",
    "question": "Що станеться?"
  },
  {
    "answer": 0,
    "explanation": [
      "Не можна додавати властивості конструктору, як звичайному об'єкту. Якщо потрібно додати фичу всіх об'єктах, то необхідно використовувати прототипи. В даному випадку,",
      "зробить метод `member.getFullName()` чинним. У чому тут перевага? Припустимо, що ми додали цей метод до конструктора. Можливо, не кожному екземпляру `Person` потрібен цей метод. Це призведе до великих втрат пам'яті, тому що всі екземпляри будуть мати цю властивість. Навпаки, якщо ми додамо цей метод тільки до прототипу, у нас буде тільки одне місце в пам'яті, до якого зможуть звертатися всі екземпляри!"
    ],
    "id": 10,
    "options": [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`"
    ],
    "problem": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "Для `sarah` ми не використали ключове слово `new`. Використання `new` призводить до створення нового об'єкта. Але без `new` він вказує на **глобальний об'єкт**!",
      "Ми вказали, що `this.firstName` дорівнює `\"Sarah\"` і `this.lastName` дорівнює `\"Smith\"`. Насправді ми визначили `global.firstName = 'Sarah'` і `global.lastName = 'Smith'`. `sarah` залишилася `undefined`."
    ],
    "id": 11,
    "options": [
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` та `undefined`",
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` та `Person {firstName\"Sarah\", lastName\"Smith\"}`",
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` та `{}`",
      "\"Lydia\", lastName\"Hallie\"}` та `ReferenceError`"
    ],
    "problem": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person(\"Lydia\", \"Hallie\");\nconst sarah = Person(\"Sarah\", \"Smith\");\n\nconsole.log(lydia);\nconsole.log(sarah);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 3,
    "explanation": [
      "Під час фази **захоплення** подія поширюється з елементів батьків до елемента мети. Після досягнення **мети** починається фаза **спливання**.",
      "<img src=\"https://i.imgur.com/N18oRgd.png\" width=\"200\">"
    ],
    "id": 12,
    "options": [
      "Мета (Target) > Захоплення (Capturing) > Всплиття (Bubbling)",
      "Всплиття (Bubbling) > Мета (Target) > Захоплення (Capturing)",
      "Мета (Target) > Всплиття (Bubbling) > Захоплення (Capturing)",
      "Захоплення (Capturing) > Мета (Target) > Всплиття (Bubbling)"
    ],
    "problem": "",
    "question": "Назвіть три фази поширення подій"
  },
  {
    "answer": 1,
    "explanation": [
      "Всі об'єкти мають прототипи, крім **базового об'єкта**. Базовий об'єкт має доступ до деяких методів і властивостей, таких як `.toString`. Саме тому ми можемо використовувати вбудовані методи JavaScript! Всі ці методи доступні в прототипі. Якщо JavaScript не може знайти метод безпосередньо у об'єкту, він продовжує пошук по ланцюжку прототипів поки не знайде."
    ],
    "id": 13,
    "options": [
      "Так",
      "Ні"
    ],
    "problem": "",
    "question": "Все объекты имеют прототипы?"
  },
  {
    "answer": 2,
    "explanation": [
      "JavaScript це **динамічно тіпізірованна мова**: ми не визначаємо тип змінних. Змінні можуть автоматично бути перетворені з одного типу в інший без нашої участі, що називається _неявним приведенням типів_. **Приведення** це перетворення з одного типу в інший.",
      "У цьому прикладі, JavaScript конвертувати число `1` в рядок, щоб операція усередині функції мала сенс і повернула значення. Під час складання числа (`1`) і рядки (`'2'`) число перетворюється до рядка. Ми можемо конкатеніровать рядки ось так: `\"Hello\" + \"World\"`. Таким чином, \"`1\"` + `\"2\"` повертає \"`12\"`."
    ],
    "id": 14,
    "options": [
      "`NaN`",
      "`TypeError`",
      "`\"12\"`",
      "`3`"
    ],
    "problem": "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, \"2\");\n",
    "question": "Результат коду?"
  },
  {
    "answer": 2,
    "explanation": [
      "**Постфіксний** унарний оператор `++`:",
      "Повертає значення (`0`)",
      "Інкрементує значення (тепер число дорівнює `1`)",
      "**Префіксний** унарний оператор `++`:",
      "Інкрементує значення (тепер число дорівнює `1`)",
      "Повертає значення (`0`)",
      "Результат: `0 2 2`."
    ],
    "id": 15,
    "options": [
      "`1` `1` `2`",
      "`1` `2` `2`",
      "`0` `2` `2`",
      "`0` `1` `2`"
    ],
    "problem": "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 1,
    "explanation": [
      "При використанні тегованих шаблонних литералов першим аргументом завжди буде масив строкових значень. Залишилися аргументами будуть значення переданих виразів!"
    ],
    "id": 16,
    "options": [
      "`\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`",
      "`[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`",
      "`\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`"
    ],
    "problem": "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = \"Lydia\";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "В операціях порівняння примітиви порівнюються за їх _значенням_, а об'єкти по _посиланнях_. JavaScript перевіряє, щоб об'єкти вказували на одну і ту ж область пам'яті.",
      "Порівнянні об'єкти в нашому прикладі не такі: об'єкт, переданий як параметр, вказує на іншу область пам'яті, ніж об'єкти, що використовуються в порівняннях.",
      "Тому `{age: 18} === {age: 18}` і `{age: 18} == {age: 18}` повертають `false`."
    ],
    "id": 17,
    "options": [
      "`You are an adult!`",
      "`You are still an adult.`",
      "`Hmm.. You don't have an age I guess`"
    ],
    "problem": "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log(\"You are an adult!\");\n  } else if (data == { age: 18 }) {\n    console.log(\"You are still an adult.\");\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "Оператор поширення (`... args`) повертає масив з аргументами. Масив це об'єкт, тому `typeof args` повертає `\"object\"`."
    ],
    "id": 18,
    "options": [
      "`\"number\"`",
      "`\"array\"`",
      "`\"object\"`",
      "`\"NaN\"`"
    ],
    "problem": "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "Використовуючи `\"use strict\"`, можна бути впевненим, що ми помилково не оголосимо глобальні змінні. Ми раніше ніде не оголошували змінну `age`, тому з використанням `\"use strict\"` виникне ReferenceError. Без використання `\"use strict\"` помилки не виникне, а змінна `age` додасться в глобальний об'єкт."
    ],
    "id": 19,
    "options": [
      "`21`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "function getAge() {\n  \"use strict\";\n  age = 21;\n  console.log(age);\n}\n\ngetAge();\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "`eval` виконує код, переданий у вигляді рядка. Якщо цей вислів (як в даному випадку), то обчислюється вираз. Вираз `10 * 10 + 5` поверне число `105`."
    ],
    "id": 20,
    "options": [
      "`105`",
      "`\"105\"`",
      "`TypeError`",
      "`\"10*10+5\"`"
    ],
    "problem": "const sum = eval(\"10*10+5\");\n",
    "question": "Чому дорівнюватиме sum?"
  },
  {
    "answer": 1,
    "explanation": [
      "Дані, збережені в `sessionStorage` очищаються після закриття _вкладки_.",
      "При використанні `localStorage` дані зберігаються назавжди. Очистити їх можна, наприклад, використовуючи `localStorage.clear()`."
    ],
    "id": 21,
    "options": [
      "Завжди, дані не загубляться.",
      "Поки користувач не закриває вкладку.",
      "Поки користувач не закриє браузер, а не тільки вкладку.",
      "Поки користувач не вимикає комп'ютер."
    ],
    "problem": "sessionStorage.setItem(\"cool_secret\", 123);\n",
    "question": "Як довго буде доступний cool_secret?"
  },
  {
    "answer": 1,
    "explanation": [
      "За допомогою ключового слова `var`, можна визначати скільки завгодно змінних з одним і тим же ім'ям. Змінна зберігатиме останнім присвоєне значення.",
      "Ви не можете зробити це з `let` або` const`, оскільки вони блочні."
    ],
    "id": 22,
    "options": [
      "`8`",
      "`10`",
      "`SyntaxError`",
      "`ReferenceError`"
    ],
    "problem": "var num = 8;\nvar num = 10;\n\nconsole.log(num);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "Всі ключі об'єктів (крім `Symbols`) є рядками, навіть якщо задано не в вигляді рядків. Тому `obj.hasOwnProperty('1')` так само повертає `true`.",
      "Але це не працює для `set`. Значення `\"1\"` немає в `set`: `set.has ('1')`, тому повертається `false`. Але `set.has(1)` поверне `true`."
    ],
    "id": 23,
    "options": [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`"
    ],
    "problem": "const obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(\"1\");\nobj.hasOwnProperty(1);\nset.has(\"1\");\nset.has(1);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "Якщо є два ключі з однаковим ім'ям, то ключ буде перезаписан. Його позиція збережеться, але значенням буде встановлено останнім."
    ],
    "id": 24,
    "options": [
      "`{ a\"one\", b\"two\" }`",
      "`{ b\"two\", a\"three\" }`",
      "`{ a\"three\", b\"two\" }`",
      "`SyntaxError`"
    ],
    "problem": "const obj = { a: \"one\", b: \"two\", a: \"three\" };\nconsole.log(obj);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "Базовий контекст виконання це глобальний контекст виконання: це те, що є де завгодно в твоєму коді."
    ],
    "id": 25,
    "options": [
      "Так",
      "Ні",
      "В залежності від ситуації"
    ],
    "problem": "",
    "question": "Глобальний контекст виконання створює дві речі: глобальний об'єкт і this"
  },
  {
    "answer": 2,
    "explanation": [
      "Оператор `continue` пропускає ітерацію, якщо умова повертає `true`."
    ],
    "id": 26,
    "options": [
      "`1` `2`",
      "`1` `2` `3`",
      "`1` `2` `4`",
      "`1` `3` `4`"
    ],
    "problem": "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "`String` це вбудований конструктор, до якого можна додавати властивості. Я додала метод до його прототипу. Рядки-примітиви автоматично конвертуються до рядків-об'єктів. Тому всі рядки (строкові об'єкти) мають доступ до цього методу!"
    ],
    "id": 27,
    "options": [
      "`\"Just give Lydia pizza already!\"`",
      "`TypeErrornot a function`",
      "`SyntaxError`",
      "`undefined`"
    ],
    "problem": "String.prototype.giveLydiaPizza = () => {\n  return \"Just give Lydia pizza already!\";\n};\n\nconst name = \"Lydia\";\n\nname.giveLydiaPizza();\n",
    "question": "Яким буде результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "Ключі об'єкта автоматично конвертуються в рядки. Ми збираємося додати об'єкт в якості ключа до об'єкта `a` зі значенням `123`.",
      "Проте, коли ми наводимо об'єкт до рядка, він стає `\"[object Object]\"`. Таким чином, ми говоримо, що `a[\"object Object\"] = 123`. Потім ми робимо те ж саме. `c` це інший об'єкт, який ми неявно наводимо до рядка. Тому `a[\"object Object\"] = 456`.",
      "Потім, коли ми виводимо `a[b]`, ми маємо на увазі `a[\"object Object\"]`. Ми тільки що встановили туди значення `456`, тому в результаті отримуємо `456`."
    ],
    "id": 28,
    "options": [
      "`123`",
      "`456`",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "const a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 1,
    "explanation": [
      "Ми викликаємо функцію `setTimeout` першої. Тим не менш, вона виводиться в консоль останньої",
      "Це відбувається через те, що в браузерах у нас є не тільки рантайм движок, але і `WebAPI`. `WebAPI` надає нам функцію `setTimeout` і багато інших можливостей. Наприклад, DOM.",
      "Після того як _коллбек_ відправлений в `WebAPI`, функція `setTimeout` (але не коллбек!) виймається з стека.",
      "<img src=\"https://i.imgur.com/X5wsHOg.png\" width=\"200\">",
      "Тепер викликається `foo`, і `\"First\"` виводиться в консоль.",
      "<img src=\"https://i.imgur.com/Pvc0dGq.png\" width=\"200\">",
      "`foo` дістається з стека, і викликається `baz`. `\"Third\"` виводиться в консоль.",
      "<img src=\"https://i.imgur.com/WhA2bCP.png\" width=\"200\">",
      "`WebAPI` не може додавати вміст в стек коли захоче. Замість цього він відправляє коллбек-функцію в так звану _чергу_.",
      "<img src=\"https://i.imgur.com/NSnDZmU.png\" width=\"200\">",
      "Тут на сцену виходить цикл подій (event loop). **Event loop** перевіряє стек і черга завдань. Якщо стек порожній, то він бере перший елемент з черги і відправляє його в стек.",
      "<img src=\"https://i.imgur.com/uyiScAI.png\" width=\"200\">",
      "Викликається `bar`, в консоль виводиться `\"Second\"` і ця функція дістається з стека."
    ],
    "id": 29,
    "options": [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`"
    ],
    "problem": "const foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"));\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n",
    "question": "Яким буде результат?"
  },
  {
    "answer": 2,
    "explanation": [
      "Метою події є **найглибший** вкладений елемент. Зупинити поширення подій можна за допомогою `event.stopPropagation`"
    ],
    "id": 30,
    "options": [
      "Зовнішній `div`",
      "Внутрішній `div`",
      "`button`",
      "Масив з усіма вкладеними елементами"
    ],
    "problem": "<div onclick=\"console.log('first div')\">\n  <div onclick=\"console.log('second div')\">\n    <button onclick=\"console.log('button')\">\n      Click!\n    </button>\n  </div>\n</div>\n",
    "question": "Що буде в `event.target` після кліка на кнопку?"
  },
  {
    "answer": 0,
    "explanation": [
      "Після кліка по `p` буде виведено `p` та `div`. У циклі життя події є три фази: **захоплення**, **мета** і **спливання**. За замовчуванням обробники подій виконуються на фазі спливання (якщо не встановлено параметр `useCapture` в `true`). Спливання йде з найглибшого елемента вгору."
    ],
    "id": 31,
    "options": [
      "`p` `div`",
      "`div` `p`",
      "`p`",
      "`div`"
    ],
    "problem": "<div onclick=\"console.log('div')\">\n  <p onclick=\"console.log('p')\">\n    Click here!\n  </p>\n</div>\n",
    "question": "Що буде в консолі після кліка по параграфу?"
  },
  {
    "answer": 3,
    "explanation": [
      "В обох випадках ми передаємо об'єкт, на який буде вказувати `this`. Але `.call` виконується _відразу ж_!",
      "`.bind` повертає _копію_ функції, але з прив'язаним контекстом. Вона не виконується негайно."
    ],
    "id": 32,
    "options": [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`"
    ],
    "problem": "const person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 1,
    "explanation": [
      "Функція `sayHi` повертає значення, що повертається з _негайно викликаного функціонального вираза_ (IIFE). Результатом є `0` типу `\"number\"`.",
      "Для інформації: в JS 7 вбудованих типів: `null`, `undefined`, `boolean`, `number`, `string`, `object`, та `symbol`. `\"Function\"` не є окремим типом, тому що функції є об'єктами типу `\"object\"`."
    ],
    "id": 33,
    "options": [
      "`\"object\"`",
      "`\"number\"`",
      "`\"function\"`",
      "`\"undefined\"`"
    ],
    "problem": "function sayHi() {\n  return (() => 0)();\n}\n\ntypeof sayHi();\n",
    "question": "Яким буде результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "Є тільки шість \"помилкових\" значень:",
      "`undefined`",
      "`null`",
      "`NaN`",
      "`0`",
      "`''` (порожній рядок)",
      "`false`",
      "Конструктори функцій, такі як new `Number` та `new Boolean` є \"істинними\"."
    ],
    "id": 34,
    "options": [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      "Всі значення."
    ],
    "problem": "0;\nnew Number(0);\n(\"\");\n(\" \");\nnew Boolean(false);\nundefined;\n",
    "question": "Які з цих значень є \"помилковими\"?"
  },
  {
    "answer": 1,
    "explanation": [
      "`typeof 1` повертає `\"number\"`.\n`typeof \"number\"` повертає `\"string\"`"
    ],
    "id": 35,
    "options": [
      "`\"number\"`",
      "`\"string\"`",
      "`\"object\"`",
      "`\"undefined\"`"
    ],
    "problem": "console.log(typeof typeof 1);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 2,
    "explanation": [
      "Коли в масив додається значення, яке виходить за межі довжини масиву, JavaScript створює так звані \"порожні клітинки\". Насправді вони мають значення `undefined`, але в консолі виводяться так:",
      "`[1, 2, 3, 7 x empty, 11]`",
      "в залежності від місця використання (може відрізнятися для браузерів, Node, і т.д.)."
    ],
    "id": 36,
    "options": [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`"
    ],
    "problem": "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "Блок `catch` отримує аргумент `x`. Це не той же `x`, який визначено в якості змінної перед рядком `try`.",
      "Потім ми присвоюємо цього аргументу значення `1` та встановлюємо значення для змінної `y`. Потім виводимо в консоль значення аргументу `x`, що дорівнює `1`.",
      "За межами блоку `catch` змінна `x` все ще `undefined`, а `y` дорівнює `2`. Коли ми викликаємо` console.log(x)` за межами блоку `catch`, цей виклик повертає `undefined`, а `y` повертає `2`."
    ],
    "id": 37,
    "options": [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`"
    ],
    "problem": "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript є тільки примітиви і об'єкти.",
      "Типи примітивів: `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, та `symbol`.",
      "Відмінністю примітиву від об'єкта є те, що примітиви не мають властивостей або методів. Проте, `'foo'.toUpperCase()` перетворюється в `'FOO'` та не викликає `TypeError`. Це відбувається тому, що при спробі отримання властивості або методу у примітиву (наприклад, рядки), JavaScript неявно оберне примітив об'єктом, використовуючи один з класів-обгорток (наприклад, `String`), а потім відразу ж знищить обгортку після обчислення виразу. Всі примітиви крім `null` та `undefined` поводяться таким чином."
    ],
    "id": 38,
    "options": [
      "примітив або об'єкт",
      "функція або об'єкт",
      "питання з підступом! тільки об'єкти",
      "число або об'єкт"
    ],
    "problem": "",
    "question": "Все в JavaScript це..."
  },
  {
    "answer": 2,
    "explanation": [
      "`[1, 2]` - початкове значення, з яким инициализируется змінна `acc`. Після першого проходу `acc` дорівнюватиме `[1,2]`, а `cur` буде `[0,1]`. Після конкатенації результат буде `[1, 2, 0, 1]`.",
      "Потім `acc` дорівнює `[1, 2, 0, 1]`, а cur `[2, 3]`. Після злиття отримаємо `[1, 2, 0, 1, 2, 3]`."
    ],
    "id": 39,
    "options": [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`"
    ],
    "problem": "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 1,
    "explanation": [
      "`null` \"НЕправдивий\". `!null` повертає `true`. `!true` повертає `false`.",
      "`\"\"` \"НЕправдивий\". `!\"\"` повертає `true`. `!true` повертає `false`.",
      "`1` \"правдивий\". `!1` повертає `false`. `!false` повертає `true`."
    ],
    "id": 40,
    "options": [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`"
    ],
    "problem": "!!null;\n!!\"\";\n!!1;\n",
    "question": "Що буде в консолі?"
  },
  {
    "answer": 0,
    "explanation": [
      "Це метод повертає унікальний id. Цей id може бути використаний для очищення інтервалу за допомогою функції `clearInterval()`."
    ],
    "id": 41,
    "options": [
      "унікальний id",
      "вказану кількість мілісекунд",
      "передану функцію",
      "`undefined`"
    ],
    "problem": "setInterval(() => console.log(\"Hi\"), 1000);\n",
    "question": "Що повертає метод `setInterval`?"
  },
  {
    "answer": 0,
    "explanation": [
      "Рядок є ітеріруемой сутністю. Оператор поширення перетворює кожен символ в окремий елемент."
    ],
    "id": 42,
    "options": [
      "`[\"L\", \"y\", \"d\", \"i\", \"a\"]`",
      "`[\"Lydia\"]`",
      "`[[], \"Lydia\"]`",
      "`[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`"
    ],
    "problem": "[...\"Lydia\"];\n",
    "question": "What does this return?"
  }
]