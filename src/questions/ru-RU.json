[
  {
    "answer": 3,
    "explanation": [
      "Внутри функции мы сперва определяем переменную `name` с помощью ключевого слова `var`. Это означает, что переменная будет поднята (область памяти под переменную будет выделена во время фазы создания) со значением `undefined` по умолчанию, до тех пора пока исполнение кода не дойдет до строчки, где определяется переменная. Мы еще не определили значение `name` когда пытаемся вывести её в консоль, поэтому в консоли будет `undefined`.",
      "Переменные, определенные с помощью `let` (и `const`), также поднимаются, но в отличие от `var`, не <i>инициализируются</i>. Доступ к ним не возможен до тех пор, пока не выполнится строка их определения (инициализации). Это называется \"временная мертвая зона\". Когда мы пытаемся обратиться к переменным до того момента как они определены, JavaScript выбрасывает исключение `ReferenceError`."
    ],
    "id": 0,
    "options": [
      "`Lydia` и `undefined`",
      "`Lydia` и `ReferenceError`",
      "`ReferenceError` и `21`",
      "`undefined` и `ReferenceError`"
    ],
    "problem": "function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = \"Lydia\";\n  let age = 21;\n}\n\nsayHi();\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 2,
    "explanation": [
      "Из-за очереди событий в JavaScript, функция `setTimeout` вызывается _после_ того как цикл будет завершен. Так как переменная `i` в первом цикле была определена с помощью `var`, она будет глобальной. В цикле мы каждый раз увеличиваем значение `i` на `1`, используя унарный оператор `++`. К моменту выполнения функции `setTimeout` значение `i` будет равно `3` в первом примере.",
      "Во втором цикле переменная `i` определена с помощью `let`. Такие переменные (а также `const`) имеют блочную область видимости (блок это что угодно между `{ }`). С каждой итерацией `i` будет иметь новое значение, и каждое значение будет замкнуто в своей области видимости внутри цикла."
    ],
    "id": 1,
    "options": [
      "`0 1 2` и `0 1 2`",
      "`0 1 2` и `3 3 3`",
      "`3 3 3` и `0 1 2`"
    ],
    "problem": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 1,
    "explanation": [
      "Заметь, что `diameter` это обычная функция, в то время как `perimeter` это стрелочная функция.",
      "У стрелочных функций значение `this` указывает на окружающую область видимости, в отличие от обычных функций! Это значит, что при вызове `perimeter` значение `this` у этой функции указывает не на объект `shape`, а на внешнюю область видимости (например, window).",
      "У этого объекта нет ключа `radius`, поэтому возвращается `undefined`."
    ],
    "id": 2,
    "options": [
      "`20` и `62.83185307179586`",
      "`20` и `NaN`",
      "`20` и `63`",
      "`NaN` и `63`"
    ],
    "problem": "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nshape.diameter();\nshape.perimeter();\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "Унарный плюс приводит операнд к числу. `true` это `1`, а `false` это `0`.",
      "Строка `'Lydia'` это \"истинное\" значение. На самом деле мы спрашиваем \"является ли это истинное значение ложным\"? Ответ: `false`."
    ],
    "id": 3,
    "options": [
      "`1` и `false`",
      "`false` и `NaN`",
      "`false` и `false`"
    ],
    "problem": "+true;\n!\"Lydia\";\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript все ключи объекта являются строками (кроме Symbol). И хотя мы не _набираем_ их как строки, они всегда преобразовываются к строкам под капотом.",
      "JavaScript интерпретирует (или распаковывает) операторы. При использовании квадратных скобок JS замечает `[` и продолжает пока не встретит `]`. Только после этого он вычислит то, что находится внутри скобок.",
      "`mouse[bird.size]`: Сперва определяется `bird.size`, которое равно `\"small\"`. `mouse[\"small\"]` возвращает `true`.",
      "Но с записью через точку так не происходит. У `mouse` нет ключа `bird`. Таким образом, `mouse.bird` равно `undefined`. Затем мы запрашиваем ключ `size`, используя точечную нотацию: `mouse.bird.size`. Так как `mouse.bird` это `undefined`, мы запрашиваем `undefined.size`. Это не является валидным, и мы получаем ошибку типа `Cannot read property \"size\" of undefined`."
    ],
    "id": 4,
    "options": [
      "`mouse.bird.size`",
      "`mouse[bird.size]`",
      "`mouse[bird[\"size\"]]`",
      "Все варианты валидны"
    ],
    "problem": "const bird = {\n  size: \"small\"\n};\n\nconst mouse = {\n  name: \"Mickey\",\n  small: true\n};\n",
    "question": "Что НЕ является валидным?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript все объекты являются _ссылочными_ типами данных.",
      "Сперва переменная `c` указывает на объект. Затем мы указываем переменной `d` ссылаться на тот же объект, что и `c`.",
      "<img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\">",
      "Когда ты изменяешь один объект, то изменяются значения всех ссылок, указывающих на этот объект."
    ],
    "id": 5,
    "options": [
      "`Hello`",
      "`Hey!`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "let c = { greeting: \"Hey!\" };\nlet d;\n\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 2,
    "explanation": [
      "`new Number()` это встроенный конструктор функции. И хотя он выглядит как число, это не настоящее число: у него есть ряд дополнительных фич и это объект.",
      "Оператор `==` разрешает приведение типов, он проверяет равенство _значений_. Оба значения равны `3`, поэтому возвращается `true`.",
      "При использовании оператора `===` значение _и_ тип должны быть одинаковыми. Но в нашем случае это не так: `new Number()` это не число, это **объект**. Оба возвращают `false`."
    ],
    "id": 6,
    "options": [
      "`true` `false` `true`",
      "`false` `false` `true`",
      "`true` `false` `false`",
      "`false` `true` `true`"
    ],
    "problem": "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 3,
    "explanation": [
      "Функция `colorChange` является статичной. Статичные методы не имеют доступа к экземплярам класса. Так как `freddie` это экземпляр, то статичный метод там не доступен. Поэтому выбрасывается ошибка `TypeError`."
    ],
    "id": 7,
    "options": [
      "`orange`",
      "`purple`",
      "`green`",
      "`TypeError`"
    ],
    "problem": "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = \"green\" } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: \"purple\" });\nfreddie.colorChange(\"orange\");\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "В консоли выведется объект, потому что мы только что создали пустой объект в глобальном объекте! Когда мы вместо `greeting` написали `greetign`, интерпретатор JS на самом деле выполнил `global.greetign = {}` (или `window.greetign = {}` в браузере).",
      "Нужно использовать `\"use strict\"`, чтобы избежать такого поведения. Эта запись поможет быть уверенным в том, что переменная была определена перед тем как ей присвоили значение."
    ],
    "id": 8,
    "options": [
      "`{}`",
      "`ReferenceErrorgreetign is not defined`",
      "`undefined`"
    ],
    "problem": "let greeting;\ngreetign = {}; // Опечатка!\nconsole.log(greetign);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript это возможно, т.к. функции это объекты! (Всё есть объект кроме примитивов).",
      "Функция — это специальный тип объекта, который можно вызвать. Кроме того, функция — это объект со свойствами. Свойство такого объекта нельзя вызвать, так как оно не является функцией."
    ],
    "id": 9,
    "options": [
      "Ничего, всё в порядке!",
      "`SyntaxError`. Нельзя добавлять свойства функциям таким способом.",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "function bark() {\n  console.log(\"Woof!\");\n}\n\nbark.animal = \"dog\";\n",
    "question": "Что произойдет?"
  },
  {
    "answer": 0,
    "explanation": [
      "Нельзя добавлять свойства конструктору, как обычному объекту. Если нужно добавить фичу всем объектам, то необходимо использовать прототипы. В данном случае",
      "сделает метод `member.getFullName()` рабочим. В чем тут преимущество? Предположим, что мы добавили этот метод к конструктору. Возможно, не каждому экземпляру `Person` нужен этот метод. Это приведет к большим потерям памяти, т.к. все экземпляры будут иметь это свойство. Напротив, если мы добавим этот метод только к прототипу, у нас будет только одно место в памяти, к которому смогут обращаться все экземпляры!"
    ],
    "id": 10,
    "options": [
      "`TypeError`",
      "`SyntaxError`",
      "`Lydia Hallie`",
      "`undefined` `undefined`"
    ],
    "problem": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n}\n\nconsole.log(member.getFullName());\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "Для `sarah` мы не использовали ключевое слово `new`. Использование `new` приводит к созданию нового объекта. Но без `new` он указывает на **глобальный объект**!",
      "Мы указали, что `this.firstName` равно `\"Sarah\"` и `this.lastName` равно `\"Smith\"`. На самом деле мы определили `global.firstName = 'Sarah'` и `global.lastName = 'Smith'`. `sarah` осталась `undefined`, поскольку мы не возвращаем значение из функции `Person`."
    ],
    "id": 11,
    "options": [
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` и `undefined`",
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` и `Person {firstName\"Sarah\", lastName\"Smith\"}`",
      "`Person {firstName\"Lydia\", lastName\"Hallie\"}` и `{}`",
      "\"Lydia\", lastName\"Hallie\"}` и `ReferenceError`"
    ],
    "problem": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person(\"Lydia\", \"Hallie\");\nconst sarah = Person(\"Sarah\", \"Smith\");\n\nconsole.log(lydia);\nconsole.log(sarah);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 3,
    "explanation": [
      "Во время фазы **захвата** событие распространяется с элементов родителей до элемента цели. После достижения **цели** начинается фаза **всплытия**.",
      "<img src=\"https://i.imgur.com/N18oRgd.png\" width=\"200\">"
    ],
    "id": 12,
    "options": [
      "Цель > Захват > Всплытие",
      "Всплытие > Цель > Захват",
      "Цель > Всплытие > Захват",
      "Захват > Цель > Всплытие"
    ],
    "problem": "",
    "question": "Назовите три фазы распространения событий"
  },
  {
    "answer": 1,
    "explanation": [
      "Все объекты имеют прототипы, кроме **базового объекта**. Базовый объект имеет доступ до некоторых методов и свойств, таких как `.toString`. Именно поэтому мы можем использовать встроенные методы JavaScript! Все эти методы доступны в прототипе. Если JavaScript не может найти метод непосредственно у объекта, он продолжает поиск по цепочке прототипов пока не найдет."
    ],
    "id": 13,
    "options": [
      "Да",
      "Нет"
    ],
    "problem": "",
    "question": "Все объекты имеют прототипы"
  },
  {
    "answer": 2,
    "explanation": [
      "JavaScript это **динамически типизированный язык**: мы не определяем тип переменных. Переменные могут автоматически быть преобразованы из одного типа в другой без нашего участия, что называется _неявным приведением типов_. **Приведение** это преобразование из одного типа в другой.",
      "В этом примере JavaScript сконвертировал число `1` в строку, чтобы операция внутри функции имела смысл и вернула значение. Во время сложения числа (`1`) и строки (`'2'`) число преобразовывается к строке. Мы можем конкатенировать строки вот так: `\"Hello\" + \"World\"`. Таким образом, `\"1\" + \"2\"` возвращает `\"12\"`."
    ],
    "id": 14,
    "options": [
      "`NaN`",
      "`TypeError`",
      "`\"12\"`",
      "`3`"
    ],
    "problem": "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, \"2\");\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 2,
    "explanation": [
      "**Постфиксный** унарный оператор `++`:",
      "Возвращает значение (`0`)",
      "Инкрементирует значение (теперь число равно `1`)",
      "**Префиксный** унарный оператор `++`:",
      "Инкрементирует значение (число теперь равно `2`)",
      "Возвращает значение (`2`)",
      "Результат: `0 2 2`."
    ],
    "id": 15,
    "options": [
      "`1` `1` `2`",
      "`1` `2` `2`",
      "`0` `2` `2`",
      "`0` `1` `2`"
    ],
    "problem": "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 1,
    "explanation": [
      "При использовании тегированных шаблонных литералов первым аргументом всегда будет массив строковых значений. Оставшимися аргументами будут значения переданных выражений!"
    ],
    "id": 16,
    "options": [
      "`\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`",
      "`[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`",
      "`\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`"
    ],
    "problem": "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = \"Lydia\";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 2,
    "explanation": [
      "В операциях сравнения примитивы сравниваются по их _значениям_, а объекты по _ссылкам_. JavaScript проверяет, чтобы объекты указывали на одну и ту же область памяти.",
      "Сравниваемые объекты в нашем примере не такие: объект, переданный в качестве параметра, указывает на другую область памяти, чем объекты, используемые в сравнениях.",
      "Поэтому `{ age: 18 } === { age: 18 }` и `{ age: 18 } == { age: 18 }` возвращают `false`."
    ],
    "id": 17,
    "options": [
      "`Ты взрослый!`",
      "`Ты все еще взрослый.`",
      "`Хмм.. Кажется, у тебя нет возраста.`"
    ],
    "problem": "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log(\"Ты взрослый!\");\n  } else if (data == { age: 18 }) {\n    console.log(\"Ты все еще взрослый.\");\n  } else {\n    console.log(`Хмм.. Кажется, у тебя нет возраста.`);\n  }\n}\n\ncheckAge({ age: 18 });\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 2,
    "explanation": [
      "Оператор распространения (`...args`) возвращает массив с аргументами. Массив это объект, поэтому `typeof args` возвращает `\"object\"`."
    ],
    "id": 18,
    "options": [
      "`\"number\"`",
      "`\"array\"`",
      "`\"object\"`",
      "`\"NaN\"`"
    ],
    "problem": "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 2,
    "explanation": [
      "Используя `\"use strict\"`, можно быть уверенным, что мы по ошибке не побъявим глобальные переменные. Мы ранее нигде не объявляли переменную `age`, поэтому с использованием `\"use strict\"` возникнет `ReferenceError`. Без использования `\"use strict\"` ошибки не возникнет, а переменная `age` добавится в глобальный объект."
    ],
    "id": 19,
    "options": [
      "`21`",
      "`undefined`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "function getAge() {\n  \"use strict\";\n  age = 21;\n  console.log(age);\n}\n\ngetAge();\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "`eval` выполняет код, переданный в виде строки. Если это выражение (как в данном случае), то вычисляется выражение. Выражение `10 * 10 + 5` вернет число `105`."
    ],
    "id": 20,
    "options": [
      "`105`",
      "`\"105\"`",
      "`TypeError`",
      "`\"10*10+5\"`"
    ],
    "problem": "const sum = eval(\"10*10+5\");\n",
    "question": "Чему будет равно `sum`?"
  },
  {
    "answer": 1,
    "explanation": [
      "Данные, сохраненные в `sessionStorage` очищаются после закрытия _вкладки_.",
      "При использовании `localStorage` данные сохраняются навсегда. Очистить их можно, например, используя `localStorage.clear()`."
    ],
    "id": 21,
    "options": [
      "Всегда, данные не потеряются.",
      "Пока пользователь не закроет вкладку.",
      "Пока пользователь не закроет браузер, а не только вкладку.",
      "Пока пользователь не выключит компьютер."
    ],
    "problem": "sessionStorage.setItem(\"cool_secret\", 123);\n",
    "question": "Как долго будет доступен cool_secret?"
  },
  {
    "answer": 1,
    "explanation": [
      "С помощью ключевого слова `var` можно определять сколько угодно переменных с одним и тем же именем. Переменная будет хранить последнее присвоенное значение.",
      "Но такой трюк нельзя проделать с `let` и `const`, т.к. у них блочная область видимости."
    ],
    "id": 22,
    "options": [
      "`8`",
      "`10`",
      "`SyntaxError`",
      "`ReferenceError`"
    ],
    "problem": "var num = 8;\nvar num = 10;\n\nconsole.log(num);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 2,
    "explanation": [
      "Все ключи объектов (кроме Symbols) являются строками, даже если заданы не в виде строк. Поэтому `obj.hasOwnProperty('1')` так же возвращает true.",
      "Но это не работает для `set`. Значения `'1'` нет в `set`: `set.has('1')` возвращает `false`. Но `set.has(1)` вернет `true`."
    ],
    "id": 23,
    "options": [
      "`false` `true` `false` `true`",
      "`false` `true` `true` `true`",
      "`true` `true` `false` `true`",
      "`true` `true` `true` `true`"
    ],
    "problem": "const obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(\"1\");\nobj.hasOwnProperty(1);\nset.has(\"1\");\nset.has(1);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 2,
    "explanation": [
      "Если есть два ключа с одинаковым именем, то ключ будет перезаписан. Его позиция сохранится, но значением будет последнее указанное."
    ],
    "id": 24,
    "options": [
      "`{ a\"one\", b\"two\" }`",
      "`{ b\"two\", a\"three\" }`",
      "`{ a\"three\", b\"two\" }`",
      "`SyntaxError`"
    ],
    "problem": "const obj = { a: \"one\", b: \"two\", a: \"three\" };\nconsole.log(obj);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "Базовый контекст исполнения это глобальный контекст исполнения: это то, что доступно где угодно в твоем коде."
    ],
    "id": 25,
    "options": [
      "Да",
      "Нет",
      "Это зависит"
    ],
    "problem": "",
    "question": "Глобальный контекст исполнения создает две вещи: глобальный объект и `this`"
  },
  {
    "answer": 2,
    "explanation": [
      "Оператор `continue` пропускает итерацию, если условие возвращает `true`."
    ],
    "id": 26,
    "options": [
      "`1` `2`",
      "`1` `2` `3`",
      "`1` `2` `4`",
      "`1` `3` `4`"
    ],
    "problem": "for (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "`String` это встроенный конструктор, к которому можно добавлять свойства. Я добавила метод к его прототипу. Строки-примитивы автоматически конвертируются к строкам-объектам. Поэтому все строки (строковые объекты) имеют доступ к этому методу!"
    ],
    "id": 27,
    "options": [
      "`\"Just give Lydia pizza already!\"`",
      "`TypeErrornot a function`",
      "`SyntaxError`",
      "`undefined`"
    ],
    "problem": "String.prototype.giveLydiaPizza = () => {\n  return \"Just give Lydia pizza already!\";\n};\n\nconst name = \"Lydia\";\n\nname.giveLydiaPizza();\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "Ключи объекта автоматически конвертируются в строки. Мы собираемся добавить объект в качестве ключа к объекту `a` со значением `123`.",
      "Тем не менее, когда мы приводим объект к строке, он становится `\"[object Object]\"`. Таким образом, мы говорим, что `a[\"object Object\"] = 123`. Потом мы делаем то же самое. `c` это другой объект, который мы неявно приводим к строке. Поэтому `a[\"object Object\"] = 456`.",
      "Затем, когда мы выводим `a[b]`, мы имеем в виду `a[\"object Object\"]`. Мы только что установили туда значение `456`, поэтому в результате получаем `456`."
    ],
    "id": 28,
    "options": [
      "`123`",
      "`456`",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "const a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 1,
    "explanation": [
      "Мы вызываем функцию `setTimeout` первой. Тем не менее, она выводится в консоль последней",
      "Это происходит из-за того, что в браузерах у нас есть не только рантайм движок, но и `WebAPI`. `WebAPI` предоставляет нам функцию `setTimeout` и много других возможностей. Например, DOM.",
      "После того как _коллбек_ отправлен в `WebAPI`, функция `setTimeout` (но не коллбек!) вынимается из стека.",
      "<img src=\"https://i.imgur.com/X5wsHOg.png\" width=\"200\">",
      "Теперь вызывается `foo`, и `\"First\"` выводится в консоль.",
      "<img src=\"https://i.imgur.com/Pvc0dGq.png\" width=\"200\">",
      "`foo` достается из стека, и вызывается `baz`. `\"Third\"` выводится в консоль.",
      "<img src=\"https://i.imgur.com/WhA2bCP.png\" width=\"200\">",
      "WebAPI не может добавлять содержимое в стек когда захочет. Вместо этого он отправляет коллбек-функцию в так называемую _очередь_.",
      "<img src=\"https://i.imgur.com/NSnDZmU.png\" width=\"200\">",
      "Здесь на сцену выходит цикл событий (event loop). **Event loop** проверяет стек и очередь задач. Если стек пустой, то он берет первый элемент из очереди и отправляет его в стек.",
      "<img src=\"https://i.imgur.com/uyiScAI.png\" width=\"200\">",
      "Вызывается `bar`, в консоль выводится `\"Second\"` и эта функция достается из стека."
    ],
    "id": 29,
    "options": [
      "`First` `Second` `Third`",
      "`First` `Third` `Second`",
      "`Second` `First` `Third`",
      "`Second` `Third` `First`"
    ],
    "problem": "const foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"));\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 2,
    "explanation": [
      "Целью события является самый глубокий вложенный элемент. Остановить распространение событий можно с помощью `event.stopPropagation`"
    ],
    "id": 30,
    "options": [
      "Внешний `div`",
      "Внутренний `div`",
      "`button`",
      "Массив со всеми вложенными элементами"
    ],
    "problem": "<div onclick=\"console.log('first div')\">\n  <div onclick=\"console.log('second div')\">\n    <button onclick=\"console.log('button')\">\n      Кликни!\n    </button>\n  </div>\n</div>\n",
    "question": "Что будет в event.target после клика на кнопку?"
  },
  {
    "answer": 0,
    "explanation": [
      "После клика по `p` будет выведено `p` и `div`. В цикле жизни события есть три фазы: захват, цель и всплытие. По умолчанию обработчики событий выполняются на фазе всплытия (если не установлен параметр `useCapture` в `true`). Всплытие идет с самого глубокого элемента вверх."
    ],
    "id": 31,
    "options": [
      "`p` `div`",
      "`div` `p`",
      "`p`",
      "`div`"
    ],
    "problem": "<div onclick=\"console.log('div')\">\n  <p onclick=\"console.log('p')\">\n    Кликни меня!\n  </p>\n</div>\n",
    "question": "Что будет в консоли после клика по параграфу?"
  },
  {
    "answer": 3,
    "explanation": [
      "В обоих случаях мы передаем объект, на который будет указывать `this`. Но `.call` _выполняется сразу же_!",
      "`.bind` возвращает _копию_ функции, но с привязанным контекстом. Она не выполняется незамедлительно."
    ],
    "id": 32,
    "options": [
      "`undefined is 21` `Lydia is 21`",
      "`function` `function`",
      "`Lydia is 21` `Lydia is 21`",
      "`Lydia is 21` `function`"
    ],
    "problem": "const person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 1,
    "explanation": [
      "Функция `sayHi` возвращает значение, возвращаемое из немедленно вызываемого функционального выражения (IIFE). Результатом является `0` типа `\"number\"`.",
      "Для информации: в JS 7 встроенных типов: `null`, `undefined`, `boolean`, `number`, `string`, `object`, и `symbol`. `\"function\"` не является отдельным типом, т.к. функции являются объектами типа `\"object\"`.\n</p>\n</details>"
    ],
    "id": 33,
    "options": [
      "`\"object\"`",
      "`\"number\"`",
      "`\"function\"`",
      "`\"undefined\"`"
    ],
    "problem": "function sayHi() {\n  return (() => 0)();\n}\n\ntypeof sayHi();\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "Есть только шесть \"ложных\" значений:",
      "`undefined`",
      "`null`",
      "`NaN`",
      "`0`",
      "`''` (пустая строка)",
      "`false`",
      "Конструкторы функций, такие как `new Number` и `new Boolean` являются \"истинными\"."
    ],
    "id": 34,
    "options": [
      "`0`, `''`, `undefined`",
      "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
      "`0`, `''`, `new Boolean(false)`, `undefined`",
      "Все являются \"ложными\""
    ],
    "problem": "0;\nnew Number(0);\n(\"\");\n(\" \");\nnew Boolean(false);\nundefined;\n",
    "question": "Какие из этих значений являются \"ложными\"?"
  },
  {
    "answer": 1,
    "explanation": [
      "`typeof 1` возвращает `\"number\"`.\n`typeof \"number\"` возвращает `\"string\"`"
    ],
    "id": 35,
    "options": [
      "`\"number\"`",
      "`\"string\"`",
      "`\"object\"`",
      "`\"undefined\"`"
    ],
    "problem": "console.log(typeof typeof 1);\n",
    "question": "Что будет в консоли"
  },
  {
    "answer": 2,
    "explanation": [
      "Когда в массив добавляется значение, которое выходит за пределы длины массива, JavaScript создает так называемые \"пустые ячейки\". На самом деле они имеют значения `undefined`, но в консоли выводятся так:",
      "`[1, 2, 3, 7 x empty, 11]`",
      "в зависимости от окружения (может отличаться для браузеров, Node, и т.д.)."
    ],
    "id": 36,
    "options": [
      "`[1, 2, 3, 7 x null, 11]`",
      "`[1, 2, 3, 11]`",
      "`[1, 2, 3, 7 x empty, 11]`",
      "`SyntaxError`"
    ],
    "problem": "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "Блок `catch` получает аргумент `x`. Это не тот же `x`, который определен в качестве переменной перед строкой `try {`",
      "Затем мы присваиваем этому аргументу значение `1` и устанавливаем значение для переменной `y`. Потом выводим в консоль значение аргумента `x`, которое равно `1`.",
      "За пределами блока `catch` переменная `x` все еще `undefined`, а `y` равно `2`. Когда мы вызываем `console.log(x)` за пределами блока `catch`, этот вызов возвращает `undefined`, а `y` возвращает `2`."
    ],
    "id": 37,
    "options": [
      "`1` `undefined` `2`",
      "`undefined` `undefined` `undefined`",
      "`1` `1` `2`",
      "`1` `undefined` `undefined`"
    ],
    "problem": "(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n",
    "question": "Что будет в консоли?"
  },
  {
    "answer": 0,
    "explanation": [
      "В JavaScript есть только примитивы и объекты.",
      "Типы примитивов: `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, и `symbol`.",
      "Отличием примитива от объекта является то, что примитивы не имеют свойств или методов. Тем не менее, `'foo'.toUpperCase()` преобразуется в `'FOO'` и не вызывает `TypeError`. Это происходит потому, что при попытке получения свойства или метода у примитива (например, строки), JavaScript неявно обернет примитив объектом, используя один из классов-оберток (например, `String`), а затем сразу же уничтожит обертку после вычисления выражения. Все примитивы кроме `null` и `undefined` ведут себя таким образом."
    ],
    "id": 38,
    "options": [
      "примитив или объект",
      "функция или объект",
      "вопрос с подвохом! только объекты",
      "число или объект"
    ],
    "problem": "",
    "question": "Всё в JavaScript это"
  },
  {
    "answer": 2,
    "explanation": [
      "`[1, 2]` - начальное значение, с которым инициализируется переменная `acc`. После первого прохода `acc` будет равно `[1,2]`, а `cur` будет `[0,1]`. После конкатенации результат будет `[1, 2, 0, 1]`.",
      "Затем `acc` равно `[1, 2, 0, 1]`, а `cur` равно `[2, 3]`. После слияния получим `[1, 2, 0, 1, 2, 3]`."
    ],
    "id": 39,
    "options": [
      "`[0, 1, 2, 3, 1, 2]`",
      "`[6, 1, 2]`",
      "`[1, 2, 0, 1, 2, 3]`",
      "`[1, 2, 6]`"
    ],
    "problem": "[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "`null` - \"ложный\". `!null` возвращает `true`. `!true` возвращает `false`.",
      "`\"\"` - \"ложный\". `!\"\"` возвращает `true`. `!true` возвращает `false`.",
      "`1` - \"истинный\". `!1` возвращает `false`. `!false` возвращает `true`."
    ],
    "id": 40,
    "options": [
      "`false` `true` `false`",
      "`false` `false` `true`",
      "`false` `true` `true`",
      "`true` `true` `false`"
    ],
    "problem": "!!null;\n!!\"\";\n!!1;\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "Это метод возвращает уникальный id. Этот id может быть использован для очищения интервала с помощью функции `clearInterval()`."
    ],
    "id": 41,
    "options": [
      "уникальный id",
      "указанное количество миллисекунд",
      "переданную функцию",
      "`undefined`"
    ],
    "problem": "setInterval(() => console.log(\"Hi\"), 1000);\n",
    "question": "Что возвращает метод `setInterval`?"
  },
  {
    "answer": 0,
    "explanation": [
      "Строка является итерируемой сущностью. Оператор распространения преобразовывает каждый символ в отдельный элемент."
    ],
    "id": 42,
    "options": [
      "`[\"L\", \"y\", \"d\", \"i\", \"a\"]`",
      "`[\"Lydia\"]`",
      "`[[], \"Lydia\"]`",
      "`[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`"
    ],
    "problem": "[...\"Lydia\"];\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 2,
    "explanation": [
      "Обычные функции не могут быть остановлены на полпути после вызова. Однако функцию генератор можно \"остановить\" на полпути, а затем продолжить с того места, где она остановилась. Каждый раз, когда в функции-генераторе встречает ключевое слово `yield`, функция возвращает значение, указанное после него. Обратите внимание, что функция генератора в этом случае не _return_ значение, оно _yields_ значение.",
      "Сначала мы инициализируем функцию генератор с `i`, равным `10`. Мы вызываем функцию генератор, используя метод `next ()`. Когда мы в первый раз вызываем функцию генератора, `i` равно `10`. Он встречает первое ключевое слово `yield`, получая значение `i`. Генератор теперь \"приостановлен\", и `10` выводится в консоль.",
      "Затем мы снова вызываем функцию с помощью метода `next ()`. Она запускается с того места, где остановилась ранее, все еще с `i`, равным `10`. Теперь он встречает следующее ключевое слово `yield` и возвращает `i * 2`. `i` равно `10`, поэтому он возвращает `10 * 2`, то есть `20`. Это приводит к 10, 20."
    ],
    "id": 43,
    "options": [
      "`[0, 10], [10, 20]`",
      "`20, 20`",
      "`10, 20`",
      "`0, 10 and 10, 20`"
    ],
    "problem": "function* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "Когда мы передаем несколько промисов методу `Promise.race`, он разрешает/отклоняет _первый_ промис, который разрешается/отклоняется. В метод `setTimeout` мы передаем таймер: 500 мс для первого промиса (`firstPromise`) и 100 мс для второго промиса (`secondPromise`). Это означает, что `secondPromise` разрешается первым со значением `'два'`. `res` теперь содержит значение `'два'`, которое выводиться в консоль."
    ],
    "id": 44,
    "options": [
      "`\"один\"`",
      "`\"два\"`",
      "`\"два\" \"один\"`",
      "`\"один\" \"два\"`"
    ],
    "problem": "const firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, \"один\");\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, \"два\");\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 3,
    "explanation": [
      "Сначала мы объявляем переменную `person` со значением объекта, у которого есть свойство` name`.",
      "<img src=\"https://i.imgur.com/TML1MbS.png\" width=\"200\">",
      "Затем мы объявляем переменную с именем `members`. Мы устанавливаем первый элемент этого массива равным значению переменной `person`. Объекты взаимодействуют посредством _ссылок_ при установке их равными друг другу. Когда вы назначаете ссылку из одной переменной в другую, вы создаете _копию_ этой ссылки. (обратите внимание, что у них _не одинаковые_ ссылки!)",
      "<img src=\"https://i.imgur.com/FSG5K3F.png\" width=\"300\">",
      "Затем мы присваиваем переменной `person` значение `null`.",
      "<img src=\"https://i.imgur.com/sYjcsMT.png\" width=\"300\">",
      "Мы изменили только значение переменной `person`, а не первый элемент в массиве, поскольку этот элемент имеет другую (скопированную) ссылку на объект. Первый элемент в `members` по-прежнему содержит ссылку на исходный объект. Когда мы выводим в консоль массив `members`, первый элемент по-прежнему содержит значение объекта, который выводится в консоль."
    ],
    "id": 45,
    "options": [
      "`null`",
      "`[null]`",
      "`[{}]`",
      "`[{ name\"Lydia\" }]`"
    ],
    "problem": "let person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "С помощью цикла `for-in` мы можем перебирать ключи объекта, в данном случае `name` и `age`. Под капотом ключи объекта являются строками (если они не являются Symbol). В каждом цикле мы устанавливаем значение `item` равным текущему ключу, по которому он перебирается. Сначала, `item` равен `name`, и выводится в консоль. Затем `item` равен `age`, который выводится в консоль."
    ],
    "id": 46,
    "options": [
      "`{ name\"Lydia\" }, { age21 }`",
      "`\"name\", \"age\"`",
      "`\"Lydia\", 21`",
      "`[\"name\", \"Lydia\"], [\"age\", 21]`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n};\n\nfor (const item in person) {\n  console.log(item);\n}\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "Ассоциативность операторов - это порядок, в котором компилятор оценивает выражения, слева направо или справа налево. Это происходит только в том случае, если все операторы имеют _одинаковый_ приоритет. У нас есть только один тип оператора: `+`. Кроме того, ассоциативность слева направо.",
      "`3 + 4` оценивается первым. Это приводит к числу `7`.",
      "`7 + '5'` приводит к `\"75\"` из-за принуждения. JavaScript преобразует число `7` в строку, см. вопрос 15. Мы можем объединить две строки, используя оператор `+`. `\"7\" + \"5\"` приводит к `\"75\"`."
    ],
    "id": 47,
    "options": [
      "`\"345\"`",
      "`\"75\"`",
      "`12`",
      "`\"12\"`"
    ],
    "problem": "console.log(3 + 4 + \"5\");\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 2,
    "explanation": [
      "Только первые числа в строке возвращаются. На основе _системы счисления_ (второй аргумент, чтобы указать, к какому типу чисел мы хотим его анализировать: основание 10, шестнадцатеричное, восьмеричное, двоичное и т.д.), `ParseInt` проверяет, являются ли символы в строке допустимыми. Как только он встречает символ, который не является допустимым числом в основании, он прекращает синтаксический анализ и игнорирует следующие символы.",
      "`*` не является допустимым числом. Он только разбирает `\"7\"` в десятичную `7`. `num` теперь содержит значение` 7`."
    ],
    "id": 48,
    "options": [
      "`42`",
      "`\"42\"`",
      "`7`",
      "`NaN`"
    ],
    "problem": "const num = parseInt(\"7*6\", 10);\n",
    "question": "Какое значение `num`?"
  },
  {
    "answer": 2,
    "explanation": [
      "При использовании метода map, значение `num` равно элементу, над которым он в данный момент зацикливается. В этом случае элементы являются числами, поэтому условие оператора if `typeof num === \"number\"` возвращает `true`. Функция map создает новый массив и вставляет значения, возвращаемые функцией.",
      "Однако мы не возвращаем значение. Когда мы не возвращаем значение из функции, функция возвращает значение `undefined`. Для каждого элемента в массиве вызывается функциональный блок, поэтому для каждого элемента мы возвращаем `undefined`."
    ],
    "id": 49,
    "options": [
      "`[]`",
      "`[null, null, null]`",
      "`[undefined, undefined, undefined]`",
      "`[ 3 x empty ]`"
    ],
    "problem": "[1, 2, 3].map(num => {\n  if (typeof num === \"number\") return;\n  return num * 2;\n});\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "Аргументы передаются _значением_, если их значение не является объектом, то они передаются _ссылкой_. `birthYear` передается по значению, поскольку это строка, а не объект. Когда мы передаем аргументы по значению, создается _копия_ этого значения (см. вопрос 46).",
      "Переменная `birthYear` имеет ссылку на значение `\"1997\"`. Аргумент `year` также имеет ссылку на значение` \"1997\" `, но это не то же самое значение, на которое имеется ссылка для `birthYear`. Когда мы обновляем значение `year`, устанавливая `year` равным `\"1998\"`, мы обновляем только значение `year`. `birthYear` по-прежнему равно `\"1997\"`.",
      "Значение `person` является объектом. Аргумент `member` имеет (скопированную) ссылку на _тот же_ объект. Когда мы изменяем свойство объекта, на который `member` ссылается, значение `person` также будет изменено, поскольку они оба имеют ссылку на один и тот же объект. Свойство `name` объекта `person` теперь равно значению `\"Lydia\"`."
    ],
    "id": 50,
    "options": [
      "`{ name\"Lydia\" }, \"1997\"`",
      "`{ name\"Sarah\" }, \"1998\"`",
      "`{ name\"Lydia\" }, \"1998\"`",
      "`{ name\"Sarah\" }, \"1997\"`"
    ],
    "problem": "function getInfo(member, year) {\n  member.name = \"Lydia\";\n  year = 1998;\n}\n\nconst person = { name: \"Sarah\" };\nconst birthYear = \"1997\";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 3,
    "explanation": [
      "С помощью оператора `throw` мы можем создавать собственные ошибки. С этим оператором вы можете генерировать исключения. Исключением может быть <b>строка</b>, <b>число</b>, <b>логическое значение</b> или <b>объект</b>. В этом случае нашим исключением является строка `'Hello world'`.",
      "С помощью оператора `catch` мы можем указать, что делать, если в блоке` try` выдается исключение. Исключение: строка `'Hello world'`. `e` теперь равно той строке, которую мы записываем. Это приводит к `'Oh error: Hello world'`."
    ],
    "id": 51,
    "options": [
      "`It worked! Hello world!`",
      "`Oh no an errorundefined`",
      "`SyntaxErrorcan only throw Error objects`",
      "`Oh no an errorHello world!`"
    ],
    "problem": "function greeting() {\n  throw \"Hello world!\";\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log(\"It worked!\", data);\n  } catch (e) {\n    console.log(\"Oh no an error:\", e);\n  }\n}\n\nsayHi();\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 1,
    "explanation": [
      "Когда вы возвращаете свойство, значение свойства равно _возвращаемому_ значению, а не значению, установленному в функции конструктора. Мы возвращаем строку `\"Maserati\"`, поэтому `myCar.make` равно `\"Maserati\"`."
    ],
    "id": 52,
    "options": [
      "`\"Lamborghini\"`",
      "`\"Maserati\"`",
      "`ReferenceError`",
      "`TypeError`"
    ],
    "problem": "function Car() {\n  this.make = \"Lamborghini\";\n  return { make: \"Maserati\" };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "`let x = y = 10;` на самом деле является сокращением для:",
      "Когда мы устанавливаем `y` равным` 10`, мы фактически добавляем свойство `y` к глобальному объекту (`window` в браузере, `global` в Node). В браузере `window.y` теперь равен` 10`.",
      "Затем мы объявляем переменную `x` со значением `y`, которое равно `10`. Переменные, объявленные с ключевым словом `let`, имеют _блочную видимость_, они определены только в блоке, в котором они объявлены; немедленно вызванная функция (IIFE) в этом случае. Когда мы используем оператор `typeof`, операнд `x` не определен: мы пытаемся получить доступ к `x` вне блока, в котором он объявлен. Это означает, что `x` не определен. Значения, которым не присвоено или не объявлено значение, имеют тип `\"undefined\"`. `console.log(typeof x)` возвращает `\"undefined\"`.",
      "Однако мы создали глобальную переменную `y`, установив `y` равным `10`. Это значение доступно в любом месте нашего кода. `y` определен и содержит значение типа `\"number\"`. `console.log(typeof y)` возвращает `\"number\"`."
    ],
    "id": 53,
    "options": [
      "`\"undefined\", \"number\"`",
      "`\"number\", \"number\"`",
      "`\"object\", \"number\"`",
      "`\"number\", \"undefined\"`"
    ],
    "problem": "(() => {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n",
    "question": "Каким будет результат?"
  },
  {
    "answer": 0,
    "explanation": [
      "Мы можем удалить свойства из объектов, используя ключевое слово `delete`, также в прототипе. Удаляя свойство в прототипе, оно больше не доступно в цепочке прототипов. В этом случае функция `bark` больше не доступна в прототипе после`delete Dog.prototype.bark`, но мы все еще пытаемся получить к ней доступ.",
      "Когда мы пытаемся вызвать что-то, что не является функцией, выдается `TypeError`. В этом случае `TypeError: pet.bark не является функцией`, поскольку` pet.bark` является `undefined`."
    ],
    "id": 54,
    "options": [
      "`\"Woof I am Mara\"`, `TypeError`",
      "`\"Woof I am Mara\"`, `\"Woof I am Mara\"`",
      "`\"Woof I am Mara\"`, `undefined`",
      "`TypeError`, `TypeError`"
    ],
    "problem": "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog(\"Mara\");\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "Объект `Set` является коллекцией _unique_ значений: значение может появляться только один раз в наборе.",
      "Мы передали последовательность `[1, 1, 2, 3, 4]` с повторяющимся значением `1`. Поскольку в наборе не может быть двух одинаковых значений, одно из них удаляется. Это приводит к `{1, 2, 3, 4}`."
    ],
    "id": 55,
    "options": [
      "`[1, 1, 2, 3, 4]`",
      "`[1, 2, 3, 4]`",
      "`{1, 1, 2, 3, 4}`",
      "`{1, 2, 3, 4}`"
    ],
    "problem": "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Импортированный модуль является _read-only_: вы не можете изменить импортированный модуль. Только модуль, который их экспортирует, может изменить его значение.",
      "Когда мы пытаемся увеличить значение `myCounter`, выдается ошибка: `myCounter` доступен только для чтения и не может быть изменен."
    ],
    "id": 56,
    "options": [
      "`10`",
      "`11`",
      "`Error`",
      "`NaN`"
    ],
    "problem": "// counter.js\nlet counter = 10;\nexport default counter;\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Оператор `delete` возвращает логическое значение: `true` при успешном удалении, иначе он вернет `false`. Однако переменные, объявленные с ключевым словом `var`,` const` или `let`, не могут быть удалены с помощью оператора` delete`.",
      "Переменная `name` была объявлена ​​с ключевым словом `const`, поэтому ее удаление не было успешным: возвращается `false`. Когда мы устанавливаем `age` равным `21`, мы фактически добавляем свойство с именем `age` к глобальному объекту. Вы можете успешно удалить свойства из объектов, в том числе из глобального объекта, поэтому `delete age` возвращает `true`."
    ],
    "id": 57,
    "options": [
      "`false`, `true`",
      "`\"Lydia\"`, `21`",
      "`true`, `true`",
      "`undefined`, `undefined`"
    ],
    "problem": "const name = \"Lydia\";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Мы можем распаковать значения из массивов или свойств из объектов путем деструктуризации. Например:",
      "<img src=\"https://i.imgur.com/ADFpVop.png\" width=\"200\">",
      "Значение `a` теперь равно `1`, а значение `b` теперь равно `2`. Что мы на самом деле сделали в этом вопросе, так это:",
      "<img src=\"https://i.imgur.com/NzGkMNk.png\" width=\"200\">",
      "Это означает, что значение `y` равно первому значению в массиве, которое является числом` 1`. Когда мы регистрируем `y`, возвращается `1`."
    ],
    "id": 58,
    "options": [
      "`[[1, 2, 3, 4, 5]]`",
      "`[1, 2, 3, 4, 5]`",
      "`1`",
      "`[1]`"
    ],
    "problem": "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "Можно комбинировать объекты с помощью оператора распространения `...`. Это позволяет создавать копии пар ключ/значение одного объекта и добавлять их в другой объект. В этом случае мы создаем копии объекта `user` и добавляем их в объект `admin`. Объект `admin` теперь содержит скопированные пары ключ/значение, что приводит к `{admin: true, name: \"Lydia\", age: 21}`."
    ],
    "id": 59,
    "options": [
      "`{ admintrue, user{ name\"Lydia\", age21 } }`",
      "`{ admintrue, name\"Lydia\", age21 }`",
      "`{ admintrue, user[\"Lydia\", 21] }`",
      "`{ admintrue }`"
    ],
    "problem": "const user = { name: \"Lydia\", age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "С помощью метода `defineProperty` мы можем добавлять новые свойства к объекту или изменять существующие. Когда мы добавляем свойство к объекту с помощью метода `defineProperty`, они по умолчанию _не перечисляемые_. Метод `Object.keys` возвращает все имена _enumerable_ свойств объекта, в данном случае только `\"name\"`.",
      "Свойства, добавленные с помощью метода `defineProperty`, по умолчанию неизменны. Вы можете переопределить это поведение, используя свойства `writable`, `configurable` и `enumerable`. Таким образом, метод `defineProperty` дает вам гораздо больший контроль над свойствами, которые вы добавляете к объекту."
    ],
    "id": 60,
    "options": [
      "`{ name\"Lydia\", age21 }`, `[\"name\", \"age\"]`",
      "`{ name\"Lydia\", age21 }`, `[\"name\"]`",
      "`{ name\"Lydia\"}`, `[\"name\", \"age\"]`",
      "`{ name\"Lydia\"}`, `[\"age\"]`"
    ],
    "problem": "const person = { name: \"Lydia\" };\n\nObject.defineProperty(person, \"age\", { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Второй аргумент `JSON.stringify` - это _replacer_. Заменитель может быть либо функцией, либо массивом, и позволяет вам контролировать, что и как должны быть преобразованы в значения.",
      "Если заменитель является _массивом_, только свойства, имена которых включены в массив, будут добавлены в строку JSON. В этом случае включаются только свойства с именами `\"level\"` и `\"health\"`, `\"username\"` исключается. `data` теперь равен `\"{\"level\":19, \"health\":90}\"`.",
      "Если заменитель является _function_, эта функция вызывается для каждого свойства объекта, который вы преобразуете. Значение, возвращаемое из этой функции, будет значением свойства при добавлении в строку JSON. Если значение равно undefined, это свойство исключается из строки JSON."
    ],
    "id": 61,
    "options": [
      "`\"{\"level\":19, \"health\":90}\"`",
      "`\"{\"username\"\"lydiahallie\"}\"`",
      "`\"[\"level\", \"health\"]\"`",
      "`\"{\"username\"\"lydiahallie\", \"level\":19, \"health\":90}\"`"
    ],
    "problem": "const settings = {\n  username: \"lydiahallie\",\n  level: 19,\n  health: 90\n};\n\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\nconsole.log(data);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Унарный оператор `++` _first возвращает_ значение операнда, _then приращивает_ значение операнда. Значение `num1` равно `10`, так как функция увеличений вначале возвращает значение `num`, которое равно `10`, и только затем увеличивает значение `num`.",
      "`num2` - это `10`, так как мы передали `num1` в `incpasePassedNumber`. `number` равно `10` (значение `num1`. Опять же, унарный оператор `++` _first возвращает_ значение операнда, _then увеличивает значение операнда. Значение `number` равно `10`, поэтому `num2` равно `10`."
    ],
    "id": 62,
    "options": [
      "`10`, `10`",
      "`10`, `11`",
      "`11`, `11`",
      "`11`, `12`"
    ],
    "problem": "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "В ES6 мы можем инициализировать параметры значением по умолчанию. Значением параметра будет значение по умолчанию, если никакое другое значение не было передано функции, или если значение параметра равно `\"undefined\"`. В этом случае мы распространяем свойства объекта `value` на новый объект, поэтому значение `x` по умолчанию равно `{number: 10}`.",
      "Аргумент по умолчанию реализуется в момент _call time_! Каждый раз, когда мы вызываем функцию, создается _new_ объект. Мы вызываем функцию `multiply` первые два раза, не передавая значение: `x` имеет значение по умолчанию `{number: 10}`. Затем мы записываем умноженное значение этого числа, которое равно `20`.",
      "В третий раз, когда мы вызываем multiply, мы передаем аргумент: объект с именем `value`. Оператор `*=` на самом деле является сокращением для `x.number = x.number * 2`: мы изменяем значение `x.number` и записываем умноженное значение `20`.",
      "В четвертый раз мы снова передаем объект `value`. `x.number` ранее был изменен на `20`, поэтому `x.number * = 2` записывает `40`."
    ],
    "id": 63,
    "options": [
      "`20`, `40`, `80`, `160`",
      "`20`, `40`, `20`, `40`",
      "`20`, `20`, `20`, `40`",
      "`NaN`, `NaN`, `20`, `40`"
    ],
    "problem": "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "Первым аргументом, который получает метод `reduce`, является _аккумулятором_, в данном случае `x`. Второй аргумент - это _текущее значение_, `y`. С помощью метода `reduce` мы выполняем функцию обратного вызова для каждого элемента в массиве, что в конечном итоге может привести к единственному значению.",
      "В этом примере мы не возвращаем никаких значений, мы просто регистрируем значения аккумулятора и текущее значение.",
      "Значение аккумулятора равно ранее возвращенному значению функции обратного вызова. Если вы не передадите необязательный аргумент `initialValue` методу `reduce`, аккумулятор будет равен первому элементу при первом вызове.",
      "При первом вызове аккумулятор (`x`) равен `1`, а текущее значение (`y`) равно `2`. Мы не возвращаемся из функции обратного вызова, мы регистрируем аккумулятор и текущее значение: `1` и `2` регистрируются.",
      "Если вы не возвращаете значение из функции, она возвращает значение `undefined`. При следующем вызове аккумулятор равен `undefined`, а текущее значение равно 3. `undefined` и `3` будут зарегистрированы.",
      "При четвертом вызове мы снова не возвращаемся из функции обратного вызова. Аккумулятор снова равен `undefined`, а текущее значение равно `4`. `undefined` и` 4` будут зарегистрированы.\n</p>\n</details>"
    ],
    "id": 64,
    "options": [
      "`1` `2`, `3` `3` и `6` `4`",
      "`1` `2`, `2` `3` и `3` `4`",
      "`1` `undefined`, `2` `undefined`, `3` `undefined` и `4` `undefined`",
      "`1` `2`, `undefined` `3` и `undefined` `4`"
    ],
    "problem": "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "В производном классе вы не можете получить доступ к ключевому слову `this` до вызова `super`. Если вы попытаетесь это сделать, он выдаст ReferenceError: 1 и 4 приведут к ошибке ссылки.",
      "С ключевым словом `super` мы вызываем конструктор родительского класса с заданными аргументами. Конструктор родителя получает аргумент `name`, поэтому нам нужно передать `name` в `super`.",
      "Класс `Labrador` получает два аргумента: `name`, поскольку он расширяет `Dog`, и `size` в качестве дополнительного свойства класса `Labrador`. Они оба должны быть переданы в функцию конструктора в `Labrador`, что делается правильно с помощью конструктора 2.\n</p>\n</details>"
    ],
    "id": 65,
    "options": [
      "1",
      "2",
      "3",
      "4"
    ],
    "problem": "class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1\n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4\n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};\n",
    "question": "С помощью какого конструктора мы можем успешно расширить класс `Dog`?"
  },
  {
    "answer": 1,
    "explanation": [
      "С ключевым словом `import` все импортируемые модули являются _pre-parsed_. Это означает, что импортированные модули запускаются _первыми_, код в файле, который импортирует модуль, исполняется _после_.",
      "В этом разница между `require()` в CommonJS и `import`! С помощью `require()` вы можете загружать зависимости по требованию во время выполнения кода. Если бы мы использовали `require` вместо `import`, в консоль были бы записаны `running index.js`, `running sum.js`, `3`."
    ],
    "id": 66,
    "options": [
      "`running index.js`, `running sum.js`, `3`",
      "`running sum.js`, `running index.js`, `3`",
      "`running sum.js`, `3`, `running index.js`",
      "`running index.js`, `undefined`, `running sum.js`"
    ],
    "problem": "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Каждый `Symbol` совершенно уникален. Цель аргумента, переданного `Symbol`, состоит в том, чтобы дать `Symbol` описание. Значение `Symbol` не зависит от переданного аргумента. Когда мы проверяем равенство, мы создаем два совершенно новых `Symbol`: первый `Symbol('foo')` и второй `Symbol('foo')`. Эти два значения уникальны и не равны друг другу, `Symbol('foo') === Symbol('foo')` возвращает `false`."
    ],
    "id": 67,
    "options": [
      "`true`, `true`, `false`",
      "`false`, `true`, `false`",
      "`true`, `false`, `true`",
      "`true`, `true`, `true`"
    ],
    "problem": "console.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol('foo') === Symbol('foo'))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "С помощью метода `padStart` мы можем добавить отступ в начало строки. Значение, передаваемое этому методу, представляет собой _общую_ длину строки вместе с отступом. Строка `\"Lydia Hallie\"` имеет длину `12`. `name.padStart(13)` вставляет 1 пробел в начале строки, потому что 12 + 1 равно 13.",
      "Если аргумент, переданный методу `padStart`, меньше длины строки, заполнение не будет добавлено."
    ],
    "id": 68,
    "options": [
      "`\"Lydia Hallie\"`, `\"Lydia Hallie\"`",
      "`\"           Lydia Hallie\"`, `\"  Lydia Hallie\"` (`\"[13x whitespace]Lydia Hallie\"`, `\"[2x whitespace]Lydia Hallie\"`)",
      "`\" Lydia Hallie\"`, `\"Lydia Hallie\"` (`\"[1x whitespace]Lydia Hallie\"`, `\"Lydia Hallie\"`)",
      "`\"Lydia Hallie\"`, `\"Lyd\"`,"
    ],
    "problem": "const name = \"Lydia Hallie\"\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "С помощью оператора `+` вы можете объединять строки. В этом случае мы объединяем строку `\"\"` со строкой `\"💻\"`, что приводит к `\"💻\"`."
    ],
    "id": 69,
    "options": [
      "`\"🥑💻\"`",
      "`257548`",
      "Строка, содержащая кодовые обозначения",
      "Error"
    ],
    "problem": "console.log(\"🥑\" + \"💻\");\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Функция генератора \"приостанавливает\" выполнение, когда видит ключевое слово yield. Во-первых, мы должны позволить функции выдать строку \"Do you love JavaScript?\", что можно сделать, вызвав `game.next().value`.",
      "Каждая строка выполняется до тех пор, пока не найдет первое ключевое слово `yield`. В первой строке функции есть ключевое слово `yield` на первом месте: выполнение останавливается с первым выходом! _Это означает, что переменная `answer` еще не определена!_",
      "Когда мы вызываем `game.next(\"Yes\").value`, предыдущий `yield` заменяется значением параметров, переданных функции `next()`, в данном случае `\"Yes\"`. Значение переменной `answer` теперь равно `\"Yes\"`. Условие if возвращает `false`, а `JavaScript loves you back ❤️`, регистрируется."
    ],
    "id": 70,
    "options": [
      "`game.next(\"Yes\").value` и `game.next().value`",
      "`game.next.value(\"Yes\")` и `game.next.value()`",
      "`game.next().value` и `game.next(\"Yes\").value`",
      "`game.next.value()` и `game.next.value(\"Yes\")`"
    ],
    "problem": "function* startGame() {\n  const answer = yield \"Do you love JavaScript?\";\n  if (answer !== \"Yes\") {\n    return \"Oh wow... Guess we're gone here\";\n  }\n  return \"JavaScript loves you back ❤️\";\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back ❤️\n",
    "question": "Как мы можем вывести в лог значения, которые закомментированы после оператора console.log?"
  },
  {
    "answer": 2,
    "explanation": [
      "`String.raw` возвращает строку, в которой экранированные символы (`\\n`, `\\v`, `\\t` и т.д.) игнорируются! Обратная косая черта может быть проблемой, так как вы можете получить что-то вроде:",
      "`` const path = `C:\\Documents\\Projects\\table.html` ``",
      "Что приведет к:",
      "`\"C:DocumentsProjects able.html\"`",
      "С `String.raw` он просто проигнорирует управляющий знак и напечатает:",
      "`C:\\Documents\\Projects\\table.html`",
      "В этом случае строка `Hello\\nworld`, которая и выводится."
    ],
    "id": 71,
    "options": [
      "`Hello world!`",
      "`Hello` <br />&nbsp; &nbsp; &nbsp;`world`",
      "`Hello\\nworld`",
      "`Hello\\n` <br /> &nbsp; &nbsp; &nbsp;`world`"
    ],
    "problem": "console.log(String.raw`Hello\\nworld`);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Асинхронная функция всегда возвращает обещание. `await` все еще должен ждать разрешения обещания: ожидаемое обещание возвращается, когда мы вызываем `getData()`, чтобы установить `data` равным ему.",
      "Если бы мы хотели получить доступ к разрешенному значению `\"I made it\"`, мы могли бы использовать метод `.then()` для `data`:",
      "`data.then(res => console.log(res))`",
      "Тогда это бы вывело `\"I made it!\"`"
    ],
    "id": 72,
    "options": [
      "`\"I made it!\"`",
      "`Promise {<resolved>\"I made it!\"}`",
      "`Promise {<pending>}`",
      "`undefined`"
    ],
    "problem": "async function getData() {\n  return await Promise.resolve(\"I made it!\");\n}\n\nconst data = getData();\nconsole.log(data);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "Метод `.push()` возвращает _длину_ нового массива! Ранее массив содержал один элемент (строка `\"banana\"`) и имел длину `1`. После добавления в массив строки `\"apple\"`, массив содержит два элемента и имеет длину `2`. Это возвращается из функции `addToList`.",
      "Метод `push` изменяет исходный массив. Если вы хотите вернуть _массив_ из функции, а не _длину массива_, вы должны были вернуть `list` после добавления в нее `item`."
    ],
    "id": 73,
    "options": [
      "`['apple', 'banana']`",
      "`2`",
      "`true`",
      "`undefined`"
    ],
    "problem": "function addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList(\"apple\", [\"banana\"]);\nconsole.log(result);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "`Object.freeze` делает невозможным добавление, удаление или изменение свойств объекта (если только значение свойства не является другим объектом).",
      "Когда мы создаем переменную `shape` и устанавливаем ее равной замороженному объекту `box`, `shape` также ссылается на замороженный объект. Вы можете проверить, заморожен ли объект, используя `Object.isFrozen`. В этом случае `Object.isFrozen(shape)` возвращает true, поскольку переменная `shape` имеет ссылку на замороженный объект.",
      "Поскольку `shape` заморожен, и поскольку значение `x` не является объектом, мы не можем изменить свойство `x`. `x` по-прежнему равно `10`, и `{x: 10, y: 20}` регистрируется."
    ],
    "id": 74,
    "options": [
      "`{ x100, y20 }`",
      "`{ x10, y20 }`",
      "`{ x100 }`",
      "`ReferenceError`"
    ],
    "problem": "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "Когда мы распаковываем свойство `name` из правого объекта, мы присваиваем его значение `\"Lydia\"` переменной с именем `myName`.",
      "С помощью `{name: myName}` мы сообщаем JavaScript, что хотим создать новую переменную с именем `myName` со значением свойства `name` в правой части.",
      "Поскольку мы пытаемся зарегистрировать `name`, переменную, которая не определена, выдается ReferenceError."
    ],
    "id": 75,
    "options": [
      "`\"Lydia\"`",
      "`\"myName\"`",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "const { name: myName } = { name: \"Lydia\" };\n\nconsole.log(name);\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Чистая функция - это функция, которая всегда возвращает тот же результат, если переданы одинаковые аргументы.",
      "Функция `sum` всегда возвращает один и тот же результат. Если мы передадим `1` и `2`, он всегда вернет `3` без побочных эффектов. Если мы передадим `5` и `10`, он всегда вернет `15` и так далее. Это определение чистой функции."
    ],
    "id": 76,
    "options": [
      "Да",
      "Нет"
    ],
    "problem": "function sum(a, b) {\n  return a + b;\n}\n",
    "question": "Это чистая функция?"
  },
  {
    "answer": 2,
    "explanation": [
      "Функция `add` является функцией _запоминателем_. С помощью запоминания мы можем кэшировать результаты функции, чтобы ускорить ее выполнение. В этом случае мы создаем объект `cache`, в котором хранятся ранее возвращенные значения.",
      "Если мы снова вызываем функцию `addFunction` с тем же аргументом, она сначала проверяет, получило ли оно уже это значение в своем кеше. В этом случае будет возвращено значение кэша, что экономит время выполнения. Иначе, если он не кэшируется, он вычислит значение и сохранит его после.",
      "Мы вызываем функцию `addFunction` три раза с одним и тем же значением: при первом вызове значение функции, когда `num` равно `10`, еще не кэшировано. Условие оператора if `num in cache` возвращает `false`, и выполняется блок else: `Calculated! 20` регистрируется, и значение результата добавляется в объект кеша. `cache` теперь выглядит как `{10: 20}`.",
      "Во второй раз объект `cache` содержит значение, возвращаемое для `10`. Условие оператора if `num in cache` возвращает `true`, а `'From cache! 20'` выводится в лог.",
      "В третий раз мы передаем `5 * 2` в функцию, которая оценивается как `10`. Объект `cache` содержит значение, возвращаемое для `10`. Условие оператора if `num in cache` возвращает `true`, а `'From cache! 20'` регистрируется."
    ],
    "id": 77,
    "options": [
      "`Calculated! 20` `Calculated! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `Calculated! 20`",
      "`Calculated! 20` `From cache! 20` `From cache! 20`",
      "`Calculated! 20` `From cache! 20` `Error`"
    ],
    "problem": "const add = () => {\n  const cache = {};\n  return num => {\n    if (num in cache) {\n      return `From cache! ${cache[num]}`;\n    } else {\n      const result = num + 10;\n      cache[num] = result;\n      return `Calculated! ${result}`;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "С помощью цикла _for-in_ мы можем перебирать **перечисляемые** свойства. В массиве перечисляемые свойства являются \"ключами\" элементов массива, которые фактически являются их индексами. Вы можете увидеть массив как:",
      "`{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`",
      "Где ключи - перечисляемые свойства. `0` `1` `2` `3` войти в систему.",
      "С помощью цикла _for-of_ мы можем выполнять итерацию **итераций**. Массив является итеративным. Когда мы выполняем итерацию по массиву, переменная \"item\" равна элементу, по которому она итерируется в данный момент, `\"☕\"` `\"💻\"` `\"🍷\"` `\"🍫\"` выводится в лог."
    ],
    "id": 78,
    "options": [
      "`0` `1` `2` `3` и `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`",
      "`\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` и `\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"`",
      "`\"☕\"` ` \"💻\"` `\"🍷\"` `\"🍫\"` и `0` `1` `2` `3`",
      " `0` `1` `2` `3` и `{0\"☕\", 1\"💻\", 2\"🍷\", 3\"🍫\"}`"
    ],
    "problem": "const myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"]\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Элементы массива могут содержать любые значения. Числа, строки, объекты, другие массивы, ноль, логические значения, неопределенные и другие выражения, такие как даты, функции и вычисления.",
      "Элемент будет равен возвращаемому значению. `1 + 2` вернет `3`, `1 * 2` вернет `2`, а `1 / 2` вернет `0.5`."
    ],
    "id": 79,
    "options": [
      "`[\"1 + 2\", \"1 * 2\", \"1 / 2\"]`",
      "`[\"12\", 2, 0.5]`",
      "`[3, 2, 0.5]`",
      " `[1, 1, 1]`"
    ],
    "problem": "const list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "По умолчанию аргументы имеют значение `undefined`, если только значение не было передано функции. В этом случае мы не передали значение для аргумента `name`. `name` равно логгируемому `undefined`.",
      "В ES6 мы можем перезаписать значение по умолчанию `undefined` параметрами по умолчанию. Например:",
      "`function sayHi(name = \"Lydia\") { ... }`",
      "В этом случае, если мы не передали значение или если мы передали `undefined`, `name` всегда будет равно строке `Lydia`"
    ],
    "id": 80,
    "options": [
      "`Hello there, `",
      "`Hello there, undefined`",
      "`Hello there, null`",
      " `ReferenceError`"
    ],
    "problem": "function sayHi(name) {\n  return `Hi there, ${name}`\n}\n\nconsole.log(sayHi())\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "Значение ключевого слова `this` зависит от того, где вы его используете. В **методе**, как и в методе `getStatus`, ключевое слово `this` ссылается на объект, которому принадлежит метод. Метод принадлежит объекту `data`, поэтому `this` относится к объекту `data`. Когда мы регистрируем `this.status`, регистрируется свойство `status` объекта `data`, которое является `\"🥑\"`.",
      "С помощью метода `call` мы можем изменить объект, на который ссылается ключевое слово `this`. В **функциях** ключевое слово `this` относится к _объекту, которому принадлежит функция_. Мы объявили функцию `setTimeout` для объекта _global_, поэтому в функции `setTimeout` ключевое слово `this` ссылается на объект _global_. В глобальном объекте есть переменная с именем _status_ со значением `\"😎\"`. При регистрации `this.status` выводится `\"😎\"`."
    ],
    "id": 81,
    "options": [
      "`\"🥑\"` и `\"😍\"`",
      "`\"🥑\"` и `\"😎\"`",
      "`\"😍\"` и `\"😎\"`",
      "`\"😎\"` и `\"😎\"`"
    ],
    "problem": "var status = \"😎\"\n\nsetTimeout(() => {\n  const status = \"😍\"\n\n  const data = {\n    status: \"🥑\",\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Мы устанавливаем переменную `city` равной значению свойства с именем `city` для объекта `person`. У этого объекта нет свойства с именем `city`, поэтому переменная `city` имеет значение `undefined`.",
      "Обратите внимание, что мы _не_ ссылаемся на сам объект person! Мы просто устанавливаем переменную `city` равной текущему значению свойства `city` объекта `person`.",
      "Затем мы устанавливаем `city` равным строке `\"Amsterdam\"`. Это не меняет объект person - нет ссылки на этот объект.",
      "При регистрации объекта `person` возвращается неизмененный объект."
    ],
    "id": 82,
    "options": [
      "`{ name\"Lydia\", age21 }`",
      "`{ name\"Lydia\", age21, city\"Amsterdam\" }`",
      "`{ name\"Lydia\", age21, cityundefined }`",
      "`\"Amsterdam\"`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nlet city = person.city\ncity = \"Amsterdam\"\n\nconsole.log(person)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Переменные с ключевыми словами `const` и `let` имеют _блочную видимость_. Блок - это что-то между фигурными скобками (`{}`). В этом случае в фигурных скобках операторов if/else. Вы не можете ссылаться на переменную за пределами блока, в котором она объявлена, вызывается ReferenceError."
    ],
    "id": 83,
    "options": [
      "`\"Sorry, you're too young.\"`",
      "`\"Yay! You're old enough!\"`",
      "`ReferenceError`",
      "`undefined`"
    ],
    "problem": "function checkAge(age) {\n  if (age < 18) {\n    const message = \"Sorry, you're too young.\"\n  } else {\n    const message = \"Yay! You're old enough!\"\n  }\n\n  return message\n}\n\nconsole.log(checkAge(21))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Значение `res` во втором `.then` равно возвращенному значению предыдущего `.then`. Вы можете продолжать цепочку `.then` таким образом; значение передается следующему обработчику."
    ],
    "id": 84,
    "options": [
      "Результат метода `fetch`.",
      "Результат второго вызова метода `fetch`.",
      "Результат коллбэка в предыдущем `.then()`.",
      "Всегда будет `undefined`."
    ],
    "problem": "fetch('https://www.website.com/api/user/1')\n  .then(res => res.json())\n  .then(res => console.log(res))\n",
    "question": "Какая информация будетвыведена в лог?"
  },
  {
    "answer": 0,
    "explanation": [
      "С помощью `!!name` мы определяем, является ли значение `name` истинным или ложным. Если имя истинное, которое мы хотим проверить, то `!name` возвращает `false`. А `!false` (это то, чем на самом деле является `!! name`) возвращает `true`.",
      "Устанавливая `hasName` равным `name`, вы устанавливаете `hasName` равным любому значению, которое вы передали функции `getName`, а не логическому значению `true`.",
      "`new Boolean (true)` возвращает объектную оболочку, а не само логическое значение.",
      "`name.length` возвращает длину переданного аргумента, независимо от того, является ли он `true`."
    ],
    "id": 85,
    "options": [
      "`!!name`",
      "`name`",
      "`new Boolean(name)`",
      "`name.length`"
    ],
    "problem": "function getName(name) {\n  const hasName = //\n}\n",
    "question": "Какая опция позволяет установить hasName равным `true`, если вы не можете передать`true` в качестве аргумента?"
  },
  {
    "answer": 1,
    "explanation": [
      "Чтобы получить символ по определенному индексу в строке, вы можете использовать скобочную нотацию. Первый символ в строке имеет индекс 0 и т.д. В этом случае мы хотим получить элемент с индексом 0, символ `'I'`, который выводится в лог.",
      "Обратите внимание, что этот метод не поддерживается в IE7 и ниже. В этом случае используйте `.charAt()`"
    ],
    "id": 86,
    "options": [
      "`\"\"\"`",
      "`\"I\"`",
      "`SyntaxError`",
      "`undefined`"
    ],
    "problem": "console.log(\"I want pizza\"[0])\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "Вы можете установить значение параметра по умолчанию равным другому параметру функции, если они были определены _до_ параметров по умолчанию. Мы передаем значение `10` в функцию `sum`. Если функция `sum` принимает только один аргумент, это означает, что значение для `num2` не передано, и в этом случае значение `num1` равно переданному значению `10`. Значением по умолчанию `num2` является значение `num1`, которое равно `10`. `num1 + num2` возвращает `20`.",
      "Если вы пытаетесь установить значение параметра по умолчанию равным параметру, который определен _после_ (справа), то значение параметра еще не было инициализировано; это приведет к ошибке."
    ],
    "id": 87,
    "options": [
      "`NaN`",
      "`20`",
      "`ReferenceError`",
      "`undefined`"
    ],
    "problem": "function sum(num1, num2 = num1) {\n  console.log(num1 + num2)\n}\n\nsum(10)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "С синтаксисом `import * as name` мы импортируем _все exports_ из файла `module.js` в файл `index.js`, тогда и создается новый объект с именем `data`. В файле `module.js` есть два экспорта: экспорт по умолчанию и именованный экспорт. Экспорт по умолчанию - это функция, которая возвращает строку `\"Hello World\"`, а именованный экспорт - это переменная с именем `name`, которая имеет значение строки `\"Lydia\"`.",
      "Объект `data` имеет свойство `default` для экспорта по умолчанию, другие свойства имеют имена именованных экспортов и их соответствующие значения."
    ],
    "id": 88,
    "options": [
      "`{ defaultfunction default(), name\"Lydia\" }`",
      "`{ defaultfunction default() }`",
      "`{ default\"Hello world\", name\"Lydia\" }`",
      "Global object of `module.js`"
    ],
    "problem": "// module.js\nexport default () => \"Hello world\"\nexport const name = \"Lydia\"\n\n// index.js\nimport * as data from \"./module\"\n\nconsole.log(data)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Классы являются синтаксическим сахаром для конструкторов функций. Эквивалентом класса `Person` в качестве конструктора функции будет:",
      "Вызов конструктора функции с `new` приводит к созданию экземпляра `Person`, ключевое слово `typeof` возвращает `\"object\"` для экземпляра. `typeof member` возвращает `\"объект\"`."
    ],
    "id": 89,
    "options": [
      "`\"class\"`",
      "`\"function\"`",
      "`\"object\"`",
      "`\"string\"`"
    ],
    "problem": "class Person {\n  constructor(name) {\n    this.name = name\n  }\n}\n\nconst member = new Person(\"John\")\nconsole.log(typeof member)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "Метод `.push` возвращает _новую длину_ массива, а не сам массив! Устанавливая `newList` равным `[1, 2, 3].push(4)`, мы устанавливаем `newList` равным новой длине массива: `4`.",
      "Затем мы пытаемся использовать метод `.push` для `newList`. Поскольку `newList` является числовым значением `4`, мы не можем использовать метод `.push`: выдается ошибка TypeError."
    ],
    "id": 90,
    "options": [
      "`[1, 2, 3, 4, 5]`",
      "`[1, 2, 3, 5]`",
      "`[1, 2, 3, 4]`",
      "`Error`"
    ],
    "problem": "let newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "Обычные функции, такие как функция `giveLydiaPizza`, имеют свойство `prototype`, которое является объектом (прототипом объекта) со свойством `constructor`. Однако функции со стрелками, такие как функция `giveLydiaChocolate`, не имеют этого свойства `prototype`. `undefined` возвращается при попытке доступа к свойству `prototype` с использованием `giveLydiaChocolate.prototype`."
    ],
    "id": 91,
    "options": [
      "`{ constructor...}` `{ constructor...}`",
      "`{}` `{ constructor...}`",
      "`{ constructor...}` `{}`",
      "`{ constructor...}` `undefined`"
    ],
    "problem": "function giveLydiaPizza() {\n  return \"Here is pizza!\"\n}\n\nconst giveLydiaChocolate = () => \"Here's chocolate... now go hit the gym already.\"\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "`Object.entries (person)` возвращает массив вложенных массивов, содержащий ключи и объекты:",
      "`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]`",
      "Используя цикл `for-of`, мы можем перебирать каждый элемент массива, в данном случае подмассивы. Мы можем мгновенно деструктурировать подмассивы в цикле for, используя `const [x, y]`. `x` равен первому элементу в подмассиве, `y` равен второму элементу в подмассиве.",
      "Первым подмассивом является `[ \"name\", \"Lydia\" ]`, где `x` равно `\"name\"`, и `y` равно `\"Lydia\"`, которые выводятся в лог.\nВторым подмассивом является `[ \"age\", 21 ]`, где `x` равно `\"age\"`, и `y` равно `21`, которые выводятся в лог."
    ],
    "id": 92,
    "options": [
      "`name` `Lydia` and `age` `21`",
      "`[\"name\", \"Lydia\"]` and `[\"age\", 21]`",
      "`[\"name\", \"age\"]` and `undefined`",
      "`Error`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y)\n}\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "`... args` - прочие параметры. Значение прочих параметров - это массив, содержащий все оставшиеся аргументы **и может быть передан только последним**! В этом примере прочие параметры были вторым аргументом. Это невозможно, и это приведет к синтаксической ошибке.",
      "Приведенный выше пример работает. Это возвращает массив `[ 'banana', 'apple', 'orange', 'pear' ]`\n</p>\n</details>"
    ],
    "id": 93,
    "options": [
      "`[\"banana\", \"apple\", \"pear\", \"orange\"]`",
      "`[[\"banana\", \"apple\"], \"pear\", \"orange\"]`",
      "`[\"banana\", \"apple\", [\"pear\"], \"orange\"]`",
      "`SyntaxError`"
    ],
    "problem": "function getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\"banana\", \"apple\"], \"pear\", \"orange\")\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "В JavaScript мы _не должны_ явно указывать точку с запятой (`;`), однако движок JavaScript все равно добавляет их после операторов. Это называется **автоматической вставкой точек с запятой**. Например, оператором могут быть переменные или ключевые слова, такие как `throw`, `return`, `break` и т.д.",
      "Здесь мы написали инструкцию `return` и другое значение `a + b` в новой строке. Однако, поскольку это новая линия, движок не знает, что это на самом деле значение, которое мы хотели бы вернуть. Вместо этого он автоматически добавляет точку с запятой после `return`. Вы можете увидеть это как:",
      "Это означает, что `a + b` никогда не достигается, так как функция перестает выполняться после ключевого слова `return`. Если значение не возвращается, как здесь, функция возвращает значение `undefined`. Обратите внимание, что после операторов `if / else` автоматической вставки нет!"
    ],
    "id": 94,
    "options": [
      "`a is bigger`, `6` and `b is bigger`, `3`",
      "`a is bigger`, `undefined` and `b is bigger`, `undefined`",
      "`undefined` and `undefined`",
      "`SyntaxError`"
    ],
    "problem": "function nums(a, b) {\n  if\n  (a > b)\n  console.log('a is bigger')\n  else\n  console.log('b is bigger')\n  return\n  a + b\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "Мы можем установить классы равными другим классам/конструкторам функций. В этом случае мы устанавливаем `Person` равным `AnotherPerson`. Свойство `name` этого конструктора - `Sarah`, поэтому свойство `name` для нового экземпляра класса `Person` `member` - это `Sarah`."
    ],
    "id": 95,
    "options": [
      "`\"Lydia\"`",
      "`\"Sarah\"`",
      "`Errorcannot redeclare Person`",
      "`SyntaxError`"
    ],
    "problem": "class Person {\n  constructor() {\n    this.name = \"Lydia\"\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = \"Sarah\"\n  }\n}\n\nconst member = new Person()\nconsole.log(member.name)\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 3,
    "explanation": [
      "`Symbol` не является _перечисляемый_. Метод `Object.keys` возвращает все _перечисляемые_ свойства ключа для объекта. `Symbol` не просматривается таким образом, и возвращается пустой массив. При регистрации всего объекта будут видны все свойства, даже не перечисляемые.",
      "Это одно из многих качеств символа: помимо представления совершенно уникального значения (которое предотвращает случайное столкновение имен в объектах, например, при работе с 2 библиотеками, которые хотят добавить свойства к одному и тому же объекту), вы также можете \"скрыть\" свойства объектов таким образом (хотя и не полностью. Вы можете получить доступ к символам, используя метод `Object.getOwnPropertySymbols()`)."
    ],
    "id": 96,
    "options": [
      "`{Symbol('a')'b'}` and `[\"{Symbol('a')\"]`",
      "`{}` and `[]`",
      "`{ a\"b\" }` and `[\"a\"]`",
      "`{Symbol('a')'b'}` and `[]`"
    ],
    "problem": "const info = {\n  [Symbol('a')]: 'b'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 0,
    "explanation": [
      "Функция `getList` получает массив в качестве аргумента. Между скобками функции `getList` мы сразу же деструктурируем этот массив. Вы можете увидеть это как:",
      "`[x, ...y] = [1, 2, 3, 4]`",
      "С помощью оставшихся параметров `... y` мы помещаем все \"оставшиеся\" аргументы в массив. Остальные аргументы - это `2`, `3` и `4` в этом случае. Значение `y` является массивом, содержащим все остальные параметры. В этом случае значение `x` равно `1`, поэтому, мы видим в логе `[x, y]`, `[1, [2, 3, 4]]`.",
      "Функция `getUser` получает объект. В случае функций со стрелками мы не можем писать фигурные скобки, если мы просто возвращаем одно значение. Однако, если вы хотите вернуть _объект_ из стрелочной функции, вы должны написать его в скобках, в противном случае никакое значение не возвращается! Следующая функция вернула бы объект:",
      "```const getUser = user => ({ name: user.name, age: user.age })```",
      "Поскольку в этом случае значение не возвращается, функция возвращает значение `undefined`."
    ],
    "id": 97,
    "options": [
      "`[1, [2, 3, 4]]` and `undefined`",
      "`[1, [2, 3, 4]]` and `{ name\"Lydia\", age21 }`",
      "`[1, 2, 3, 4]` and `{ name\"Lydia\", age21 }`",
      "`Error` and `{ name\"Lydia\", age21 }`"
    ],
    "problem": "const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: \"Lydia\", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 2,
    "explanation": [
      "Переменная `name` содержит значение строки, которая не является функцией, поэтому не может вызываться.",
      "Ошибки типа выдаются, когда значение не соответствует ожидаемому типу. JavaScript ожидал, что `name` будет функцией, так как мы пытаемся вызвать ее. Однако это была строка, поэтому выдается ошибка TypeError: name не является функцией!",
      "Синтаксические ошибки генерируются, когда вы написали что-то, что не является допустимым JavaScript, например, когда вы написали слово `return` как `retrun`.\nReferenceErrors генерируется, когда JavaScript не может найти ссылку на значение, к которому вы пытаетесь получить доступ."
    ],
    "id": 98,
    "options": [
      "`SyntaxError`",
      "`ReferenceError`",
      "`TypeError`",
      "`undefined`"
    ],
    "problem": "const name = \"Lydia\"\n\nconsole.log(name())\n",
    "question": "Какой будет вывод?"
  },
  {
    "answer": 1,
    "explanation": [
      "`[]` - истинное значение. С оператором `&&` будет возвращено правое значение, если левое значение является истинным значением. В этом случае левое значение `[]` является истинным значением, поэтому возвращается `'Im'`.",
      "`\"\"` - ложное значение. Если левое значение ложно, ничего не возвращается. `n't` не возвращается."
    ],
    "id": 99,
    "options": [
      "`possible! You should see a therapist after so much JavaScript lol`",
      "`Impossible! You should see a therapist after so much JavaScript lol`",
      "`possible! You shouldn't see a therapist after so much JavaScript lol`",
      "`Impossible! You shouldn't see a therapist after so much JavaScript lol`"
    ],
    "problem": "// 🎉✨ This is my 100th question! ✨🎉\n\nconst output = `${[] && 'Im'}possible!\nYou should${'' && `n't`} see a therapist after so much JavaScript lol`\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 2,
    "explanation": [
      "С помощью оператора `||` мы можем вернуть первый истинный операнд. Если все значения ложны, последний операнд возвращается.",
      "`(false || {} || null)`: пустой объект `{}` является истинным значением. Это первое (и единственное) истинное значение, которое возвращается. `one` содержит `{}`.",
      "`(null || false ||\" \")`: все операнды являются ложными значениями. Это означает, что прошедший операнд `\"\"` возвращается. `two` содержит `\"\"`.",
      "`([] || 0 ||\" \")`: пустой массив `[]` является истинным значением. Это первое истинное значение, которое возвращается. `three` присвоено `[]`."
    ],
    "id": 100,
    "options": [
      "`false` `null` `[]`",
      "`null` `\"\"` `true`",
      "`{}` `\"\"` `[]`",
      "`null` `null` `true`"
    ],
    "problem": "const one = (false || {} || null)\nconst two = (null || false || \"\")\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 3,
    "explanation": [
      "С обещанием мы в основном говорим: \"Я хочу выполнить эту функцию и откладываю ее, пока она выполняется, поскольку это может занять некоторое время\". Только когда определенное значение разрешено (или отклонено), и когда стек вызовов пуст, я хочу использовать это значение.",
      "Мы можем получить это значение с помощью ключевого слова `.then` и `await` в функции `async`. Хотя мы можем получить значение обещания с помощью `.then` и `await`, они работают немного по-разному.",
      "В `firstFunction` мы (вроде) отложили функцию `myPromise` во время ее работы, но продолжили выполнение другого кода, в данном случае `console.log ('second')`. Затем функция разрешается строкой `I have resolved`, которая затем логируется после того, как она увидела, что стек вызовов пуст.",
      "Используя ключевое слово `await` в `secondFunction`, мы буквально приостанавливаем выполнение асинхронной функции до тех пор, пока значение не будет разрешено до перехода на следующую строку.",
      "Это означает, что мы ожидали разрешения `myPromise` со значением `I have resolved`, и только когда это произошло, мы перешли к следующей строке: `second` была выведена в консоль последней."
    ],
    "id": 101,
    "options": [
      "`I have resolved!`, `second` and `I have resolved!`, `second`",
      "`second`, `I have resolved!` and `second`, `I have resolved!`",
      "`I have resolved!`, `second` and `second`, `I have resolved!`",
      "`second`, `I have resolved!` and `I have resolved!`, `second`"
    ],
    "problem": "const myPromise = () => Promise.resolve('I have resolved!')\n\nfunction firstFunction() {\n  myPromise().then(res => console.log(res))\n  console.log('second')\n}\n\nasync function secondFunction() {\n  console.log(await myPromise())\n  console.log('second')\n}\n\nfirstFunction()\nsecondFunction()\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 2,
    "explanation": [
      "Оператор `+` используется не только для добавления числовых значений, но мы также можем использовать его для объединения строк. Всякий раз, когда движок JavaScript видит, что одно или несколько значений не являются числом, он приводит число к строке.",
      "Первым является `1`, который является числовым значением. `1 + 2` возвращает число `3`.",
      "Тем не менее, вторая строка `\"Lydia\"`. `\"Lydia\"` является строкой, а `2` является числом: `2` приводится к строке. `\"Lydia\"` и `\"2\"` объединяются, что приводит к результирующей строке `\"Lydia2\"`.",
      "`{name: \"Lydia\"}` является объектом. Ни число, ни объект не являются строкой, поэтому они приводятся к строке. Всякий раз, когда мы приводим обычный объект, он становится `\"[object Object]\"`. `\"[object Object]\"`, объединенный с `\"2\"`, становится `\"[object Object]2\"`."
    ],
    "id": 102,
    "options": [
      "`3`, `NaN`, `NaN`",
      "`3`, `7`, `NaN`",
      "`3`, `Lydia2`, `[object Object]2`",
      "`\"12\"`, `Lydia2`, `[object Object]2`"
    ],
    "problem": "const set = new Set()\n\nset.add(1)\nset.add(\"Lydia\")\nset.add({ name: \"Lydia\" })\n\nfor (let item of set) {\n  console.log(item + 2)\n}\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 2,
    "explanation": [
      "Мы можем передать любой тип значения, которое мы хотим, в `Promise.resolve`, либо обещание, либо не обещание. Сам метод возвращает обещание с разрешенным значением. Если вы передадите обычную функцию, это будет разрешенное обещание с обычным значением. Если вы передадите обещание, это будет разрешенное обещание с разрешенным значением этого пройденного обещания.",
      "В этом случае мы просто передали числовое значение `5`. Возвращается разрешенное обещание со значением `5`."
    ],
    "id": 103,
    "options": [
      "`5`",
      "`Promise {<pending>5}`",
      "`Promise {<resolved>5}`",
      "`Error`"
    ],
    "problem": "Promise.resolve(5)\n",
    "question": "Чему равно значение?"
  },
  {
    "answer": 1,
    "explanation": [
      "Объекты передаются по ссылке. Когда мы проверяем объекты на строгое равенство (`===`), мы сравниваем их ссылки.",
      "Мы устанавливаем значение по умолчанию для `person2`, равное объекту `person`, и передаем объект `person` в качестве значения для `person1`.",
      "Это означает, что оба значения имеют ссылку на одно и то же место в памяти, поэтому они равны.",
      "Блок кода в операторе `else` запускается, и в лог выводится `They are the same!`."
    ],
    "id": 104,
    "options": [
      "`Not the same!`",
      "`They are the same!`",
      "`ReferenceError`",
      "`SyntaxError`"
    ],
    "problem": "function compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log(\"Not the same!\")\n  } else {\n    console.log(\"They are the same!\")\n  }\n}\n\nconst person = { name: \"Lydia\" }\n\ncompareMembers(person)\n",
    "question": "Чему равно значение?"
  },
  {
    "answer": 3,
    "explanation": [
      "В JavaScript у нас есть два способа доступа к свойствам объекта: нотация в скобках или нотация в точках. В этом примере мы используем точечную нотацию (`colorConfig.colors`) вместо скобочной нотации (`colorConfig[\"colors\"]`).",
      "В точечной нотации JavaScript пытается найти свойство объекта с таким точным именем. В этом примере JavaScript пытается найти свойство с именем `colors` в объекте `colorConfig`. Не существует свойства с именем `colorConfig`, поэтому возвращается `undefined`. Затем мы пытаемся получить доступ к значению первого элемента, используя `[1]`. Мы не можем сделать это для значения, которое `undefined`, поэтому оно выдает `TypeError`: `Cannot read свойство '1' of undefined`.",
      "JavaScript интерпретирует (или распаковывает) операторы. Когда мы используем скобочные обозначения, он видит первую открывающую скобку `[` и продолжает работать, пока не найдет закрывающую скобку `]`. Только тогда он оценит утверждение. Если бы мы использовали `colorConfig[colors [1]]`, он бы возвратил значение свойства `red` объекта `colorConfig`."
    ],
    "id": 105,
    "options": [
      "`true`",
      "`false`",
      "`undefined`",
      "`TypeError`"
    ],
    "problem": "const colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n}\n\nconst colors = [\"pink\", \"red\", \"blue\"]\n\nconsole.log(colorConfig.colors[1])\n",
    "question": "Чему равно значение?"
  },
  {
    "answer": 0,
    "explanation": [
      "Под капотом смайлики - это юникоды. Юникод для сердца смайликов `\"U+2764 U+FE0F\"`. Они всегда одинаковы для одного и того же смайлика, поэтому мы сравниваем две одинаковые строки друг с другом, что возвращает `true`."
    ],
    "id": 106,
    "options": [
      "`true`",
      "`false`"
    ],
    "problem": "console.log('❤️' === '❤️')\n",
    "question": "Чему равно значение?"
  },
  {
    "answer": 3,
    "explanation": [
      "Используя метод `splice`, мы модифицируем исходный массив, удаляя, заменяя или добавляя элементы. В этом случае мы удалили 2 элемента из индекса 1 (мы удалили `'🥑'` и `'😍'`) и добавили `✨` emoji.",
      "`map`, `filter` и `slice` возвращают новый массив, `find` возвращает элемент, а `reduce` возвращает аккумулированное значение."
    ],
    "id": 107,
    "options": [
      "`All of them`",
      "`map` `reduce` `slice` `splice`",
      "`map` `slice` `splice`",
      "`splice`"
    ],
    "problem": "const emojis = ['✨', '🥑', '😍']\n\nemojis.map(x => x + '✨')\nemojis.filter(x => x !== '🥑')\nemojis.find(x => x !== '🥑')\nemojis.reduce((acc, cur) => acc + '✨')\nemojis.slice(1, 2, '✨') \nemojis.splice(1, 2, '✨')\n",
    "question": "Какой из этих методов модифицирует исходный массив?"
  },
  {
    "answer": 0,
    "explanation": [
      "Мы устанавливаем значение свойства `favourFood` для объекта `info` равным строке со смайликами для пиццы, `'🍕'`. Строка является примитивным типом данных. В JavaScript примитивные типы данных передаются по ссылке ...",
      "В JavaScript примитивные типы данных (все, что не является объектом) передаются как _значение_. В этом случае мы устанавливаем значение свойства `favourFood` объекта `info` равным значению первого элемента в массиве `food`, в данном случае это строка с emoji пиццы (`'🍕'`). Строка является примитивным типом данных и взаимодействует по значению (см. мой [пост в блоге](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference), если вы заинтересованы в получении дополнительной информации).",
      "Затем мы меняем значение свойства `favourFood` объекта `info`. Массив `food` не изменился, поскольку значение `favourFood` было просто _скопировано_ из значения первого элемента в массиве и не имеет ссылки на то же место в памяти, что и элемент на `food[0]`. Когда мы выводим в лог `food`, это все равно исходный массив, `['🍕', '🍫', '🥑', '🍔']`."
    ],
    "id": 108,
    "options": [
      "`['🍕', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍫', '🥑', '🍔']`",
      "`['🍝', '🍕', '🍫', '🥑', '🍔']`",
      "`ReferenceError`"
    ],
    "problem": "const food = ['🍕', '🍫', '🥑', '🍔']\nconst info = { favoriteFood: food[0] }\n\ninfo.favoriteFood = '🍝'\n\nconsole.log(food)\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 0,
    "explanation": [
      "С помощью метода `JSON.parse ()` мы можем разобрать строку JSON в значение JavaScript."
    ],
    "id": 109,
    "options": [
      "Разбирает JSON в значение JavaScript",
      "Разбирает объект JavaScript в JSON",
      "Разбирает любое значение JavaScript в JSON",
      "Разбирает JSON непосредственно в объект JavaScript"
    ],
    "problem": "JSON.parse()\n",
    "question": "Что делает этот метод?"
  },
  {
    "answer": 3,
    "explanation": [
      "Каждая функция имеет свой собственный _контекст исполнения_ (или _область действия_). Функция `getName` сначала ищет в своем собственном контексте (области действия), чтобы увидеть, содержит ли она переменную `name`, к которой мы пытаемся получить доступ. В этом случае функция `getName` содержит собственную переменную `name`: мы объявляем переменную `name` с ключевым словом `let` и значением `'Sarah'`.",
      "Переменные с ключевым словом `let` (и `const`) поднимаются в начало функции, в отличие от `var`, которые <i>не инициализируется</i>. Они недоступны до того, как мы объявим (инициализируем) их строку. Это называется \"временной мертвой зоной\". Когда мы пытаемся получить доступ к переменным до их объявления, JavaScript выдает `ReferenceError`.",
      "Если бы мы не объявили переменную `name` в функции `getName`, движок javascript посмотрел бы вниз по _цепочки области действия_. Внешняя область имеет переменную с именем `name` со значением `Lydia`. В этом случае он бы записал \"Лидию\"."
    ],
    "id": 110,
    "options": [
      "Lydia",
      "Sarah",
      "`undefined`",
      "`ReferenceError`"
    ],
    "problem": "let name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n  let name = 'Sarah'\n}\n\ngetName()\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 2,
    "explanation": [
      "Используя ключевое слово `yield`, мы получаем значения в функции генератора. С помощью ключевого слова `yield*` мы можем получить значения из другой функции-генератора или итерируемого объекта (например, массива).",
      "В `generatorOne` мы получаем весь массив `[' a ',' b ',' c ']`, используя ключевое слово `yield`. Значение свойства `value` для объекта, возвращаемого методом `next` для `one` (`one.next().value`), равно всему массиву `['a', 'b', 'c']`.",
      "В файле `generatorTwo` мы используем ключевое слово `yield*`. Это означает, что первое полученное значение `two` равно первому полученному значению в итераторе. Итератор - это массив `['a', 'b', 'c']`. Первым полученным значением является `a`, поэтому в первый раз, когда мы вызываем `two.next().value`, возвращается `a`."
    ],
    "id": 111,
    "options": [
      "`a` and `a`",
      "`a` and `undefined`",
      "`['a', 'b', 'c']` and `a`",
      "`a` and `['a', 'b', 'c']`"
    ],
    "problem": "function* generatorOne() {\n  yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n  yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne()\nconst two = generatorTwo()\n\nconsole.log(one.next().value)\nconsole.log(two.next().value)\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 0,
    "explanation": [
      "Выражения внутри литералов шаблона расчитываются первыми. Это означает, что строка будет содержать возвращаемое значение выражения, в данном случае немедленно исполняемую функцию `(x => x)('I love')`. Мы передаем значение `'I love'` в качестве аргумента стрелочной функции `x => x`. `x` равно `'I love'`, которое и возвращается. Это приводит к `I love to program`."
    ],
    "id": 112,
    "options": [
      "`I love to program`",
      "`undefined to program`",
      "`${(x => x)('I love') to program`",
      "`TypeError`"
    ],
    "problem": "console.log(`${(x => x)('I love')} to program`)\n",
    "question": "Какое значение будет на выходе?"
  },
  {
    "answer": 2,
    "explanation": [
      "Обычно, когда мы устанавливаем объекты равными `null`, эти объекты получают метку _собрано в мусор_, так как больше нет ссылок на этот объект. Однако, поскольку функция обратного вызова в `setInterval` является стрелочной функцией стрелки (таким образом, привязанной к объекту `config`), функция обратного вызова все еще содержит ссылку на объект `config`. Пока есть ссылка, объект не будет собран в мусор. Поскольку сборщик мусора не отрабатывает, функция обратного вызова `setInterval` будет по-прежнему вызываться каждые 1000 мс (1с)."
    ],
    "id": 113,
    "options": [
      "обратный вызов `setInterval` не будет вызван",
      "обратный вызов `setInterval` будет вызван один раз",
      "обратный вызов `setInterval` будет вызываться каждую секунду",
      "мы никогда не вызовем `config.alert()`, т.к. `config` равно `null`"
    ],
    "problem": "let config = {\n  alert: setInterval(() => {\n    console.log('Alert!')\n  }, 1000)\n}\n\nconfig = null\n",
    "question": "Что произойдет?"
  },
  {
    "answer": 1,
    "explanation": [
      "При добавлении пары ключ/значение с использованием метода `set` имя ключа будет равно значению первого аргумента, переданного в функцию `set`, а значением будет второй аргумент, переданный в функцию `set`. В данном случае ключом является _функция_ `() => 'greeting'` и значение `'Hello world'`. `myMap` теперь это `{ () => 'greeting' => 'Hello world!' }`.",
      "1 неверно, поскольку ключ не `'greeting'`, а `() => 'greeting'`.\n3 неверно, так как мы создаем новую функцию, передавая ее в качестве параметра методу `get`. Объект взаимодействует со _ссылкой_. Функции - это объекты, поэтому две функции никогда не бывают строго равными, даже если они идентичны: они имеют ссылки на разные места в памяти."
    ],
    "id": 114,
    "options": [
      "1",
      "2",
      "2 и 3",
      "Каждый из них"
    ],
    "problem": "const myMap = new Map()\nconst myFunc = () => 'greeting'\n\nmyMap.set(myFunc, 'Hello world!')\n\n//1\nmyMap.get('greeting')\n//2\nmyMap.get(myFunc)\n//3\nmyMap.get(() => 'greeting')\n",
    "question": "Какие методы вернут значение `'Hello world!'`?"
  },
  {
    "answer": 2,
    "explanation": [
      "Функции `changeAge` и `changeAgeAndName` имеют параметр по умолчанию, а именно _вновь_ созданный объект `{ ...person }`. Этот объект имеет копии всех ключей/значений объекта `person`.",
      "Сначала мы вызываем функцию `changeAge` и передаем объект `person` в качестве аргумента. Эта функция увеличивает значение свойства `age` на 1. `person` теперь `{name: \"Lydia\", age: 22}`.",
      "Затем мы вызываем функцию `changeAgeAndName`, однако мы не передаем параметр. Вместо этого значение `x` равно новому объекту: `{ ... person }`. Поскольку это новый объект, он не влияет на значения свойств объекта `person`. `person` по-прежнему равен `{name: \"Lydia\", age: 22}`."
    ],
    "id": 115,
    "options": [
      "`{name\"Sarah\", age22}`",
      "`{name\"Sarah\", age23}`",
      "`{name\"Lydia\", age22}`",
      "`{name\"Lydia\", age23}`"
    ],
    "problem": "const person = {\n  name: \"Lydia\",\n  age: 21\n}\n\nconst changeAge = (x = { ...person }) => x.age += 1\nconst changeAgeAndName = (x = { ...person }) => {\n  x.age += 1\n  x.name = \"Sarah\"\n}\n\nchangeAge(person)\nchangeAgeAndName()\n\nconsole.log(person)\n",
    "question": "Какое значение будет на выходе?"
  }
]