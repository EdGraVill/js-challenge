(this["webpackJsonpjs-challenge"]=this["webpackJsonpjs-challenge"]||[]).push([[36],{111:function(e){e.exports=JSON.parse('[{"answer":3,"explanation":["Innerhalb der Funktion wird zuerst der `name` mit dem `var` Keyword gesetzt. Das bedeuted, dass die Variable mit dem Standardwert `undefined` gehoisted wird (Speicher wird w\xe4hrend der Erstellung bereitgestellt), bis zu der Zeile, wo wir die Variable definieren. Da wir die Variable auf der Zeile, wo wir den `name` loggen noch nicht gesetzt haben, ist dieser noch `undefined`.","Variablen mit dem `let` (oder `const`) Keyword werden ebenfalls gehoisted, aber im Gegensatz zu `var` werden diese nicht <i>initialisiert</i>. Auf sie k\xf6nnen wir daher nicht zugreifen, bevor sie definiert wurden. JavaScript wirft einen `ReferenceError` aus."],"id":0,"options":["`Lydia` und `undefined`","`Lydia` und `ReferenceError`","`ReferenceError` und `21`","`undefined` und `ReferenceError`"],"problem":"function sayHi() {\\n\\tconsole.log(name);\\n\\tconsole.log(age);\\n\\tvar name = \\"Lydia\\";\\n\\tlet age = 21;\\n}\\n\\nsayHi();\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Aufgrund der Event Queue in JavaScript, wird die Callback Funktion in `setTimeout` _nach_ der Schleife ausgef\xfchrt. Da die Variable `i` in der ersten Schleife mit dem `var` Keyword definiert wurde, ist dieser Wert global verf\xfcgbar. W\xe4hrend der Schleife wird der Wert von `i` jedesmal mithilfe des `++` Operators um `1` erh\xf6ht. Zu dem Zeitpunkt, wenn die Callback Funktion in `setTimeout` aufgerufen wird, ist `i` gleich `3` im ersten Beispiel.","In der zweiten Schleife wurde die Variable `i` mit dem `let` Keyword definiert: Variablen, die mit `let` (oder `const`) deklariert werden sind block-scoped (Ein Block ist alles zwischen `{ }`). W\xe4hrend jedem Durchlauf bekommt `i` einen neuen Wert zugewiesen, der jeweils innerhalb des Scopes der Schleife liegt."],"id":1,"options":["`0 1 2` und `0 1 2`","`0 1 2` und `3 3 3`","`3 3 3` und `0 1 2`"],"problem":"for (var i = 0; i < 3; i++) {\\n\\tsetTimeout(() => console.log(i), 1);\\n}\\n\\nfor (let i = 0; i < 3; i++) {\\n\\tsetTimeout(() => console.log(i), 1);\\n}\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Merke, dass der Wert von `diameter` eine regul\xe4re Funktion ist, w\xe4hrend der Wert von `perimeter` eine Arrow Function ist.","In Arrow Functions bezieht sich das `this` Keyword auf den aktuellen Scope, was bei regul\xe4ren Funktionen nicht der Fall ist. Das bedeutet, wenn wir `perimeter` aufrufen, bezieht es sich nicht auf das shape Object, sondern auf den umliegenden Scope (zum Beispiel `window`).","Es gibt keinen Wert `radius` in dem Object, daher wird `undefined` zur\xfcckgegeben."],"id":2,"options":["`20` und `62.83185307179586`","`20` und `NaN`","`20` und `63`","`NaN` und `63`"],"problem":"const shape = {\\n\\tradius: 10,\\n\\tdiameter() {\\n\\t\\treturn this.radius * 2;\\n\\t},\\n\\tperimeter: () => 2 * Math.PI * this.radius,\\n};\\n\\nshape.diameter();\\nshape.perimeter();\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Das un\xe4re Plus versucht einen Operand zu einer Nummer umzuwandeln. `true` ist `1` und `false` ist `0`.","Der String `\'Lydia\'` ist truthy. Was wir eigentlich fragen ist: \\"ist dieser truthy Wert falsy?\\". Die Antwort ist `false`."],"id":3,"options":["`1` und `false`","`false` und `NaN`","`false` und `false`"],"problem":"+true;\\n!\\"Lydia\\";\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["In JavaScript sind alle Object Keys strings (au\xdfer bei Symbols). Selbst wenn diese nicht als strings _getyped_ sind, werden sie im Endeffekt zu Strings konvertiert.","JavaScript interpretiert lediglich Aussagen. Wenn wir Bracket Notation verwenden, sieht JavaScript so zuerst eine \xf6ffnende eckige Klammer `[` und geht weiter, bis es eine schlie\xdfende eckige Klammer `]` findet. Erst dann wird die Aussage evaluiert.","`mouse[bird.size]`: Erst wird `bird.size` evaluiert, was `\\"small\\"` zur\xfcck gibt. `mouse[\\"small\\"]` gibt `true` zur\xfcck.","Mit der Dot Notation ist das nicht der Fall. `mouse` hat keinen Key namens `bird`, was bedeutet, dass `mouse.bird` `undefined` ist. Dann fragen wir nach der `size` mit Dot Notation: `mouse.bird.size`. Da `mouse.bird` `undefined` ist, fragen wir eigentlich nach `undefined.size`. Das ist fehlerhaft und wirft daher einen Fehler, wie zum Beispiel `Cannot read property \\"size\\" of undefined` zur\xfcck."],"id":4,"options":["`mouse.bird.size` ist nicht korrekt","`mouse[bird.size]` ist nicht korrekt","`mouse[bird[\\"size\\"]]` ist nicht korrekt","Keine der Antworten ist korrekt."],"problem":"const bird = {\\n\\tsize: \\"small\\",\\n};\\n\\nconst mouse = {\\n\\tname: \\"Mickey\\",\\n\\tsmall: true,\\n};\\n","question":"Was ist wahr?"},{"answer":0,"explanation":["In JavaScript interagieren alle Objekte durch _Referenz_, wenn diese gleich sind.","Zuerst h\xe4lt die Variable `c` ein Object. Sp\xe4ter wird `d` die selbe Referenz zugewiesen wie `c`.","<img src=\\"https://i.imgur.com/ko5k0fs.png\\" width=\\"200\\">","Wenn ein Object ge\xe4ndert wird, werden alle Referenzen zu diesem Object ebenfalls aktualisiert."],"id":5,"options":["`Hello`","`Hey`","`undefined`","`ReferenceError`","`TypeError`"],"problem":"let c = { greeting: \\"Hey!\\" };\\nlet d;\\n\\nd = c;\\nc.greeting = \\"Hello\\";\\nconsole.log(d.greeting);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["`new Number()` ist ein eingebauter Function Constructor. Auch wenn der Wert wie eine Nummer aussieht, ist es in Wirklichkeit keine Nummer, sondern beinhaltet eine Menge zus\xe4tzlicher Werte und ist daher ein Object.","Wenn wir `==` nutzen wird nur gepr\xfcft, ob der _Wert_ gleich ist. Da beide den Wert `3` haben, wird `true` zur\xfcckgegeben.","Wenn wir aber `===` nutzen m\xfcssen sowohl der Wert _als auch_ der Typ \xfcbereinstimmen. Das ist `false`, da `new Number()` keine Nummer, sondern ein **Object** ist."],"id":6,"options":["`true` `false` `true`","`false` `false` `true`","`true` `false` `false`","`false` `true` `true`"],"problem":"let a = 3;\\nlet b = new Number(3);\\nlet c = 3;\\n\\nconsole.log(a == b);\\nconsole.log(a === b);\\nconsole.log(b === c);\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Die `colorChange` Funktion ist statisch (`static`). Statische Methoden existieren nur am Constructor wo sie erstellt wurden und k\xf6nnen nicht an ihre Kinder weitergegeben werden. Da `freddie` ein Kind ist, wird die Funktion nicht runter gereicht und ist daher auch nicht in der `freddie` Instanz verf\xfcgbar. Ein `TypeError` wird zur\xfcckgeworfen."],"id":7,"options":["`orange`","`purple`","`green`","`TypeError`"],"problem":"class Chameleon {\\n\\tstatic colorChange(newColor) {\\n\\t\\tthis.newColor = newColor;\\n\\t\\treturn this.newColor;\\n\\t}\\n\\n\\tconstructor({ newColor = \\"green\\" } = {}) {\\n\\t\\tthis.newColor = newColor;\\n\\t}\\n}\\n\\nconst freddie = new Chameleon({ newColor: \\"purple\\" });\\nfreddie.colorChange(\\"orange\\");\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Das Object wird geloggt, da wir ein leeres Object am globalen Object erstellt haben. Als wir uns bei `greeting` verschrieben haben (als `greetign`) hat JavaScript das als neues Objekt `global.greetign = {}` (oder `window.greetign = {}` im Browser) angesehen.","Um das zu verhindern, k\xf6nnen wir `\\"use strict\\"` verwenden. Das stellt sicher, dass eine Variable erst definiert sein muss, bevor dieser ein Wert zugewiesen werden kann."],"id":8,"options":["`{}`","`ReferenceErrorgreetign is not defined`","`undefined`"],"problem":"let greeting;\\ngreetign = {}; // Typo!\\nconsole.log(greetign);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["In JavaScript ist das ohne Weiteres m\xf6glich, da Funktionen Objekte sind. (Alle Typen au\xdfer primitiven Typen sind Objekte)","Eine Funktion ist ein spezieller Typ eines Objekts. Der Code, den wir schreiben ist keine eigentliche Funktion, sondern ein Object mit Properties. Die Property ist aufrufbar."],"id":9,"options":["Nichts, das ist absolut in Ordnung.","`SyntaxError`. Man kann einer Funktion keine Properties in der Form zuweisen.","`undefined`","`ReferenceError`"],"problem":"function bark() {\\n\\tconsole.log(\\"Woof!\\");\\n}\\n\\nbark.animal = \\"dog\\";\\n","question":"Was passiert, wenn wir das tun?"},{"answer":0,"explanation":["Man kann keine Properties einem Constructor zuweisen, wie es bei normalen Objects der Fall ist. Wenn man ein Feature allen Objects zugleich zuweisen m\xf6chte, muss man den Prototype verwenden. In diesem Fall also:","So h\xe4tte `member.getFullName()` funktioniert. Warum ist das von Vorteil? Sagen wir, wir h\xe4tten diese Methode dem Constructor selbst zugewiesen, aber vielleicht ben\xf6tigt nicht jede Instanz von `Person` diese Methode. So h\xe4tte das eine Menge Arbeitsspeicher verschwendet, weil jede Instanz die Property zugewiesen bekommt, auch wenn sie diese gar nicht ben\xf6tigt.\\nStattdessen haben wir sie nur dem Prototype zugewiesen, sodass sie nur an einer Stelle im Arbeitsspeicher hinterlegt ist, aber dennoch haben alle Instanzen Zugriff darauf."],"id":10,"options":["`TypeError`","`SyntaxError`","`Lydia Hallie`","`undefined` `undefined`"],"problem":"function Person(firstName, lastName) {\\n\\tthis.firstName = firstName;\\n\\tthis.lastName = lastName;\\n}\\n\\nconst member = new Person(\\"Lydia\\", \\"Hallie\\");\\nPerson.getFullName = function() {\\n\\treturn `${this.firstName} ${this.lastName}`;\\n};\\n\\nconsole.log(member.getFullName());\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["F\xfcr `sarah` haben wir nicht das `new` Keyword verwendet. Wenn wir `new` verwenden, bezieht sich das auf das neue, leere Object, welches wir erstellen. Wenn wir allerdings das `new` Keyword nicht verwenden, bezieht es sich auf das **globale Objekt**.","Wir haben `this.firstName` den Wert `\\"Sarah\\"` zugewiesen und `this.lastName` den Wert `\\"Smith\\"`. Was wir damit eigentlich zugewiesen haben, ist `global.firstName = \'Sarah\'` und `global.lastName = \'Smith\'`. `sarah` selbst ist daher `undefined`."],"id":11,"options":["`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` und `undefined`","`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` und `Person {firstName\\"Sarah\\", lastName\\"Smith\\"}`","`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` und `{}`","\\"Lydia\\", lastName\\"Hallie\\"}` und `ReferenceError`"],"problem":"function Person(firstName, lastName) {\\n\\tthis.firstName = firstName;\\n\\tthis.lastName = lastName;\\n}\\n\\nconst lydia = new Person(\\"Lydia\\", \\"Hallie\\");\\nconst sarah = Person(\\"Sarah\\", \\"Smith\\");\\n\\nconsole.log(lydia);\\nconsole.log(sarah);\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["W\xe4hrend der **capturing** Phase geht das Event durch die Elternelemente bis hin zum Zielelement. Wenn dann das Ziel (**target**) erreicht ist, beginnt die **bubbling** Phase.","<img src=\\"https://i.imgur.com/N18oRgd.png\\" width=\\"200\\">"],"id":12,"options":["Target > Capturing > Bubbling","Bubbling > Target > Capturing","Target > Bubbling > Capturing","Capturing > Target > Bubbling"],"problem":"","question":"Was sind die drei Phasen der Event Propagation?"},{"answer":1,"explanation":["Alle Objekte haben Prototypes, au\xdfer dem **Basis Objekt**. Das Basis Objekt hat Zugriff auf einige Methoden und Properties, wie zum Beispiel `.toString`. Das ist der Grund, warum wir eingebaute JavaScript Methoden nutzen k\xf6nnen. All diese Methoden sind am Prototype verf\xfcgbar. Obwohl JavaScript diese nicht direkt am Objekt finden kann, folgt es der Prototype Chain, bis es die Property findet und damit verf\xfcgbar macht."],"id":13,"options":["wahr","falsch"],"problem":"","question":"Alle Objekte haben Prototypes."},{"answer":2,"explanation":["JavaScript ist eine **Sprache mit dynamischen Typen**, was bedeutet, dass wir Variablen keine spezifischen Typen zuweisen. Werte k\xf6nnen automatisch in einen anderen Typ umgewandelt werden, was _implicit type coercion_ genannt wird. **Coercion** (dt. \\"Zwang\\") ist die Umwandlung von einem Typ zu einem anderen.","In diesem Beispiel wandelt JavaScript die Nummer `1` in einem String um, sodass die Funktion Sinn ergibt und einen Wert zur\xfcckgeben kann. W\xe4hrend der Addition eines numerischen Types (`1`) mit einem String (`\'2\'`) wird die Nummer wie ein String behandelt. Wir k\xf6nnen Strings mit einem Plus Symbol zusammensetzen, zum Beispiel: `\\"Hello\\" + \\"World\\"`. Genau das passiert hier, sodass `\\"1\\" + \\"2\\"` einen Wert von `\\"12\\"` zur\xfcckgibt."],"id":14,"options":["`NaN`","`TypeError`","`\\"12\\"`","`3`"],"problem":"function sum(a, b) {\\n\\treturn a + b;\\n}\\n\\nsum(1, \\"2\\");\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Der **Postfix** Unary Operator `++`:","gibt den Wert zur\xfcck (hier: `0`)","erh\xf6ht den Wert (`number` ist jetzt `1`)","Der **Prefix** Unary Operator `++`:","erh\xf6ht den Wert (`number` ist jetzt `2`)","gibt den Wert zur\xfcck (hier: `2`)","Der Output ist daher `0 2 2`."],"id":15,"options":["`1` `1` `2`","`1` `2` `2`","`0` `2` `2`","`0` `1` `2`"],"problem":"let number = 0;\\nconsole.log(number++);\\nconsole.log(++number);\\nconsole.log(number);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Wenn man Template Literals verwendet ist das erste Argument immer ein Array der String Werte. Die restlichen Argumente bekommen die Werte der \xfcbergebenen Expressions zugewiesen."],"id":16,"options":["`\\"Lydia\\"` `21` `[\\"\\", \\" is \\", \\" years old\\"]`","`[\\"\\", \\" is \\", \\" years old\\"]` `\\"Lydia\\"` `21`","`\\"Lydia\\"` `[\\"\\", \\" is \\", \\" years old\\"]` `21`"],"problem":"function getPersonInfo(one, two, three) {\\n\\tconsole.log(one);\\n\\tconsole.log(two);\\n\\tconsole.log(three);\\n}\\n\\nconst person = \\"Lydia\\";\\nconst age = 21;\\n\\ngetPersonInfo`${person} is ${age} years old`;\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Wenn man pr\xfcft, ob Werte gleich sind werden Primitives immer anhand ihrer _Value_ verglichen, w\xe4hrend Objects anhand der _Referenz_ verglichen werden. JavaScript pr\xfcft, ob die Objekte eine Referenz zur gleichen Stelle im Speicher haben.","Die beiden Objekte, die wir hier vergleichen haben das nicht. Das Objekt, welches wir als Parameter \xfcbergeben haben bezieht sich auf eine andere Stelle im Speicher, als das Objekt, welches wir verwendet haben um die Werte zu vergleichen.","Deshalb werfen sowohl `{ age: 18 } === { age: 18 }` als auch `{ age: 18 } == { age: 18 }` den Wert `false` zur\xfcck."],"id":17,"options":["`You are an adult!`","`You are still an adult.`","`Hmm.. You don\'t have an age I guess`"],"problem":"function checkAge(data) {\\n\\tif (data === { age: 18 }) {\\n\\t\\tconsole.log(\\"You are an adult!\\");\\n\\t} else if (data == { age: 18 }) {\\n\\t\\tconsole.log(\\"You are still an adult.\\");\\n\\t} else {\\n\\t\\tconsole.log(`Hmm.. You don\'t have an age I guess`);\\n\\t}\\n}\\n\\ncheckAge({ age: 18 });\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Der Spread Operator (`...args`) gibt ein Array mit Argumenten zur\xfcck. Ein Array ist ein Objekt, sodass `typeof args` `\\"object\\"` ausgibt."],"id":18,"options":["`\\"number\\"`","`\\"array\\"`","`\\"object\\"`","`\\"NaN\\"`"],"problem":"function getAge(...args) {\\n\\tconsole.log(typeof args);\\n}\\n\\ngetAge(21);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Durch `\\"use strict\\"` kann man sicher stellen, dass man nicht versehentlich globale Variablen definiert. Da wir die Variable `age` nie definiert haben und `\\"use strict\\"` verwenden wirft JavaScript einen reference error aus. H\xe4tten wir `\\"use strict\\"` nicht verwendet, so h\xe4tte es funktioniert, da die property `age` dem globalen Objekt zugewiesen worden w\xe4re."],"id":19,"options":["`21`","`undefined`","`ReferenceError`","`TypeError`"],"problem":"function getAge() {\\n\\t\\"use strict\\";\\n\\tage = 21;\\n\\tconsole.log(age);\\n}\\n\\ngetAge();\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["`eval` evaluiert Code, der als String \xfcbergeben wurde. Falls es, wie in diesem Fall, eine Expression ist, so wird diese Expression auch evaluiert. Die Expression `10 * 10 + 5` gibt damit die nummer `105` aus."],"id":20,"options":["`105`","`\\"105\\"`","`TypeError`","`\\"10*10+5\\"`"],"problem":"const sum = eval(\\"10*10+5\\");\\n","question":"Was ist der Wert von `sum`?"},{"answer":1,"explanation":["Der Wert in `sessionStorage` geht verloren, wenn der _Tab_ geschlossen wird.","Wenn man stattdessen `localStorage` verwendet, bleibt der Wert f\xfcr immer bestehend, es sei denn `localStorage.clear()` wird ausgef\xfchrt."],"id":21,"options":["F\xfcr immer, der Wert geht nicht verloren.","Wenn der User den Tab schlie\xdft.","Wenn der User den Browser schlie\xdft, nicht nur den Tab.","Wenn der User den Computer neu startet."],"problem":"sessionStorage.setItem(\\"cool_secret\\", 123);\\n","question":"Wie lange ist cool_secret verf\xfcgbar?"},{"answer":1,"explanation":["Mit dem `var` Keyword kann man mehrere Variablen mit dem selben Namen definieren. Die Variable h\xe4lt dann den letzt gesetzten Wert.","Das ist nicht m\xf6glich mit `let` oder `const`, da diese dem Block Scope unterliegen."],"id":22,"options":["`8`","`10`","`SyntaxError`","`ReferenceError`"],"problem":"var num = 8;\\nvar num = 10;\\n\\nconsole.log(num);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Alle Object Keys (au\xdfgenommen Symbols) sind im Endeffekt Strings, selbst, wenn man diese nicht explizit als String definiert. Deshalb gibt `obj.hasOwnProperty(\'1\')` auch `true` zur\xfcck.","Das funktioniert nicht f\xfcr Set. Da wir keine `\'1\'` in unserem Set haben wirft `set.has(\'1\')` den Wert `false` zur\xfcck. Der Typ von `1` ist numerisch und `set.has(1)` gibt daher `true` zur\xfcck."],"id":23,"options":["`false` `true` `false` `true`","`false` `true` `true` `true`","`true` `true` `false` `true`","`true` `true` `true` `true`"],"problem":"const obj = { 1: \\"a\\", 2: \\"b\\", 3: \\"c\\" };\\nconst set = new Set([1, 2, 3, 4, 5]);\\n\\nobj.hasOwnProperty(\\"1\\");\\nobj.hasOwnProperty(1);\\nset.has(\\"1\\");\\nset.has(1);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Wenn man zwei Keys mit dem selben Namen hat, wird der erste Key ersetzt. Er wird immernoch an erster Stelle sein, allerdings mit dem zuletzt gesetzten Wert."],"id":24,"options":["`{ a\\"one\\", b\\"two\\" }`","`{ b\\"two\\", a\\"three\\" }`","`{ a\\"three\\", b\\"two\\" }`","`SyntaxError`"],"problem":"const obj = { a: \\"one\\", b: \\"two\\", a: \\"three\\" };\\nconsole.log(obj);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Der Base Execution Context entspricht dem Global Execution Context und ist \xfcberall in unserem Code verf\xfcgbar."],"id":25,"options":["wahr","falsch","kommt darauf an"],"problem":"","question":"Der JavaScript Global Execution Context erstellt zwei Dinge: das globale Objekt und das \\"this\\" Keyword."},{"answer":2,"explanation":["`continue` \xfcberspringt einen Durchlauf, wenn eine gewisse Bedingung erf\xfcllt ist und `true` zur\xfcck gibt."],"id":26,"options":["`1` `2`","`1` `2` `3`","`1` `2` `4`","`1` `3` `4`"],"problem":"for (let i = 1; i < 5; i++) {\\n\\tif (i === 3) continue;\\n\\tconsole.log(i);\\n}\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["`String` ist ein eingebauter Constructor, dem wir Properties zuweisen k\xf6nnen. Wir haben hier seinem Prototype eine Methode hinzugef\xfcgt. Primitive strings werden automatisch durch die String Prototype Function in ein String Objekt umgewandelt. Daher haben alle Strings (String Objects) Zugriff auf diese Methode."],"id":27,"options":["`\\"Just give Lydia pizza already!\\"`","`TypeErrornot a function`","`SyntaxError`","`undefined`"],"problem":"String.prototype.giveLydiaPizza = () => {\\n\\treturn \\"Just give Lydia pizza already!\\";\\n};\\n\\nconst name = \\"Lydia\\";\\n\\nname.giveLydiaPizza();\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Objekt Keys werden automatisch in Strings umgewandelt. Wir versuchen ein Objekt mit dem Wert `123` als Key dem Objekt `a` zuzuweisen.","Allerdings wird ein Object, wenn es in einen String umgewandelt wird als `\\"[object Object]\\"` ausgegeben. Was wir hier also sagen ist, dass `a[\\"object Object\\"] = 123` ist. Wir versuchen das gleiche erneut - `c` ist ein anderes Objekt, welches wir implizit zu einem String umwandeln, sodass `a[\\"object Object\\"] = 456` ist.","Dann loggen wir `a[b]`, was eigentlich `a[\\"object Object\\"]` ist und gerade von uns zu `456` gesetzt wurde, sodass `456` ausgegeben wird."],"id":28,"options":["`123`","`456`","`undefined`","`ReferenceError`"],"problem":"const a = {};\\nconst b = { key: \\"b\\" };\\nconst c = { key: \\"c\\" };\\n\\na[b] = 123;\\na[c] = 456;\\n\\nconsole.log(a[b]);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Wir haben eine `setTimeout` Funktion, die zuerst ausgef\xfchrt wird und dennoch als letztes ausgegeben wird.","Der Grund daf\xfcr ist, dass Browser nicht nur die Runtime Engine, sondern auch eine `WebAPI` haben. Die `WebAPI` stellt uns `setTimeout` bereit.","Nachdem die _Callback Function_ an die WebAPI \xfcbergeben wurde wird `setTimeout` (aber nicht die Callback Function) ausgef\xfchrt und aus dem Stack entfernt.","<img src=\\"https://i.imgur.com/X5wsHOg.png\\" width=\\"200\\">","Jetzt wird `foo` ausgef\xfchrt und `\\"First\\"` geloggt.","<img src=\\"https://i.imgur.com/Pvc0dGq.png\\" width=\\"200\\">","`foo` wird aus dem Stack entfernt und `baz` wird ausgef\xfchrt. `\\"Third\\"` wird geloggt.","<img src=\\"https://i.imgur.com/WhA2bCP.png\\" width=\\"200\\">","Die WebAPI kann nicht einfach Dinge zum Stack hinzuf\xfcgen, wenn sie bereit ist, stattdessen wird die Callback Function zur _queue_ hinzugef\xfcgt.","<img src=\\"https://i.imgur.com/NSnDZmU.png\\" width=\\"200\\">","Das ist, wo die Event Loop ins Spiel kommt. Die **Event Loop** betrachtet den Stack und die Task Queue. Wenn der Stack leer ist wird das erste Element in der Queue zum Stack \xfcbertragen.","<img src=\\"https://i.imgur.com/uyiScAI.png\\" width=\\"200\\">","`bar` wird ausgef\xfchrt, `\\"Second\\"` wird geloggt und aus dem Stack entfernt."],"id":29,"options":["`First` `Second` `Third`","`First` `Third` `Second`","`Second` `First` `Third`","`Second` `Third` `First`"],"problem":"const foo = () => console.log(\\"First\\");\\nconst bar = () => setTimeout(() => console.log(\\"Second\\"));\\nconst baz = () => console.log(\\"Third\\");\\n\\nbar();\\nfoo();\\nbaz();\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Das am tiefsten genestete Element, welches das Event ausl\xf6st ist das Event Target. Man kann den Bubbling Prozess mit `event.stopPropagation` anhalten."],"id":30,"options":["\xc4u\xdferer `div`","Innerer `div`","`button`","Ein Array mit allen genesteten Elementen"],"problem":"<div onclick=\\"console.log(\'first div\')\\">\\n\\t<div onclick=\\"console.log(\'second div\')\\">\\n\\t\\t<button onclick=\\"console.log(\'button\')\\">\\n\\t\\t\\tClick!\\n\\t\\t</button>\\n\\t</div>\\n</div>\\n","question":"Was ist event.target wenn ein Button geklickt wird?"},{"answer":0,"explanation":["Wenn wir auf den Paragraph klicken, sehen wir zwei logs: `p` und `div`. W\xe4hrend der Event Propagation werden drei Phasen ausgef\xfchrt: capturing, target und bubbling. Standardm\xe4\xdfig werden Event Handler in der Bubbling Phase ausgef\xfchrt (es sei denn man setzt `useCapture` auf `true`). Die Ausf\xfchrung beginnt vom tiefsten Element nach Au\xdfen."],"id":31,"options":["`p` `div`","`div` `p`","`p`","`div`"],"problem":"<div onclick=\\"console.log(\'div\')\\">\\n\\t<p onclick=\\"console.log(\'p\')\\">\\n\\t\\tClick here!\\n\\t</p>\\n</div>\\n","question":"Was ist der geloggte Output, wenn man auf den Paragraph klickt?"},{"answer":3,"explanation":["In beiden F\xe4llen k\xf6nnen wir das Objekt weiter reichen, auf welches sich das `this` Keyword beziehen soll. Allerdings wird `.call` _sofort ausgef\xfchrt_.","`.bind.` gibt eine _Kopie_ der Funktion mit gebundenem Context zur\xfcck und wird daher nicht sofort ausgef\xfchrt."],"id":32,"options":["`undefined is 21` `Lydia is 21`","`function` `function`","`Lydia is 21` `Lydia is 21`","`Lydia is 21` `function`"],"problem":"const person = { name: \\"Lydia\\" };\\n\\nfunction sayHi(age) {\\n\\tconsole.log(`${this.name} is ${age}`);\\n}\\n\\nsayHi.call(person, 21);\\nsayHi.bind(person, 21);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Die `sayHi` Funktion gibt den Wert der sofort ausgef\xfchrten Funktion (IIFE) zur\xfcck. Die Funktion gibt `0` zur\xfcck, was vom Typ `\\"number\\"` ist.","Es gibt nur 7 eingebaute Typen in JavaScript: `null`, `undefined`, `boolean`, `number`, `string`, `object`, `symbol`, und `bigint`. `\\"function\\"` ist kein Typ, weil Funktionen Objekte sind und daher dem Typ `\\"object\\"` entsprechen."],"id":33,"options":["`\\"object\\"`","`\\"number\\"`","`\\"function\\"`","`\\"undefined\\"`"],"problem":"function sayHi() {\\n\\treturn (() => 0)();\\n}\\n\\ntypeof sayHi();\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Es gibt nur 6 falsy typen:","`undefined`","`null`","`NaN`","`0`","`\'\'` (leerer String)","`false`","Funktions-Constructor, wie `new Number` und `new Boolean` sind truthy."],"id":34,"options":["`0`, `\'\'`, `undefined`","`0`, `new Number(0)`, `\'\'`, `new Boolean(false)`, `undefined`","`0`, `\'\'`, `new Boolean(false)`, `undefined`","Alle sind falsy"],"problem":"0;\\nnew Number(0);\\n(\\"\\");\\n(\\" \\");\\nnew Boolean(false);\\nundefined;\\n","question":"Welcher dieser Werte ist falsy?"},{"answer":1,"explanation":["`typeof 1` gibt `\\"number\\"` zur\xfcck.\\n`typeof \\"number\\"` gibt `\\"string\\"` zur\xfcck."],"id":35,"options":["`\\"number\\"`","`\\"string\\"`","`\\"object\\"`","`\\"undefined\\"`"],"problem":"console.log(typeof typeof 1);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Wenn Werte einem Element in einem Array zugewiesen werden, die die L\xe4nge des Arrays \xfcbersteigen, so erstellt JavaScript \\"empty slots\\" (leere Stellen). Diese haben den Wert `undefined`, aber das Array sieht dann in etwa so aus:","`[1, 2, 3, 7 x empty, 11]`","abh\xe4ngig davon wo das Array ausgef\xfchrt wird (die Ausgabe ist unterschiedlich f\xfcr verschiedene Browser, Node, etc.)"],"id":36,"options":["`[1, 2, 3, 7 x null, 11]`","`[1, 2, 3, 11]`","`[1, 2, 3, 7 x empty, 11]`","`SyntaxError`"],"problem":"const numbers = [1, 2, 3];\\nnumbers[10] = 11;\\nconsole.log(numbers);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Der `catch` Block erh\xe4lt ein Argument `x`. Das ist nicht das selbe `x` wie die Variable, der wir Argumente zuweisen. Die Variable `x` ist block-scoped.","Sp\xe4ter setzen wir die block-scoped Variable gleich `1`, und setzen ebenfalls den Wert der Variable `y`. Jetzt loggen wir die block-scoped Variable `x` mit dem Wert `1`.","Au\xdferhalb des `catch` Blocks ist `x` noch immer `undefined` und `y` ist `2`. Wenn wir `console.log(x)` au\xdferhalb des `catch` Block ausf\xfchren, wird f\xfcr `x` der Wert `undefined` und f\xfcr `y` der Wert `2` geloggt."],"id":37,"options":["`1` `undefined` `2`","`undefined` `undefined` `undefined`","`1` `1` `2`","`1` `undefined` `undefined`"],"problem":"(() => {\\n\\tlet x, y;\\n\\ttry {\\n\\t\\tthrow new Error();\\n\\t} catch (x) {\\n\\t\\t(x = 1), (y = 2);\\n\\t\\tconsole.log(x);\\n\\t}\\n\\tconsole.log(x);\\n\\tconsole.log(y);\\n})();\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["JavaScript hat nur primitive Typen und Objekte.","Primitive Typen sind `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, und `symbol`.","Was einen primitiven Typ von einem Objekt unterscheidet ist, dass Primitive keine Properties oder Methoden haben, obwohl zum Beispiel `\'foo\'.toUpperCase()` zu `\'FOO\'` wird und keinen `TypeError` auswirft. Der Grund daf\xfcr ist, wenn man eine Property oder Method an einem primitiven Typ wie einem String ausf\xfchrt, legt JavaScript eine Wrapper Class um das String Objekt, die danach sofort wieder entfernt wird, wenn die Expression ausgef\xfchrt wurde. Alle primitiven Typen au\xdfer `null` und `undefined` weisen dieses Verhalten auf."],"id":38,"options":["Primitive oder Object","Function oder Object","Fangfragenur Objects!","Number oder Object"],"problem":"","question":"Alles in JavaScript ist entweder ein ..."},{"answer":2,"explanation":["`[1, 2]` ist unser urspr\xfcnglicher Wert. Zusammen mit dem ersten `acc` ist das der Wert, mit dem wir beginnen. W\xe4hrend dem ersten Durchlauf ist `acc` gleich `[1, 2]`, und `cur` ist `[0, 1]`. Wir verbinden diese, was `[1, 2, 0, 1]` ergibt.","Dann entspricht `acc` gleich `[1, 2, 0, 1]` und `cur` ist gleich `[2, 3]`. Wir verbinden diese und bekommen `[1, 2, 0, 1, 2, 3]`."],"id":39,"options":["`[0, 1, 2, 3, 1, 2]`","`[6, 1, 2]`","`[1, 2, 0, 1, 2, 3]`","`[1, 2, 6]`"],"problem":"[[0, 1], [2, 3]].reduce(\\n\\t(acc, cur) => {\\n\\t\\treturn acc.concat(cur);\\n\\t},\\n\\t[1, 2],\\n);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["`null` ist falsy. `!null` gibt `true` zur\xfcck. `!true` gibt `false` zur\xfcck.","`\\"\\"` ist falsy. `!\\"\\"` gibt `true` zur\xfcck. `!true` gibt `false` zur\xfcck.","`1` ist truthy. `!1` gibt `false` zur\xfcck. `!false` gibt `true` zur\xfcck."],"id":40,"options":["`false` `true` `false`","`false` `false` `true`","`false` `true` `true`","`true` `true` `false`"],"problem":"!!null;\\n!!\\"\\";\\n!!1;\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Es gibt eine unique id zur\xfcck. Diese id kann zum Beispiel verwendet werden um das Interval mit der `clearInterval()` Funktion zu leeren."],"id":41,"options":["Eine unique id","Die definierte Anzahl von Millisekunden","Die Callback Function","`undefined`"],"problem":"setInterval(() => console.log(\\"Hi\\"), 1000);\\n","question":"Was gibt die `setInterval` Method zur\xfcck?"},{"answer":0,"explanation":["Ein String ist ein Iterable. Der Spread Operator mappt jedes Zeichen eines Iterables zu einem eigenen Element."],"id":42,"options":["`[\\"L\\", \\"y\\", \\"d\\", \\"i\\", \\"a\\"]`","`[\\"Lydia\\"]`","`[[], \\"Lydia\\"]`","`[[\\"L\\", \\"y\\", \\"d\\", \\"i\\", \\"a\\"]]`"],"problem":"[...\\"Lydia\\"];\\n","question":"Was wird hier ausgegeben?"},{"answer":2,"explanation":["Regul\xe4re Funktionen k\xf6nnen nicht angehalten werden, wenn sie bereits aufgerufen wurden. Eine Generator Funktion kann dagegen auch angehalten werden, nachdem sie aufgerufen wurde und sp\xe4ter fortgesetzt werden, wo sie angehalten wurde. Jedes Mal, wenn eine Generator Funktion ein `yield` Keyword findet, wirft die Funktion den danach ermittelten Wert aus. Wichtig: _yield_ ist nichtdas selbe wie _return_.","Zuerst initialisieren wir die Generator Funktion mit `i` gleich `10`. Wir rufen die Generator Funktion mit der `next()` Methode auf. Beim ersten Aufruf der Generator Funktion is `i` gleich `10`. Wenn wir bei `yield` ankommen wird der Wert von `i` ausgegeben. Der Generator wird angehalten und `10` wird geloggt.","Dann wird die Funktion erneut mit der `next()` Methode aufgerufen und beginnt von dort, wo sie zuletzt angehalten wurde, nach wie vor mit `i` gleich `10`. Jetzt erreichen wir das n\xe4chste `yield` Keyword bei `i * 2`. `i` ist gleich `10`, sodass das Ergebnis von `10 * 2` ausgegeben wird, was `20` ist. Das Ergebnis ist `10, 20`."],"id":43,"options":["`[0, 10], [10, 20]`","`20, 20`","`10, 20`","`0, 10 und 10, 20`"],"problem":"function* generator(i) {\\n  yield i;\\n  yield i * 2;\\n}\\n\\nconst gen = generator(10);\\n\\nconsole.log(gen.next().value);\\nconsole.log(gen.next().value);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Wenn wir mehrere Promises in die `Promice.race` Methode eingegeben, wird das Promise, welches _zuerst_ gel\xf6st/abgelehnt wird auch hier gel\xf6st/abgelehnt. Die `setTimeout` Methode bekommt einen Timer von 500ms f\xfcr das erste Promise (`firstPromise`) \xfcbergeben, und 100ms f\xfcr das zweite Promise (`secondPromise`). Das bedeutet, dass `secondPromise` mit dem Wert `\'two\'` zuerst gel\xf6st wird und an `res` \xfcbergeben wird. Der Wert wird geloggt."],"id":44,"options":["`\\"one\\"`","`\\"two\\"`","`\\"two\\" \\"one\\"`","`\\"one\\" \\"two\\"`"],"problem":"const firstPromise = new Promise((res, rej) => {\\n  setTimeout(res, 500, \\"one\\");\\n});\\n\\nconst secondPromise = new Promise((res, rej) => {\\n  setTimeout(res, 100, \\"two\\");\\n});\\n\\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\\n","question":"Was wird hier ausgegeben?"},{"answer":3,"explanation":["Zuerst definieren wir die Variable `person` mit dem Wert eines Objekts, welches eine `name` Property hat.","<img src=\\"https://i.imgur.com/TML1MbS.png\\" width=\\"200\\">","Dann definieren wir eine Variable namens `members`. Wir setzen das erste Element des Arrays gleich dem Wert der `person` Variable. Objekte interagieren durch eine _Referenz_, wenn diese gleichgesetzt werden. Wenn eine Referenz von einer Variable zur anderen gleichgesetzt wird, so wird eine _Kopie_ der Referenz erstellt (Wichtig: nicht die _selbe_ Referenz!)","<img src=\\"https://i.imgur.com/FSG5K3F.png\\" width=\\"300\\">","Dann setzen wir die Variable `person` gleich `null`.","<img src=\\"https://i.imgur.com/sYjcsMT.png\\" width=\\"300\\">","Wir \xe4ndern nur den Wert der Variable `person` und nicht das erste Element im Array, da das Element eine andere Referenz als das Objekt hat (Kopie). Das erste Element in `members` beinhaltet immernoch die Referenz zum original Objekt. Wenn wir das `members` Array loggen ist dieses immernoch der Wert des Objekts, welches dann geloggt wird."],"id":45,"options":["`null`","`[null]`","`[{}]`","`[{ name\\"Lydia\\" }]`"],"problem":"let person = { name: \\"Lydia\\" };\\nconst members = [person];\\nperson = null;\\n\\nconsole.log(members);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Mit einer `for-in` Schleife k\xf6nnen wir \xfcber Objekt Keys iterieren - in diesem Fall `name` und `age`. Im Endeffekt sind Objekt Keys Strings (oder Symbols). Bei jedem Durchlauf setzen wir den Wert von `item` gleich zum aktuellen Key. Zuerst ist `item` gleich `name` und wird geloggt. Dann wird `item` gleich `age` gesetzt und wird geloggt."],"id":46,"options":["`{ name\\"Lydia\\" }, { age21 }`","`\\"name\\", \\"age\\"`","`\\"Lydia\\", 21`","`[\\"name\\", \\"Lydia\\"], [\\"age\\", 21]`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n};\\n\\nfor (const item in person) {\\n  console.log(item);\\n}\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Operator Assoziativit\xe4t ist die Reihenfolge, in der der Compiler die Expression evaluiert, entweder links-nach-rechts oder rechts-nach-links. Das funktioniert nur, wenn alle Operatoren die _gleiche_ Priorit\xe4t haben. Hier haben wir nur einen Operator: `+`. F\xfcr Addition ist die Assoziativit\xe4t links-nach-rechts.","`3 + 4` wird zuerst errechnet, das Ergebnis ist `7`.","`7 + \'5\'` ergibt `\\"75\\"` (aufgrund von Coercion). JavaScript wandelt `7` in einen String um (Siehe Frage 15). Zwei Strings werden durch den `+` Operator zusammengesetzt.`\\"7\\" + \\"5\\"` ergibt `\\"75\\"`."],"id":47,"options":["`\\"345\\"`","`\\"75\\"`","`12`","`\\"12\\"`"],"problem":"console.log(3 + 4 + \\"5\\");\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Nur die erste Zahl im String wird ausgegeben. Aufgrund des _radix_ (das zweite Argument definiert, welchen Typ einer Zahl wir parsen wollen: Basis 10, hexadezimal, Octal, Binary, etc.) pr\xfcft `parseInt` ob die Zeichen im String g\xfcltig sind. Wenn ein Zeichen erkannt wird, welches nicht g\xfcltig ist, wird der Parse Vorgang beendet und die nachfolgenden Zeichen werden ignoriert.","`*` ist keine g\xfcltige Nummer, sodass nur `\\"7\\"` als Dezimal geparsed wird: `7`. `num` ist jetzt gleich `7`."],"id":48,"options":["`42`","`\\"42\\"`","`7`","`NaN`"],"problem":"const num = parseInt(\\"7*6\\", 10);\\n","question":"Was ist der Wert von `num`?"},{"answer":2,"explanation":["Wenn man \xfcber das Array mappt, ist `num` gleich dem Element, welches gerade durchlaufen wird. In diesem Fall sind die Elemente Nummern, sodass die Kondition der If-Schleife `typeof num === \\"number\\"` erf\xfcllt ist und `true` zur\xfcck gibt. Die map Funktion erstellt ein neues Array und beinhaltet die Werte der Funktion.","Allerdings geben wir keinen Wert aus. Wenn unsere Funktion keinen Wert ausgibt, ist der Standard \\"return\\" `undefined`. F\xfcr jedes Element im Array wird die Funktion aufgerufen, sodass f\xfcr jedes Element `undefined` ausgegeben wird."],"id":49,"options":["`[]`","`[null, null, null]`","`[undefined, undefined, undefined]`","`[ 3 x empty ]`"],"problem":"[1, 2, 3].map(num => {\\n  if (typeof num === \\"number\\") return;\\n  return num * 2;\\n});\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Argumente werden als _Wert_ \xfcbergeben, es sei denn ihr Wert ist ein Objekt, dann werden sie als _Referenz_ \xfcbergeben. `birthYear` wird als Wert \xfcbergeben, da es ein String ist und kein Objekt. Wenn Argumente als Wert \xfcbergeben werden, wird eine _Kopie_ des Wertes erstellt (Siehe Frage 46).","Die Variable `birthYear` beinhaltet eine Referenz zum Wert `\\"1997\\"`. Das Argument `year` beinhaltet ebenso eine Referenz zum Wert `\\"1997\\"`, aber die Werte sind nicht identisch! Wenn wir den Wert von `year` \xe4ndern, indem wir ihn gleich `\\"1998\\"` setzen, \xe4ndern wir nur den Wert von `year`. `birthYear` ist immernoch `\\"1997\\"`.","Der Wert von `person` ist ein Objekt, sodass das Argument `member` eine Kopie der Referenz des _gleichen_ Objekts hat. Wenn wir also eine Property dessen Objekt `member` eine Referenz enth\xe4lt, wird der Wert von `person` ebenso ge\xe4ndert, da beide die gleiche Referenz zum selben Objekt beinhalten. Die Property `name` von `person` ist jetzt gleich `\\"Lydia\\"`."],"id":50,"options":["`{ name\\"Lydia\\" }, \\"1997\\"`","`{ name\\"Sarah\\" }, \\"1998\\"`","`{ name\\"Lydia\\" }, \\"1998\\"`","`{ name\\"Sarah\\" }, \\"1997\\"`"],"problem":"function getInfo(member, year) {\\n  member.name = \\"Lydia\\";\\n  year = 1998;\\n}\\n\\nconst person = { name: \\"Sarah\\" };\\nconst birthYear = \\"1997\\";\\n\\ngetInfo(person, birthYear);\\n\\nconsole.log(person, birthYear);\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Mit dem `throw` Statement k\xf6nnen wir individuelle Fehlermeldungen erstellen und Exceptions erstellen. Eine Exception kann ein <b>String</b>, eine <b>Nummer</b>, ein <b>Boolean</b> oder ein <b>Objekt</b> sein. In diesem Fall ist unsere Exception der String `\'Hello world\'`.","Mit dem `catch` Statement k\xf6nnen wir definieren, was passiert, wenn die Exception im `try` Block eintritt. Wenn die Exception eintritt wird der String `\'Hello world\'` ausgegeben. Nun loggen wir `e`, was gleich dem String ist. Das Ergebnis ist `\'Oh an error: Hello world\'`."],"id":51,"options":["`\\"It worked! Hello world!\\"`","`\\"Oh no an errorundefined\\"`","`SyntaxErrorcan only throw Error objects`","`\\"Oh no an error! Hello world!\\"`"],"problem":"function greeting() {\\n  throw \\"Hello world!\\";\\n}\\n\\nfunction sayHi() {\\n  try {\\n    const data = greeting();\\n    console.log(\\"It worked!\\", data);\\n  } catch (e) {\\n    console.log(\\"Oh no an error!\\", e);\\n  }\\n}\\n\\nsayHi();\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Wenn man eine Property ausgibt ist der Wert der Property gleich dem ausgegeben Wert und nicht dem Wert, der im Constructor definiert wurde. Wir geben den String `\\"Maserati\\"` aus, sodass `myCar.make` gleich `\\"Maserati\\"` ist."],"id":52,"options":["`\\"Lamborghini\\"`","`\\"Maserati\\"`","`ReferenceError`","`TypeError`"],"problem":"function Car() {\\n  this.make = \\"Lamborghini\\";\\n  return { make: \\"Maserati\\" };\\n}\\n\\nconst myCar = new Car();\\nconsole.log(myCar.make);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["`let x = y = 10;` ist kurz f\xfcr:","Wenn wir `y` gleich `10` setzen, erstellen wir eigentlich eine Property `y` im globalen Objekt (`window` im Browser oder `global` in Node). Im Browser ist jetzt `window.y` gleich `10`.","Dann erstellen wir eine Variable `x` mit dem Wert von `y` (`10`). Variablen, die mit `let` erstellt werden sind _Block-Scoped_, was bedeutet, dass sie nur in dem Block existieren, wo sie erstellt wurden \u2013 der hier erstellte Funktion (IIFE) in diesem Fall. Wenn wir den `typeof` Operator nutzen ist `x` nicht definiert. Wir versuchen auf `x` au\xdferhalb des Scopes zuzugreifen, was bedeutet, dass `x` `\\"undefined\\"` ist. `console.log(typeof x)` gibt daher `\\"undefined\\"` aus.","Da wir die Variable `y` aber global erstellt haben ist ihr Wert `10` auch hier verf\xfcgbar und \xfcberall in userem Code aufrufbar. `y` ist definiert und beinhaltet einen Wert vom Typ `\\"number\\"`. `console.log(typeof y)` gibt daher `\\"number\\"` aus."],"id":53,"options":["`\\"undefined\\", \\"number\\"`","`\\"number\\", \\"number\\"`","`\\"object\\", \\"number\\"`","`\\"number\\", \\"undefined\\"`"],"problem":"(() => {\\n  let x = (y = 10);\\n})();\\n\\nconsole.log(typeof x);\\nconsole.log(typeof y);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Properties von Objekten k\xf6nnen mit dem `delete` Keyword entfernt werden, selbst am Prototype. Beim entfernen von Properties am Prototype ist zu beachten, dass diese dann aus der Prototypen-Kette verschwinden. In unserem Fall existiert die `bark` Funktion nicht mehr am Prototype nachdem `delete Dog.prototype.bark` ausgef\xfchrt wurde.","Wenn wir versuchen etwas auszuf\xfchren, was keine Funktion ist, wird ein `TypeError` ausgeworfen. In diesem Fall `TypeError: pet.bark is not a function`, da `pet.bark` `undefined` ist."],"id":54,"options":["`\\"Woof I am Mara\\"`, `TypeError`","`\\"Woof I am Mara\\"`,`\\"Woof I am Mara\\"`","`\\"Woof I am Mara\\"`, `undefined`","`TypeError`, `TypeError`"],"problem":"class Dog {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n}\\n\\nDog.prototype.bark = function() {\\n  console.log(`Woof I am ${this.name}`);\\n};\\n\\nconst pet = new Dog(\\"Mara\\");\\n\\npet.bark();\\n\\ndelete Dog.prototype.bark;\\n\\npet.bark();\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Das `Set` Objekt ist eine Sammlung von _eindeutigen_ Werten: jeder Wert kann nur ein Mal in einem Set vorkommen.","Wir \xfcbergeben `[1, 1, 2, 3, 4]` mit einer doppelten `1`. Da wir keine doppelten Werte in einem Set haben k\xf6nnen wird eine `1` entfernt. Das Ergebnis ist `{1, 2, 3, 4}`."],"id":55,"options":["`[1, 1, 2, 3, 4]`","`[1, 2, 3, 4]`","`{1, 1, 2, 3, 4}`","`{1, 2, 3, 4}`"],"problem":"const set = new Set([1, 1, 2, 3, 4]);\\n\\nconsole.log(set);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Ein importiertes Modul ist _read-only_, was bedeutet, dass importierte Module nicht ge\xe4ndert werden k\xf6nnen. Nur das Modul, welches diese exportiert kann deren Wert \xe4ndern.","Wenn wir also den Wert von `myCounter` erh\xf6hen bekommen wir den Fehler `myCounter is read-only and cannot be modified`."],"id":56,"options":["`10`","`11`","`Error`","`NaN`"],"problem":"// counter.js\\nlet counter = 10;\\nexport default counter;\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Der `delete` Operator gibt einen Boolean Wert zur\xfcck: `true` bei erfolgreichem entfernen, oder andernfalls `false`. Variablen, die mit `var`, `let` oder `const` deklariert werden, k\xf6nnen andererseits  nicht mit `delete` entfernt werden.","Der Wert von `name` wurde mit `const` deklariert, weshalb `delete` nicht m\xf6glich ist und `false` zur\xfcckgegeben wird. Als wir `age` den Wert `21` zugewiesen haben, haben wir eine Property `age` zum globalen Objekt hinzugef\xfcgt. Diese Properties kann man mit `delete` entfernen, sodass `delete age` `true` zur\xfcckgibt."],"id":57,"options":["`false`, `true`","`\\"Lydia\\"`, `21`","`true`, `true`","`undefined`, `undefined`"],"problem":"const name = \\"Lydia\\";\\nage = 21;\\n\\nconsole.log(delete name);\\nconsole.log(delete age);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Wir k\xf6nnen durch Destructuring Werte aus Arrays oder Properties aus Objekten entpacken. Zum Beispiel:","<img src=\\"https://i.imgur.com/ADFpVop.png\\" width=\\"200\\">","Der Wert von `a` ist jetzt `1` und der Wert von `b` ist jetzt `2`. Was wir in der Frage eigentlich getan haben ist:","<img src=\\"https://i.imgur.com/NzGkMNk.png\\" width=\\"200\\">","Das bedeutet, dass der Wert von `y` gleich des ersten Wertes im Array ist, sprich der Zahl `1` entspricht. Wenn wir `y` loggen bekommen wir `1` ausgegeben."],"id":58,"options":["`[[1, 2, 3, 4, 5]]`","`[1, 2, 3, 4, 5]`","`1`","`[1]`"],"problem":"const numbers = [1, 2, 3, 4, 5];\\nconst [y] = numbers;\\n\\nconsole.log(y);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Es ist m\xf6glich Objekte mit dem Spread Operator `...` zu verbinden. Dieser erstellt Kopien der Key/Value Paare eines Objektes und f\xfcgt diese dem anderen Objekt hinzu. In diesem Fall wird eine Kopie des `user` Objekts erstellt und dem `admin` Objekt zugewiesen. Das `admin` Objekt beinhaltet nun die kopierten Key/Value Paare, sodass das Ergebnis `{ admin: true, name: \\"Lydia\\", age: 21 }` ist."],"id":59,"options":["`{ admintrue, user{ name\\"Lydia\\", age21 } }`","`{ admintrue, name\\"Lydia\\", age21 }`","`{ admintrue, user[\\"Lydia\\", 21] }`","`{ admintrue }`"],"problem":"const user = { name: \\"Lydia\\", age: 21 };\\nconst admin = { admin: true, ...user };\\n\\nconsole.log(admin);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Mit der `defineProperty` Methode k\xf6nnen wir neue Properties zu einem Objekt hinzuf\xfcgen oder bestehende modifizieren. Wenn wir mit der `defineProperty` Methode Properties einem Objekt hinzuf\xfcgen, sind diese standardm\xe4\xdfig _nicht z\xe4hlbar_. Die `Object.keys` Methode gibt alle _z\xe4hlbaren_ Property Namen eines Objektes zur\xfcck, in diesem Fall nur `\\"name\\"`.","Properties, die mit `defineProperty` erstellt wurden sind standardm\xe4\xdfig unver\xe4nderbar. Man kann dieses Verhalten mit den `writable`, `configurable` und `enumerable` Properties ver\xe4ndern. Auf diese Art gibt die `defineProperty` Methode mehr Kontrolle \xfcber die Properties, die einem Objekt hinzugef\xfcgt werden."],"id":60,"options":["`{ name\\"Lydia\\", age21 }`, `[\\"name\\", \\"age\\"]`","`{ name\\"Lydia\\", age21 }`, `[\\"name\\"]`","`{ name\\"Lydia\\"}`, `[\\"name\\", \\"age\\"]`","`{ name\\"Lydia\\"}`, `[\\"age\\"]`"],"problem":"const person = { name: \\"Lydia\\" };\\n\\nObject.defineProperty(person, \\"age\\", { value: 21 });\\n\\nconsole.log(person);\\nconsole.log(Object.keys(person));\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Das zweite Argument von `JSON.stringify` ist ein _Replacer_. Der Replacer kann entweder eine Funktion oder ein Array sein und gibt uns Kontrolle dar\xfcber, wie die Werte in Strings umgewandelt werden sollen.","Wenn der Replacer ein _Array_ ist, werden nur die Properties dem JSON String hinzugef\xfcgt, die in dem Array aufgef\xfchrt sind. In diesem Fall sind das nur `\\"level\\"` und `\\"health\\"`. `\\"username\\"` ist ausgeschlossen. `data` ist jetzt gleich `\\"{\\"level\\":19, \\"health\\":90}\\"`.","Wenn der Replacer eine _Funktion_ ist, so wird diese Funktion f\xfcr jede Property im Objekt aufgerufen, die in Strings umgewandelt wird. Der Wert, den die Funktion zur\xfcckgibt, ist der Wert der Property, die dem JSON String hinzugef\xfcgt wird. Ist der Wert `undefined`, so wird die Property ausgeschlossen."],"id":61,"options":["`\\"{\\"level\\":19, \\"health\\":90}\\"`","`\\"{\\"username\\"\\"lydiahallie\\"}\\"`","`\\"[\\"level\\", \\"health\\"]\\"`","`\\"{\\"username\\"\\"lydiahallie\\", \\"level\\":19, \\"health\\":90}\\"`"],"problem":"const settings = {\\n  username: \\"lydiahallie\\",\\n  level: 19,\\n  health: 90\\n};\\n\\nconst data = JSON.stringify(settings, [\\"level\\", \\"health\\"]);\\nconsole.log(data);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Der un\xe4re Operator `++` _gibt zuerst_ den Wert des Operanden aus und _erh\xf6ht danach_ den Wert des Operanden. Der Wert `num1` ist `10`, da `increaseNumber` zuerst den Wert von `num1` (`10`) ausgibt und ihn danach erh\xf6ht.","`num2` ist gleich `10`, da wir `num1` `increasePassedNumber` zugewiesen haben. `number` ist gleich `10` (der Wert von `num1`). Der un\xe4re Operator `++` gibt erneut _zuerst_ den Wert des Operanden aus und _erh\xf6ht danach_ den Wert. Der Wert von `number` ist `10`, sodass `num2` ebenfalls `10` ist."],"id":62,"options":["`10`, `10`","`10`, `11`","`11`, `11`","`11`, `12`"],"problem":"let num = 10;\\n\\nconst increaseNumber = () => num++;\\nconst increasePassedNumber = number => number++;\\n\\nconst num1 = increaseNumber();\\nconst num2 = increasePassedNumber(num1);\\n\\nconsole.log(num1);\\nconsole.log(num2);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["In ES6 k\xf6nnen wir Parameter mit einem Standardwert initialisieren. Der Wert des Parameters wird als Standard gesetzt, wenn kein anderer Wert \xfcbergeben wird oder der Wert des Parameters `\\"undefined\\"` ist. In diesem Fall verteilen wir die Properties von `value` in einem neuen Objekt, sodass `x` den Standardwert `{ number: 10 }` bekommt.","Das Standard Argument wird beim _Aufruf_ evaluiert. Jedes Mal, wenn wir die Funktion aufrufen, wird ein _neues_ Objekt erstellt. Wir rufen die `multiply` Funktion die ersten beiden Male auf ohne einen Wert zu \xfcbergeben: `x` hat daher den Standardwert `{ number: 10 }`. Wir loggen dann den multiplizierten Wert davon, sodass wir `20` bekommen.","Beim dritten Mal wird die `multiply` Funktion mit einem Argument f\xfcr `value` aufgerufen. Der `*=` Operator ist kurz f\xfcr `x.number = x.number * 2`: wir \xe4ndern den Wert von `x.number` und loggen den multiplizierten Wert `20`.","Beim vierten Mal \xfcbergeben wir wieder eine `value`. `x.number` wurde zuvor in `20` ge\xe4ndert, sodass `x.number *= 2` jetzt `40` loggt."],"id":63,"options":["`20`, `40`, `80`, `160`","`20`, `40`, `20`, `40`","`20`, `20`, `20`, `40`","`NaN`, `NaN`, `20`, `40`"],"problem":"const value = { number: 10 };\\n\\nconst multiply = (x = { ...value }) => {\\n  console.log((x.number *= 2));\\n};\\n\\nmultiply();\\nmultiply();\\nmultiply(value);\\nmultiply(value);\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Das erste Argument, welches die `reduce` Methode erh\xe4lt ist der _Akkumulator_ `x`. Das zweite Argument ist der _aktuelle Wert_, `y`. Durch die `reduce` Methode f\xfchren wir eine Callback Funktion an jedem Element des Arrays aus, was im Endeffekt einen einzelnen Wert ausgibt.","In diesem Beispiel geben wir nicht irgendwelche Werte aus, sondern loggen einfach nur den Akkumulator und den momentanen Wert.","Der Wert des Akkumulators ist gleich dem vorhergehenden Wert der Callback Funktion. Wenn wir `initialValue` nicht an die `reduce` Methode \xfcbergeben bleibt der Akkumulator gleich dem ersten Element des ersten Calls.","Beim ersten Call ist der Akkumulator (`x`) gleich `1` und der aktuelle Wert (`y`) ist `2`. Da wir in der Callback Funktion bleiben loggen wir den Akkumulator und den aktuellen Wert: `1` und `2`.","Wenn wir keinen Wert einer Funktion ausgeben wird `undefined` ausgegeben. Beim n\xe4chsten Call ist der Akkumulator daher `undefined` und der aktuelle Wert ist `3`. `undefined` und `3` werden geloggt.","Beim vierten Call geben wir wieder nichts aus, sodass der Akkumulator wieder `undefined` ist und der aktuelle Wert `4`. `undefined` und `4` werden geloggt.\\n</p>\\n</details>"],"id":64,"options":["`1` `2` und `3` `3` und `6` `4`","`1` `2` und `2` `3` und `3` `4`","`1` `undefined` und `2` `undefined` und `3` `undefined` und `4` `undefined`","`1` `2` und `undefined` `3` und `undefined` `4`"],"problem":"[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["In einer abgeleiteten Klasse kann das `this` Keyword nicht aufgerufen werden, bevor `super` aufgerufen wurde. Wenn man das versucht wird ein ReferenceError ausgeworfen: 1 und 4 w\xfcrden daher einen Referenz-Fehler ausgeben.","Mit dem `super` Keyword k\xf6nnen wir den Constructor der Elternklasse mit gegebenen Argumenten aufrufen. Der Constructor der Elternklasse erh\xe4lt das `name` Argument, sodass wir `name` an `super` \xfcbergeben m\xfcssen.","Die `Dog` Klasse erh\xe4lt zwei Argumente, `name` da es `Animal` erweitert und `size` als extra Property der `Dog` Klasse. Beide m\xfcssen an die Constructor Funktion von `Dog` \xfcbergeben werden, was nur bei Constructor 2 richtig ist.\\n</p>\\n</details>"],"id":65,"options":["1","2","3","4"],"problem":"class Dog {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n};\\n\\nclass Labrador extends Dog {\\n  // 1 \\n  constructor(name, size) {\\n    this.size = size;\\n  }\\n  // 2\\n  constructor(name, size) {\\n    super(name);\\n    this.size = size;\\n  }\\n  // 3\\n  constructor(size) {\\n    super(name);\\n    this.size = size;\\n  }\\n  // 4 \\n  constructor(name, size) {\\n    this.name = name;\\n    this.size = size;\\n  }\\n\\n};\\n","question":"Mit welchem Constructor k\xf6nnen wir die `Dog` Klasse erweitern?"},{"answer":1,"explanation":["Mit dem `import` Keyword werden alle importierten Module _vorgeparsed_. Das bedeutet, dass importierte Module _zuerst_ ausgef\xfchrt werden, der Code in der eigentlichen Datei wird _danach_ ausgef\xfchrt.","Das ist der gro\xdfe Unterschied zwischen `require()` in CommonJS und `import`. Mit `require()` k\xf6nnen Dependencies bei Bedarf geladen werden, w\xe4hrend der Code ausgef\xfchrt wird. H\xe4tten wir `require()` anstelle von `import` verwendet, w\xe4re `running index.js`, `running sum.js`, `3` in der Konsole geloggt worden."],"id":66,"options":["`running index.js`, `running sum.js`, `3`","`running sum.js`, `running index.js`, `3`","`running sum.js`, `3`, `running index.js`","`running index.js`, `undefined`, `running sum.js`"],"problem":"// index.js\\nconsole.log(\'running index.js);\\nimport { sum } from \'./sum.js\';\\nconsole.log(sum(1, 2));\\n\\n// sum.js\\nconsole.log(\'running sum.js\');\\nexport const sum = (a, b) => a + b;\\n","question":"Mit welchem Constructor k\xf6nnen wir die `Dog` Klasse erweitern?"},{"answer":0,"explanation":["Jedes Symbol ist eindeutig. Der Sinn des Argumentes, welches an das Symbol weitergegeben wird, ist dem Symbol eine Beschreibung zu geben. Der Wert des Symbols h\xe4ngt nicht von diesem Argument ab. Beim vergleichen der Symbole werden zwei komplett neue Symbole erstellt: das erste `Symbol(\'foo\')` und das zweite `Symbol(\'foo\')`. Diese beiden Werte sind eindeutig und nicht identisch, weshalb `Symbol(\'foo\') === Symbol(\'foo\')` `false` ausgibt."],"id":67,"options":["`true`, `true`, `false`","`false`, `true`, `false`","`true`, `false`, `true`","`true`, `true`, `true`"],"problem":"console.log(Number(2) === Number(2))\\nconsole.log(Boolean(false) === Boolean(false))\\nconsole.log(Symbol(\'foo\') === Symbol(\'foo\'))\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Mit der `padStart` Methode k\xf6nnen wir Padding am Anfang des Strings hinzuf\xfcgen. Der Wert, der an die Methode \xfcbergeben wird ist die _absolute_ L\xe4nge des Strings mit dem Padding. Der String `\\"Lydia Hallie\\"` hat eine L\xe4nge von `12`. `name.padStart(13)` f\xfcgt ein Leerzeichen am Anfang des Strings ein, weil 12 + 1 = 13 ist.","Falls der Wert, der an `padStart` \xfcbergeben wurde kleiner ist, als die L\xe4nge des Arrays, so wird kein Padding hinzugef\xfcgt."],"id":68,"options":["`\\"Lydia Hallie\\"`, `\\"Lydia Hallie\\"`","`\\"           Lydia Hallie\\"`, `\\"  Lydia Hallie\\"` (`\\"[13x whitespace]Lydia Hallie\\"`, `\\"[2x whitespace]Lydia Hallie\\"`)","`\\" Lydia Hallie\\"`, `\\"Lydia Hallie\\"` (`\\"[1x whitespace]Lydia Hallie\\"`, `\\"Lydia Hallie\\"`)","`\\"Lydia Hallie\\"`, `\\"Lyd\\"`,"],"problem":"const name = \\"Lydia Hallie\\"\\nconsole.log(name.padStart(13))\\nconsole.log(name.padStart(2))\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Mit dem `+` Operator k\xf6nnen Strings zusammengesetzt werden. In diesem Fall werden die Strings `\\"\ud83e\udd51\\"` und `\\"\ud83d\udcbb\\"` zusammengesetzt, was `\\"\ud83e\udd51\ud83d\udcbb\\"` ergibt."],"id":69,"options":["`\\"\ud83e\udd51\ud83d\udcbb\\"`","`257548`","Ein String, der den Emoji Code beinhaltet","Error"],"problem":"console.log(\\"\ud83e\udd51\\" + \\"\ud83d\udcbb\\");\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Eine Generator Funktion pausiert die Ausf\xfchrung, wenn das `yield` Keyword vorliegt. Zuerst m\xfcssen wir den String \\"Do you love JavaScript?\\" abwarten, was mit `game.next().value` m\xf6glich ist.","Jede Zeile wird ausgef\xfchrt, bis das erste `yield` Keyword auftritt. Da auf der ersten Zeile ein `yield` in der Funktion vorliegt wird die Ausf\xfchrung damit angehalten. Das bedeutet, dass die Variable `Antwort` _noch nicht definiert_ wurde.","Wenn wir `game.next(\\"Yes\\").value` aufrufen wird das vorhergehende `yield` durch den Wert des Parameters ersetzt, der an `next()` \xfcbergeben wird - `\\"Yes\\"` in diesem Fall. Der Wert der Variable `Antwort` ist jetzt gleich `\\"Yes\\"`. Das if-Statement gibt `false` aus und `JavaScript loves you back \u2764\ufe0f` wird geloggt."],"id":70,"options":["`game.next(\\"Yes\\").value` und `game.next().value`","`game.next.value(\\"Yes\\")` und `game.next.value()`","`game.next().value` und `game.next(\\"Yes\\").value`","`game.next.value()` und `game.next.value(\\"Yes\\")`"],"problem":"function* startGame() {\\n  const Antwort = yield \\"Do you love JavaScript?\\";\\n  if (Antwort !== \\"Yes\\") {\\n    return \\"Oh wow... Guess we\'re gone here\\";\\n  }\\n  return \\"JavaScript loves you back \u2764\ufe0f\\";\\n}\\n\\nconst game = startGame();\\nconsole.log(/* 1 */); // Do you love JavaScript?\\nconsole.log(/* 2 */); // JavaScript loves you back \u2764\ufe0f\\n","question":"Wie k\xf6nnen wir die Werte loggen, die nach dem `console.log` auskommentiert wurden?"},{"answer":2,"explanation":["`String.raw` gibt einen String aus, in dem die Escapes (`\\\\n`, `\\\\v`, `\\\\t` etc.) ignoriert werden! Backslashes sind problematisch, weil man mit sowas in der Art rechnen muss:","`` const path = `C:\\\\Documents\\\\Projects\\\\table.html` ``","Das w\xfcrde dann wiefolgt gerendert werden:","`\\"C:DocumentsProjects able.html\\"`","Mit `String.raw` werden diese ignoriert und das Ergebnis ist:","`C:\\\\Documents\\\\Projects\\\\table.html`","In unserem Fall ist das Ergebnis `Hello\\\\nworld`, was geloggt wird."],"id":71,"options":["`Hello world!`","`Hello` <br />&nbsp; &nbsp; &nbsp;`world`","`Hello\\\\nworld`","`Hello\\\\n` <br /> &nbsp; &nbsp; &nbsp;`world`"],"problem":"console.log(String.raw`Hello\\\\nworld`);\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Eine `async` Funktion gibt immer ein Promise zur\xfcck. Mit `await` wird das Ergebnis des Promises abgewartet und ein ausstehendes Promise wird ausgegeben, wenn wir `getData()` aufrufen um `data` gleich zu setzen.","Wenn wir auf den finalen Wert `\\"I made it\\"` zugreifen wollen, nutzen wir die `.then()` Methode an `data`:","`data.then(res => console.log(res))`","Das h\xe4tte `\\"I made it!\\"` ausgegeben."],"id":72,"options":["`\\"I made it!\\"`","`Promise {<resolved>\\"I made it!\\"}`","`Promise {<pending>}`","`undefined`"],"problem":"async function getData() {\\n  return await Promise.resolve(\\"I made it!\\");\\n}\\n\\nconst data = getData();\\nconsole.log(data);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Die `.push()` Methode gibt die _L\xe4nge_ des Arrays aus! Das Array beinhaltete zuerst ein einziges Element (`\\"banana\\"`) und hatte eine L\xe4nge von `1`. Nachdem wir `\\"apple\\"` hinzugef\xfcgt haben beinhaltet das Array zwei Elemente und hat eine L\xe4nge von `2`. Das wird letztlich von der `addToList` Funktion ausgegeben.","Die `push` Methode ver\xe4ndert das urspr\xfcngliche Array. Wenn wir das _Array_ der Funktion anstelle der _L\xe4nge des Arrays_ ausgeben m\xf6chten, h\xe4tten wir `list` ausgeben m\xfcssen."],"id":73,"options":["`[\'apple\', \'banana\']`","`2`","`true`","`undefined`"],"problem":"function addToList(item, list) {\\n  return list.push(item);\\n}\\n\\nconst result = addToList(\\"apple\\", [\\"banana\\"]);\\nconsole.log(result);\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["`Object.freeze` macht es unm\xf6glich das Objekt zu ver\xe4ndern (hinzuf\xfcgen, entfernen, ver\xe4ndern), es sei denn der Wert ist ein weiteres Objekt.","Wenn wir die Variable `shape` erstellen und gleich dem eingefrorenen Objekt `box` setzen, ist `shape` ebenso eingefroren. Man kann mit `Object.isFrozen` pr\xfcfen, ob ein Objekt eingefroren ist.\\nIn unserem Fall gibt `Object.isFrozen(shape)` `true` zur\xfcck, da die Variable `shape` eine Referenz zu einem eingefrorenen Objekt ist.","Da `shape` eingefroren ist und der Wert von `x` kein Objekt ist, k\xf6nnen wir den Wert von `x` nicht ver\xe4ndern. `x` ist immernoch gleich `10` und `{ x: 10, y: 20 }` wird geloggt."],"id":74,"options":["`{ x100, y20 }`","`{ x10, y20 }`","`{ x100 }`","`ReferenceError`"],"problem":"const box = { x: 10, y: 20 };\\n\\nObject.freeze(box);\\n\\nconst shape = box;\\nshape.x = 100;\\n\\nconsole.log(shape);\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Wenn wir die Property `name` aus dem Objekt auf der rechten Seite destructuren, weisen wir den Wert einer neuen Variable `myName` zu.","Mit `{ name: myName }` sagen wir JavaScript, dass wir eine neue Variable mit dem Namen `myName` erstellen m\xf6chten und den Wert von `name` zuweisen.","Da `name` nicht definiert ist, wird ein ReferenceError ausgeworfen."],"id":75,"options":["`\\"Lydia\\"`","`\\"myName\\"`","`undefined`","`ReferenceError`"],"problem":"const { name: myName } = { name: \\"Lydia\\" };\\n\\nconsole.log(name);\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Eine pure Funktion ist eine Funktion, die _immer_ das gleiche Ergebnis zur\xfcck gibt, wenn die gleichen Argumente eingegeben werden.","Die `sum` Funktion gibt daher immer das gleiche Ergebnis aus. Wenn wir `1` und `2` eingeben wird _immer_ `3` ausgegeben. Wenn wir `5` und `10` eingeben wird _immer_ `15` ausgegeben usw. Das ist die Definition einer puren Funktion."],"id":76,"options":["Ja","Nein"],"problem":"function sum(a, b) {\\n  return a + b;\\n}\\n","question":"Is this a pure function?"},{"answer":2,"explanation":["Die `add` Funktion ist _memoized_. Mit Memoization k\xf6nnen wir Ergebnisse einer Funktion cachen, um die Performance zu beschleunigen. In diesem Fall erstellen wir ein `cache` Objekt, welches die zuvor ausgegebenen Werte speichert.","Wenn wir die `addFunction` Funktion erneut mit den gleichen Argumenten aufrufen wird zuerst gepr\xfcft, ob der Wert bereits im Cache vorhanden sind. Ist das der Fall, so wird der Cache diesen Wert ausgeben und damit Ausf\xfchrzeit sparen. Wenn der Wert nicht gecached ist wird der neue Wert berechnet und danach im Cache gespeichert.","Wir rufen die `addFunction` Funktion drei mal mit dem gleichen Wert auf: bei der ersten Ausf\xfchrung. ist der Wert der Funktion `10` nicht im Cache. Die Kondition des if-Statements `num in cache` gibt `false` aus und der else Block wird ausgef\xfchrt: `Calculated! 20` wird geloggt und der Wert des Ergebnisses wird dem Cache Objekt hinzugef\xfcgt. `cache` sieht jetzt wiefolgt aus: `{ 10: 20 }`.","Bei der zweiten Ausf\xfchrung beinhaltet das `cache` Objekt den Wert `10`. Die Kondition des if-Statements `num in cache` gibt `true` aus und `\'From cache! 20\'` wird geloggt.","Beim dritten Mal geben wir `5 * 2` als Argument in die Funktion ein, was `10` ergibt. Das `cache` Objekt beinhaltet den Wert `10` und das if-Statement `num in cache` gibt wieder `true` aus und `\'From cache! 20\'` wird geloggt."],"id":77,"options":["`Calculated! 20` `Calculated! 20` `Calculated! 20`","`Calculated! 20` `From cache! 20` `Calculated! 20`","`Calculated! 20` `From cache! 20` `From cache! 20`","`Calculated! 20` `From cache! 20` `Error`"],"problem":"const add = () => {\\n  const cache = {};\\n  return num => {\\n    if (num in cache) {\\n      return `From cache! ${cache[num]}`;\\n    } else {\\n      const result = num + 10;\\n      cache[num] = result;\\n      return `Calculated! ${result}`;\\n    }\\n  };\\n};\\n\\nconst addFunction = add();\\nconsole.log(addFunction(10));\\nconsole.log(addFunction(10));\\nconsole.log(addFunction(5 * 2));\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Mit einer _for-in_ Schleife k\xf6nnen wir \xfcber **z\xe4hlbare** Properties iterieren. In einem Array sind die z\xe4hlbaren Properties die \\"Keys\\" des Array Elements, sprich deren Indexe. Ein Array k\xf6nnte man also wiefolgt sehen:","`{0: \\"\u2615\\", 1: \\"\ud83d\udcbb\\", 2: \\"\ud83c\udf77\\", 3: \\"\ud83c\udf6b\\"}`","Daher werden die z\xe4hlbaren Properties `0` `1` `2` `3` geloggt.","Mit einer _for-of_ Schleife k\xf6nnen wir \xfcber **wiederholbare** Elemente iterieren. Ein Array ist wiederholbar. Wenn wir also \xfcber das Array iterieren, ist die Variable \\"item\\" gleich dem Element, welches momentan iteriert wird: `\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"` wird geloggt."],"id":78,"options":["`0` `1` `2` `3` und `\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"`","`\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"` und `\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"`","`\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"` und `0` `1` `2` `3`"," `0` `1` `2` `3` und `{0\\"\u2615\\", 1\\"\ud83d\udcbb\\", 2\\"\ud83c\udf77\\", 3\\"\ud83c\udf6b\\"}`"],"problem":"const myLifeSummedUp = [\\"\u2615\\", \\"\ud83d\udcbb\\", \\"\ud83c\udf77\\", \\"\ud83c\udf6b\\"]\\n\\nfor (let item in myLifeSummedUp) {\\n  console.log(item)\\n}\\n\\nfor (let item of myLifeSummedUp) {\\n  console.log(item)\\n}\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Array Elemente k\xf6nnen jeden Wert halten: Nummern, Strings, Objekte, andere Arrays, null, Booleans, undefined und andere Expressions wie Funktionen, Berechnungen oder ein Datum.","Das Element ist gleich dem ausgegebenen Wert. `1 + 2` ergibt `3`, `1 * 2` ergibt `2`, und `1 / 2` ergibt `0.5`."],"id":79,"options":["`[\\"1 + 2\\", \\"1 * 2\\", \\"1 / 2\\"]`","`[\\"12\\", 2, 0.5]`","`[3, 2, 0.5]`"," `[1, 1, 1]`"],"problem":"const list = [1 + 2, 1 * 2, 1 / 2]\\nconsole.log(list)\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Standardm\xe4\xdfig haben Argumente den Wert `undefined`, es sei denn der Funktion wurde ein Wert zugewiesen. In diesem Fall haben wir dem `name` Argument keinen Wert zugewiesen, weshalb `name` `undefined` ist.","In ES6 k\xf6nnen wir diesen Standardwert `undefined` mit Standard Parametern \xfcberschreiben, zum Beispiel:","`function sayHi(name = \\"Lydia\\") { ... }`","In diesem Fall, falls wir kein Argument oder `undefined` eingeben ist `name` immer `Lydia`."],"id":80,"options":["`Hi there, `","`Hi there, undefined`","`Hi there, null`"," `ReferenceError`"],"problem":"function sayHi(name) {\\n  return `Hi there, ${name}`\\n}\\n\\nconsole.log(sayHi())\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Der Wert des `this` Keywords h\xe4ngt davon ab, wo es verwendet wird. In einer **Methode**, wie `getStatus` bezieht sich das `this` Keyword auf das _Objekt, zu dem die Methode geh\xf6rt_. Die Methode geh\xf6rt zum `data` Objekt, sodass `this` sich auf das `data` Objekt bezieht. Wenn wir `this.status` loggen wird die `status` Property des `data` Objekts geloggt, was `\\"\ud83e\udd51\\"` ist.","Mit der `call` Methode k\xf6nnen wir das Objekt, auf welches sich das `this` Keyword bezieht \xe4ndern. In **Funktionen** bezieht sich `this` auf das _Objekt, zu dem die Funktion geh\xf6rt_. Wir erkl\xe4ren die `setTimeout` Funktion im _globalen Objekt_, sodass sich `this` in `setTimeout` auf das _globale Objekt_ bezieht. Im globalen Objekt gibt es _status_ mit dem Wert `\\"\ud83d\ude0e\\"`, was geloggt wird."],"id":81,"options":["`\\"\ud83e\udd51\\"` und `\\"\ud83d\ude0d\\"`","`\\"\ud83e\udd51\\"` und `\\"\ud83d\ude0e\\"`","`\\"\ud83d\ude0d\\"` und `\\"\ud83d\ude0e\\"`","`\\"\ud83d\ude0e\\"` und `\\"\ud83d\ude0e\\"`"],"problem":"var status = \\"\ud83d\ude0e\\"\\n\\nsetTimeout(() => {\\n  const status = \\"\ud83d\ude0d\\"\\n\\n  const data = {\\n    status: \\"\ud83e\udd51\\",\\n    getStatus() {\\n      return this.status\\n    }\\n  }\\n\\n  console.log(data.getStatus())\\n  console.log(data.getStatus.call(this))\\n}, 0)\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Wir setzen die Variable `city` gleich dem Wert der Property `city` am `person` Objekt. Da am `person` Objekt keine Property namens `city` existiert wird der Wert gleich `undefined` gesetzt.","Da wir _nicht_ das `person` Objekt selbst referenzieren, sondern einfach die Variable `city` gleich dem aktuellen Wert von `city` am `person` Objekt setzen bleibt dieses `undefined`.","Dann setzen wir `city` gleich dem String `\\"Amsterdam\\"`. Das ver\xe4ndert aber nicht das `person` Objekt, da es keine Referenz dazu am Objekt gibt.","Wenn wir `person` loggen bekommen wir daher das unver\xe4nderte Objekt angezeigt."],"id":82,"options":["`{ name\\"Lydia\\", age21 }`","`{ name\\"Lydia\\", age21, city\\"Amsterdam\\" }`","`{ name\\"Lydia\\", age21, cityundefined }`","`\\"Amsterdam\\"`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n}\\n\\nlet city = person.city\\ncity = \\"Amsterdam\\"\\n\\nconsole.log(person)\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Variablen mit dem `const` und `let` Keyword sind _block-scoped_. Ein Block ist alles zwischen geschweiften Klammern (`{ }`), in diesem Fall die geschweiften Klammern des if/else Statements. Es ist nicht m\xf6glich eine solche Variable au\xdferhalb des Blocks in dem sie erkl\xe4rt wurde aufzurufen, daher wird ein ReferenceError ausgegeben."],"id":83,"options":["`\\"Sorry, you\'re too young.\\"`","`\\"Yay! You\'re old enough!\\"`","`ReferenceError`","`undefined`"],"problem":"function checkAge(age) {\\n  if (age < 18) {\\n    const message = \\"Sorry, you\'re too young.\\"\\n  } else {\\n    const message = \\"Yay! You\'re old enough!\\"\\n  }\\n\\n  return message\\n}\\n\\nconsole.log(checkAge(21))\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Der Wert von `res` im zweiten `.then` ist gleich dem ausgegebenen Wert des vorhergehenden `.then`. Man kann soviele `.then`s aneinander reihen, wie man m\xf6chte und der Wert wird immer an den n\xe4chsten Handler \xfcbergeben."],"id":84,"options":["Das Ergebnis der `fetch` Methode.","Das Ergebnis des zweiten Aufrufs der `fetch` Methode.","Das Ergebnis des Callbacks im vorhergehenden `.then()`.","Immer `undefined`."],"problem":"fetch(\'https://www.website.com/api/user/1\')\\n  .then(res => res.json())\\n  .then(res => console.log(res))\\n","question":"Welche Information wird geloggt?"},{"answer":0,"explanation":["Mit `!!name` k\xf6nnen wir feststellen, ob `name` truthy oder falsey ist. Ist `name` truthy, so w\xfcrde `!name` `false` ausgeben. `!false` (das Gleiche wie `!!name`) ergibt `true`.","Wenn wir `hasName` gleich `name` setzen, so beinhaltet `hasName` den Wert von `name`, nicht den Boolean Wert `true`.","`new Boolean(true)` gibt einen Objekt Wrapper aus, nicht ein Boolean ansich.","`name.length` gibt die L\xe4nge des Arguments aus, nicht den Boolean Wert.\\n</p>\\n</details>"],"id":85,"options":["`!!name`","`name`","`new Boolean(name)`","`name.length`"],"problem":"function getName(name) {\\n  const hasName = //\\n}\\n","question":"Wie k\xf6nnen wir `hasName` gleich `true` setzen, vorausgesetzt wir k\xf6nnen `true` nicht als Argument \xfcbergeben?"},{"answer":1,"explanation":["Um ein Zeichen an einer bestimmten Stelle eines Strings zu bekommen kann man Bracket Notation verwenden. Das erste Zeichen in einem String hat den Index 0, usw. In diesem Fall m\xf6chten wir das Zeichen mit dem Index 0, was das Zeichen `\\"I\\"` loggt.","Diese Methode funktioniert nicht in IE7 und davor. Hier muss `.charAt()` verwendet werden."],"id":86,"options":["`\\"\\"\\"`","`\\"I\\"`","`SyntaxError`","`undefined`"],"problem":"console.log(\\"I want pizza\\"[0])\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Man kann den Wert eines Standard Parameters gleich einem anderen Parameter in der Funktion setzen, sofern diese _vor_ dem Standard Parameter definiert wurden. Wir \xfcbergeben den Wert `10` an die `sum` Funktion. Wenn die `sum` Funktion nur ein Argument \xfcbergeben bekommt bedeutet das, dass der Wert f\xfcr `num2` nicht gesetzt wurde und der Wert von `num1` ist gleich dem Wert `10`. Der Standardwert von `num2` ist gleich dem Wert von `num1`, sprich `10`. `num1 + num2` gibt `20` aus.","Wenn man den Wert des Standard Paramenters gleich dem Parameter setztm der _danach_ definiert wurde, bekommen wir einen Fehler ausgegeben, da der Wert noch nicht initialisiert wurde."],"id":87,"options":["`NaN`","`20`","`ReferenceError`","`undefined`"],"problem":"function sum(num1, num2 = num1) {\\n  console.log(num1 + num2)\\n}\\n\\nsum(10)\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Mit `import * as name` importieren wir _alle Exporte_ der `module.js` in `index.js` als `data`. In der Datei `module.js` haben wir zwei Exporte: den Standard Export und einen benannten Export. Der Standard Export ist eine Funktion, die `\\"Hello World\\"` ausgibt und der benannte Export ist eine Variable namens `name` mit dem Wert `\\"Lydia\\"`.","Das `data` Objekt hat eine Standard Property f\xfcr alle Standard Exporte, andere Properties haben die Namen des benannten Exports und der entsprechenden Werte."],"id":88,"options":["`{ defaultfunction default(), name\\"Lydia\\" }`","`{ defaultfunction default() }`","`{ default\\"Hello world\\", name\\"Lydia\\" }`","Globales Objekt von `module.js`"],"problem":"// module.js \\nexport default () => \\"Hello world\\"\\nexport const name = \\"Lydia\\"\\n\\n// index.js \\nimport * as data from \\"./module\\"\\n\\nconsole.log(data)\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Klassen sind syntaktischer Zucker f\xfcr Funktionskontruktoren. Das Equivalent der `Person` Klasse als Funktionskonstruktor w\xe4re:","Das Aufrufen eines Funktionskonstruktors mit `new` hat zur Folge, dass eine Instanz von `Person` erstellt wird. `typeof` gibt `\\"object\\"` f\xfcr die instanz aus. `typeof member` gibt `\\"object\\"` aus."],"id":89,"options":["`\\"class\\"`","`\\"function\\"`","`\\"object\\"`","`\\"string\\"`"],"problem":"class Person {\\n  constructor(name) {\\n    this.name = name\\n  }\\n}\\n\\nconst member = new Person(\\"John\\")\\nconsole.log(typeof member)\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Die `.push` Methode gibt die _neue L\xe4nge_ des Arrays aus, nicht die L\xe4nge des Arrays selbst. Wenn wir `newList` gleich `[1, 2, 3].push(4)` setzen, setzen wir `newList` auch gleich der L\xe4nge des Arrays: `4`.","Dann versuchen wir die `.push` Methode auf `newList` anzuwenden. Da `newList` den numerischen Wert `4` beinhaltet k\xf6nnen wir die `.push` Methode nicht anwenden: ein TypeError wird ausgegeben."],"id":90,"options":["`[1, 2, 3, 4, 5]`","`[1, 2, 3, 5]`","`[1, 2, 3, 4]`","`Error`"],"problem":"let newList = [1, 2, 3].push(4)\\n\\nconsole.log(newList.push(5))\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Regul\xe4re Funktionen wie `giveLydiaPizza` haben eine `prototype` Property, die ein Objekt (Prototype Object) mit einem `constructor` ist. Arrow Funktionen dagegen (wie `giveLydiaChocolate`) haben keinen `prototype`. `undefined` wird ausgegeben, wenn wir versuchen den `prototype` mit `giveLydiaChocolate.prototype` aufzurufen."],"id":91,"options":["`{ constructor...}` `{ constructor...}`","`{}` `{ constructor...}`","`{ constructor...}` `{}`","`{ constructor...}` `undefined`"],"problem":"function giveLydiaPizza() {\\n  return \\"Here is pizza!\\"\\n}\\n\\nconst giveLydiaChocolate = () => \\"Here\'s chocolate... now go hit the gym already.\\"\\n\\nconsole.log(giveLydiaPizza.prototype)\\nconsole.log(giveLydiaChocolate.prototype)\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["`Object.entries(person)` gibt ein Array mit verschachtelten Arrays der Keys aus:","`[ [ \'name\', \'Lydia\' ], [ \'age\', 21 ] ]`","Mit der `for-of` Schleife iterieren wir \xfcber jedes Element in dem Array, in diesem Fall die verschachtelten Arrays. Wir k\xf6nnen die verschachtelten Arrays mit `const [x, y]` in der for-of Schleife destrukturieren. `x` ist gleich dem ersten Element, `y` ist gleich dem zweiten Element in dem verschachtelten Array.","Das erste verschachtelte Array ist `[ \\"name\\", \\"Lydia\\" ]`. `x` ist gleich `\\"name\\"` und `y` gleich `\\"Lydia\\"`, was geloggt wird.\\nDas zweite verschachtelte Array ist `[ \\"age\\", 21 ]`. `x` ist gleich `\\"age\\"` und `y` ist gleich `21`, was geloggt wird."],"id":92,"options":["`name` `Lydia` und `age` `21`","`[\\"name\\", \\"Lydia\\"]` und `[\\"age\\", 21]`","`[\\"name\\", \\"age\\"]` und `undefined`","`Error`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n}\\n\\nfor (const [x, y] of Object.entries(person)) {\\n  console.log(x, y)\\n}\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["`...args` ist ein Rest-Parameter. Der Wert des Rest-Parameters ist ein Array mit allen weiteren Argumenten **und kann nur der letzte Parameter sein**! In diesem Beispiel war der Rest-Parameter das zweite Argument, was nicht m\xf6glich ist und daher einen Syntax Error ausgibt.","Dieses Beispiel w\xfcrde funktionieren und `[ \'banana\', \'apple\', \'orange\', \'pear\' ]` ausgeben.\\n</p>\\n</details>"],"id":93,"options":["`[\\"banana\\", \\"apple\\", \\"pear\\", \\"orange\\"]`","`[[\\"banana\\", \\"apple\\"], \\"pear\\", \\"orange\\"]`","`[\\"banana\\", \\"apple\\", [\\"pear\\"], \\"orange\\"]`","`SyntaxError`"],"problem":"function getItems(fruitList, ...args, favoriteFruit) {\\n  return [...fruitList, ...args, favoriteFruit]\\n}\\n\\ngetItems([\\"banana\\", \\"apple\\"], \\"pear\\", \\"orange\\")\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["In JavaScript muss das Semikolon _nicht_ explizit gesetzt werden, allerdings setzt die JavaScript Engine Semikolons nach Statements. Diesen Vorgang nennt man **automatische Semikolonsetzung**. Ein Statement ist zum Beispiel eine Variable oder ein Keyword wie `throw`, `return`, `break`, usw.","In unserem Beispiel haben wir ein `return` Statement gefolgt von einem anderen Wert `a + b` auf der _n\xe4chsten Zeile_. Da es eine neue Zeile ist, wei\xdf JavaScript nicht, dass das der Wert ist, den wir eigentlich ausgeben wollten. Stattdessen wird automatisch ein Semikolon nach `return` gesetzt, was man wiefolgt lesen kann:","Das bedeutet, dass `a + b` nie erreicht wird, da die Funktion auf der Zeile davor mit dem `return` Keyword endet. Wenn wie hier kein Wert ausgegeben wird, gibt die Funktion `undefined` aus.\\nBedenke: Semikolons werden **nicht** automatisch nach `if/else` Statements gesetzt!"],"id":94,"options":["`a is bigger`, `6` und `b is bigger`, `3`","`a is bigger`, `undefined` und `b is bigger`, `undefined`","`undefined` und `undefined`","`SyntaxError`"],"problem":"function nums(a, b) {\\n  if\\n  (a > b)\\n  console.log(\'a is bigger\')\\n  else \\n  console.log(\'b is bigger\')\\n  return \\n  a + b\\n}\\n\\nconsole.log(nums(4, 2))\\nconsole.log(nums(1, 2))\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["Wir k\xf6nnen Klassen gleich anderen Klassen oder Funktions Konstruktoren setzen. In diesem Beispiel setzen wir `Person` gleich `AnotherPerson`. Der Name in diesem Konstruktor ist `Sarah`, sodass die name-Property der neuen `Person` Instanz `member` gleich `\\"Sarah\\"` ist."],"id":95,"options":["`\\"Lydia\\"`","`\\"Sarah\\"`","`Errorcannot redeclare Person`","`SyntaxError`"],"problem":"class Person {\\n  constructor() {\\n    this.name = \\"Lydia\\"\\n  }\\n}\\n\\nPerson = class AnotherPerson {\\n  constructor() {\\n    this.name = \\"Sarah\\"\\n  }\\n}\\n\\nconst member = new Person()\\nconsole.log(member.name)\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Ein Symbol ist nicht _z\xe4hlbar_. Die `Object.keys` Methode gibt alle z\xe4hlbaren Key Properties eines Objekts aus. Das Symbol ist nicht sichtbar, sodass ein leeres Array ausgegeben wird. Wenn wir das gesamte Objekt loggen sind alle Properties sichtbar, auch nicht z\xe4hlbare.","Das ist einer der vielen Vorteile eines Symbols: nebem einem einzigartigen Wert (welcher verhindert, dass versehentlich zwei Objekte gleiche Namen haben, zum Beispiel wenn wir mit verschiedenen Libraries arbeiten) k\xf6nnen Properties von Objekten auf diese Art versteckt werden.\\nBedenke: Man kann die Symbole dennoch mit der `Object.getOwnPropertySymbols()` Methode einsehen."],"id":96,"options":["`{Symbol(\'a\')\'b\'}` und `[\\"{Symbol(\'a\')\\"]`","`{}` und `[]`","`{ a\\"b\\" }` und `[\\"a\\"]`","`{Symbol(\'a\')\'b\'}` und `[]`"],"problem":"const info = {\\n  [Symbol(\'a\')]: \'b\'\\n}\\n\\nconsole.log(info)\\nconsole.log(Object.keys(info))\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Die `getList` Funktion bekommt ein Array als Argument zugewiesen. Zwischen den Klammern der `getList` Funktion wird das Array direkt destrukturiert. Man k\xf6nnte das auch wiefolgt sehen:","`[x, ...y] = [1, 2, 3, 4]`","Mit dem Rest Parameter `...y` packen wir alle \xfcbrigen Argumente in ein Array. Die \xfcbrigen Argumente sind in dem Fall `2`, `3` und `4`. Der Wert von `y` ist ein Array mit den restlichen Parametern. Der Wert von `x` ist gleich `1` sodass `[1, [2, 3, 4]]` geloggt wird.","Die `getUser` Funktion bekommt ein Objekt zugewiesen. Bei Arrow Funktionen m\xfcssen wir keine geschweiften Klammern verwenden, wenn wir nur einen Wert ausgeben. Wenn wir aber ein _Objekt_ von einer Arrow Funktion ausgeben lassen m\xf6chten, so muss dieses zwischen Klammern stehen, ansonsten wird nichts ausgegeben. Die folgende Funktion h\xe4tte ein Objekt ausgegeben:","```const getUser = user => ({ name: user.name, age: user.age })```","Da kein Wert ausgegeben wird, gibt die Funktion `undefined` aus."],"id":97,"options":["`[1, [2, 3, 4]]` und `undefined`","`[1, [2, 3, 4]]` und `{ name\\"Lydia\\", age21 }`","`[1, 2, 3, 4]` und `{ name\\"Lydia\\", age21 }`","`Error` und `{ name\\"Lydia\\", age21 }`"],"problem":"const getList = ([x, ...y]) => [x, y]\\nconst getUser = user => { name: user.name, age: user.age }\\n\\nconst list = [1, 2, 3, 4]\\nconst user = { name: \\"Lydia\\", age: 21 }\\n\\nconsole.log(getList(list))\\nconsole.log(getUser(user))\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Die Variable `name` beinhaltet einen String, welcher logischer Weise keine Funktion ist und daher nicht ausgef\xfchrt werden kann.","TypeErrors werden ausgeworfen, wenn ein Wert einen falschen Typ aufweist. JavaScript hat eine Funktion erwartet, da wir `name` ausf\xfchren. Da es aber ein String war bekommen wir den TypeError: name is not a function!","SyntaxErrors werden ausgeworfen, wenn wir etwas schreiben, was kein g\xfcltiger JavaScript Code ist, zum Beispiel wenn wir uns vertippen und anstatt `return` `retrun` schreiben.","ReferenceErrors werden ausgeworfen, wenn JavaScript eine Referenz zu einem Wert nicht finden kann."],"id":98,"options":["`SyntaxError`","`ReferenceError`","`TypeError`","`undefined`"],"problem":"const name = \\"Lydia\\"\\n\\nconsole.log(name())\\n","question":"Was ist der Output?"},{"answer":1,"explanation":["`[]` ist ein \\"truthy\\" Wert. Mit dem `&&` Operator geben wir den rechten Wert aus, wenn der linke truthy ist. In diesem Fall ist `[]` truthy, wodurch `\\"Im\'` ausgegeben wird.","`\\"\\"` ein ein \\"falsy\\" Wert. Wenn der linke Wert falsy ist wird nichts ausgegeben. In diesem Fall wird `n\'t` _nicht_ ausgegeben."],"id":99,"options":["`possible! You should see a therapist after so much JavaScript lol`","`Impossible! You should see a therapist after so much JavaScript lol`","`possible! You shouldn\'t see a therapist after so much JavaScript lol`","`Impossible! You shouldn\'t see a therapist after so much JavaScript lol`"],"problem":"// \ud83c\udf89\u2728 Das ist unsere 100. Frage! \u2728\ud83c\udf89\\n\\nconst output = `${[] && \'Im\'}possible!\\nYou should${\'\' && `n\'t`} see a therapist after so much JavaScript lol`\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Mit dem `||` Operator geben wir den ersten truthy Operand aus. Wenn alle Werte falsy sind wird der letzte Operand ausgegeben.","`(false || {} || null)`: das leere Objekt `{}` ist truthy. Das ist der erste und einzige truthy Wert und wird daher ausgegeben. `one` ist gleich `{}`.","`(null || false || \\"\\")`: alle Operanden sind falsy. Das bedeutet, dass der letzte Wert `\\"\\"` ausgegeben wird. `two` ist gleich `\\"\\"`.","`([] || 0 || \\"\\")`: das leere Array `[]` ist truthy. Das ist der erste truthy Wert, und wird daher ausgegeben. `three` ist gleich `[]`."],"id":100,"options":["`false` `null` `[]`","`null` `\\"\\"` `true`","`{}` `\\"\\"` `[]`","`null` `null` `true`"],"problem":"const one = (false || {} || null)\\nconst two = (null || false || \\"\\")\\nconst three = ([] || 0 || true)\\n\\nconsole.log(one, two, three)\\n","question":"Was ist der Output?"},{"answer":3,"explanation":["Mit einem Promise sagen wir _Ich m\xf6chte diese Funktion ausf\xfchren, aber ich lege sie erstmal beiseite, weil sie eine Weile braucht. Erst wenn ein bestimmter Wert ausgegeben (oder rejected) wird und der Call Stack leer ist m\xf6chte ich den Wert nutzen._","Wir k\xf6nnen auf den Wert mit `.then()` oder `await` in einer `async` Funktion zugreifen, aber `.then()` und `await` unterscheiden sich in einem bestimmten Punkt.","In `firstFunction` legen wir `myPromise` beiseite, w\xe4hrend die Funktion durchl\xe4uft, aber wir arbeiten anderen Code ab, hier `console.log(\'second\')`. \\nDann wird die Funktion abgeschlossen und der String `I have resolved` wird ausgegeben, nachdem sich der Call Stack geleert hat.","Mit dem `await` Keyword in `secondFunction` wird die Funktion gestoppt bis der Wert ausgegeben wurde, erst dann wird die n\xe4chste Zeile ausgef\xfchrt.","Das bedeutet, dass auf `myPromise` gewartet und dann der Wert `I have resolved` ausgegeben wird und erst dann wird die n\xe4chste Zeile ausgef\xfchrt und `second` wird geloggt."],"id":101,"options":["`I have resolved!`, `second` und `I have resolved!`, `second`","`second`, `I have resolved!` und `second`, `I have resolved!`","`I have resolved!`, `second` und `second`, `I have resolved!`","`second`, `I have resolved!` und `I have resolved!`, `second`"],"problem":"const myPromise = () => Promise.resolve(\'I have resolved!\')\\n\\nfunction firstFunction() {\\n  myPromise().then(res => console.log(res))\\n  console.log(\'second\')\\n}\\n\\nasync function secondFunction() {\\n  console.log(await myPromise())\\n  console.log(\'second\')\\n}\\n","question":"What\'s the value of output?"},{"answer":2,"explanation":["Der `+` Operator wird nicht nur f\xfcr numerische Werte verwendet, wir k\xf6nnen mit ihm ebenso Strings zusammenf\xfcgen. Immer, wenn JavaScript merkt, dass mindestens ein Wert keine Nummer ist, wird ein String erstellt.","Der erste Wert ist `1`, was ein numerischer Wert ist. `1 + 2` ergibt die Zahl `3`.","Der zweite Wert hingegen ist der String `\\"Lydia\\"`. `\\"Lydia\\"` ist ein String und `2` ist eine Nummer: `2` wird in einem String umgewandelt. `\\"Lydia\\"` und `\\"2\\"` werden zusammengesetzt, was den String `\\"Lydia2\\"` ausgibt.","`{ name: \\"Lydia\\" }` ist ein Objekt. Weder eine Nummer, noch ein Objekt sind ein String, aber beide werden zu Strings konvertiert und `\\"[object Object]\\"` wird ausgegeben. `\\"[object Object]\\"` zusammengesetzt mit `\\"2\\"` wird `\\"[object Object]2\\"`."],"id":102,"options":["`3`, `NaN`, `NaN`","`3`, `7`, `NaN`","`3`, `Lydia2`, `[object Object]2`","`\\"12\\"`, `Lydia2`, `[object Object]2`"],"problem":"const set = new Set()\\n\\nset.add(1)\\nset.add(\\"Lydia\\")\\nset.add({ name: \\"Lydia\\" })\\n\\nfor (let item of set) {\\n  console.log(item + 2)\\n}\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Wir k\xf6nnen jeden Wert an `Promise.resolve` \xfcbergeben, es muss nicht unbedingt ein Promise sein. Die Methode selbst gibt ein Promise zur\xfcck, was einen Wert ausgibt. Wenn man eine normale Funktion \xfcbergibt wird das Promise einen normalen Wert ausgeben. Wenn ein Promise \xfcbergeben wird so wird ein Promise gel\xf6st und der Wert des gel\xf6sten Promises ausgegeben.","In diesem Fall haben wir nur die Zahl `5` \xfcbergeben und diese wird genauso ausgegeben: `5`."],"id":103,"options":["`5`","`Promise {<pending>5}`","`Promise {<resolved>5}`","`Error`"],"problem":"Promise.resolve(5)\\n","question":"Was wird ausgegeben?"},{"answer":1,"explanation":["Objekte werden durch eine Referenz \xfcbergeben. Wenn wir Objekte auf strikte Gleichheit (`===`) pr\xfcfen, vergleichen wir nur deren Referenz.","Wir setzen den Standardwert f\xfcr `person2` gleich dem `person` Objekt und \xfcbergeben dem `person` Objekt den Wert von `person1`.","Das bedeutet, dass beide Werte eine Referenz zum gleichen Ort im Speicher aufweisen und daher gleich sind.","Der Code im `else` Statement wird aufgerufen und `They are the same!` wird geloggt."],"id":104,"options":["`Not the same!`","`They are the same!`","`ReferenceError`","`SyntaxError`"],"problem":"function compareMembers(person1, person2 = person) {\\n  if (person1 !== person2) {\\n    console.log(\\"Not the same!\\")\\n  } else {\\n    console.log(\\"They are the same!\\")\\n  }\\n}\\n\\nconst person = { name: \\"Lydia\\" }\\n\\ncompareMembers(person)\\n","question":"Was wird ausgegeben?"},{"answer":3,"explanation":["In JavaScript gibt es zwei Wege auf Properties an Objekten zuzugreifen: Punkt-Notation oder Klammern-Notation. In diesem Beispiel nutzen wir Punkt-Notation (`colorConfig.colors`) anstelle von Klammern-Notation (`colorConfig[\\"colors\\"]`).","Mit Punkt-Notation versucht JavaScript die Property am Objekt mit diesem exakten Namen zu finden. In unserem Beispiel `colors` im `colorConfig` Objekt. Da es keine Property `colorConfig` gibt wird `undefined` ausgegeben. Dann versuchen wir den Wert des ersten Elements mit `[1]` aufzurufen, was an `undefined` nicht m\xf6glich ist, wodurch wir `TypeError: Cannot read property \'1\' of undefined` ausgegeben bekommen.","JavaScript interpretiert Statements. Wenn wir Klammern-Notation verwenden wird die erste Klammer `[` gefunden und JavaScript sucht solange, bis eine schlie\xdfende Klammer `]` gefunden wird. Erst dann wird das Statement interpretiert. H\xe4tten wir `colorConfig[colors[1]]` verwendet, w\xe4re der Wert `red` ausgegeben worden."],"id":105,"options":["`true`","`false`","`undefined`","`TypeError`"],"problem":"const colorConfig = {\\n  red: true,\\n  blue: false,\\n  green: true,\\n  black: true,\\n  yellow: false,\\n}\\n\\nconst colors = [\\"pink\\", \\"red\\", \\"blue\\"]\\n\\nconsole.log(colorConfig.colors[1])\\n","question":"Was wird ausgegeben?"},{"answer":0,"explanation":["Emojis sind im Endeffekt nur Unicodes. Der Unicode f\xfcr das Herz Emoji ist `\\"U+2764 U+FE0F\\"`. Dieser ist immer gleich, f\xfcr das selbe Emoji und daher wird `true` ausgegeben."],"id":106,"options":["`true`","`false`"],"problem":"console.log(\'\u2764\ufe0f\' === \'\u2764\ufe0f\')\\n","question":"Was wird ausgegeben?"},{"answer":3,"explanation":["Mit der `splice` Methode \xe4ndern wir das urspr\xfcngliche Array durch l\xf6schen, ersetzen oder erg\xe4nzen von Elementen. In diesem Fall haben wir 2 Elemente vom Index 1 (`\'\ud83e\udd51\'` und `\'\ud83d\ude0d\'`) entfernt und \u2728 stattdessen eingef\xfcgt.","`map`, `filter` und `slice` geben ein neues Array aus, `find` gibt ein Element aus und `reduce` gibt einen neuen Wert aus."],"id":107,"options":["`All of them`","`map` `reduce` `slice` `splice`","`map` `slice` `splice`","`splice`"],"problem":"const emojis = [\'\u2728\', \'\ud83e\udd51\', \'\ud83d\ude0d\']\\n\\nemojis.map(x => x + \'\u2728\')\\nemojis.filter(x => x !== \'\ud83e\udd51\')\\nemojis.find(x => x !== \'\ud83e\udd51\')\\nemojis.reduce((acc, cur) => acc + \'\u2728\')\\nemojis.slice(1, 2, \'\u2728\') \\nemojis.splice(1, 2, \'\u2728\')\\n","question":"Welche Methode ver\xe4ndert das urspr\xfcngliche Array?"},{"answer":0,"explanation":["In JavaScript interagieren primitive Datentypen (alles au\xdfer Objekte) anhand des _Wertes_. In diesem Beispiel setzen wir den Wert von `favoriteFood` am `info` Objekt gleich dem Wert des ersten Elements im `food` Array, in dem Fall ein String mit dem Pizza Emoji (`\'\ud83c\udf55\'`). Ein String ist ein primitiver Datentyp und agiert daher in JavaScript nach Referenz. (Siehe mein [Blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) f\xfcr mehr Informationen)","Dann \xe4ndern wir den Wert von `favoriteFood` am `info` Objekt. Das `food` Array hat sich nicht ver\xe4ndert, da der Wert von `favoriteFood` nur eine _Kopie_ des Wertes des ersten Elements im Array war und keine Referenz zum Element `food[0]` im Speicher finden kann. Wenn wir also das Essen loggen ist es immernoch das urspr\xfcngliche Array `[\'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`."],"id":108,"options":["`[\'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`","`[\'\ud83c\udf5d\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`","`[\'\ud83c\udf5d\', \'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`","`ReferenceError`"],"problem":"const food = [\'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']\\nconst info = { favoriteFood: food[0] }\\n\\ninfo.favoriteFood = \'\ud83c\udf5d\'\\n\\nconsole.log(food)\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Mit der `JSON.parse()` Methode k\xf6nnen wir einen JSON String zu einem JavaScript Wert umwandeln."],"id":109,"options":["Parsed JSON in einen JavaScript Wert","Parsed ein JavaScript Objekt zu JSON","Parsed jegliche JavaScript Werte zu JSON","Parsed JSON zu jeglichem JavaScript Objekt"],"problem":"JSON.parse()\\n","question":"Was macht diese Methode?"},{"answer":3,"explanation":["Jede Funktion hat ihren eigenen _Ausf\xfchrungskontext_ (oder _scope_). Die `getName` Funktion sucht zuerst in ihrem eigenen Kontext (scope) um zu sehen, ob sie den Wert `name` finden kann. In diesem Fall beinhaltet die `getName` Funktion ihre eigene Variable `name`: wir setzen die Variable `name` mit dem `let` Keyword und dem Wert `\'Sarah\'`.","Variablen mit dem `let` und `const` Keyword werden gehoisted, aber entgegen `var` werden diese nicht _initialisiert_. Sie sind nicht aufrufbar, bevor wir sie deklarieren (initialisieren). Das ist eine \\"vor\xfcbergehende tote Zone\\" (temporal dead zone). Wir bekommen einen `ReferenceError` ausgegeben.","H\xe4tten wir die `name` Variable nicht innerhalb `getName` deklariert, so h\xe4tte JavaScript au\xdferhalb der Funktion in der _Scope-Kette_ weitergesucht. Der \xe4u\xdfere Scope beinhaltet ebenfalls eine Variable `name` mit dem Wert `\'Lydia\'`. In diesem Fall w\xe4re `Lydia` geloggt worden."],"id":110,"options":["Lydia","Sarah","`undefined`","`ReferenceError`"],"problem":"let name = \'Lydia\'\\n\\nfunction getName() {\\n  console.log(name)\\n  let name = \'Sarah\'\\n}\\n\\ngetName()\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Mit dem `yield` Keyword, halten wir Werte in einer Generator-Funktion. Mit dem `yield*` Keyword k\xf6nnen wir Werte einer anderen Generator-Funktion oder Objekte und Arrays halten.","In `generatorOne` halten wir das gesamte Array `[\'a\', \'b\', \'c\']` mit dem `yield` Keyword. Der Wert von `value` am Objekt gibt die `next` Methode an `one` (`one.next().value`) aus, was dem gesamten Array entspricht: `[\'a\', \'b\', \'c\']`.","In `generatorTwo` verwenden wir das `yield*` Keyword. Das bedeutet, dass der erste gehaltene Wert von `two` gleich dem ersten gehaltenen Wert ist. Das ist das Array `[\'a\', \'b\', \'c\']`. Der erste gehaltene Wert ist `a`, was ausgegeben wird."],"id":111,"options":["`a` and `a`","`a` and `undefined`","`[\'a\', \'b\', \'c\']` and `a`","`a` and `[\'a\', \'b\', \'c\']`"],"problem":"function* generatorOne() {\\n  yield [\'a\', \'b\', \'c\'];\\n}\\n\\nfunction* generatorTwo() {\\n  yield* [\'a\', \'b\', \'c\'];\\n}\\n\\nconst one = generatorOne()\\nconst two = generatorTwo()\\n\\nconsole.log(one.next().value)\\nconsole.log(two.next().value)\\n","question":"Was ist der Output?"},{"answer":0,"explanation":["Expressions innerhalb von Template Literals werden zuerst berechnet. Das bedeutet, dass der String den ausgegebenen Wert der Expression beinhaltet, hier die IIFE (immediately invoked Function) `(x => x)(\'I love\')`. Wir geben den Wert `\'I love\'` als Argument an die `x => x` Arrow Funktion. `x` ist gleich `\'I love\'` und wird ausgegeben. Das Ergebnis ist `I love to program`."],"id":112,"options":["`I love to program`","`undefined to program`","`${(x => x)(\'I love\') to program`","`TypeError`"],"problem":"console.log(`${(x => x)(\'I love\')} to program`)\\n","question":"Was ist der Output?"},{"answer":2,"explanation":["Wenn wir normalerweise Objekte gleich `null` setzen, werden diese _verworfen_, weil keine Referenz mehr zu ihnen existiert. Da die Callback Funktion in `setInterval` eine Arrow Funktion (und daher an `config` gebunden) ist, h\xe4lt die Callback Funktion immernoch eine Referenz zum `config` Objekt. Solange eine Referenz besteht, wird das Objekt nicht verworfen und die `setInterval` Funktion wird weiterhin alle 1000ms (1 Sekunde) aufgerufen."],"id":113,"options":["Die `setInterval` Callback Funktion wird nicht aufgerufen","Die `setInterval` Callback Funktion wird ein Mal aufgerufen","Die `setInterval` Callback Funktion wird weiterhin jede Sekunde aufgerufen","Wir haben `config.alert()` nie aufgerufen, `config` ist `null`"],"problem":"let config = {\\n  alert: setInterval(() => {\\n    console.log(\'Alert!)\\n  }, 1000)\\n}\\n\\nconfig = null\\n","question":"What will happen?"},{"answer":1,"explanation":["Beim Setzen eines Key/Wert Paars mit der `set` Methode wird der Key als erstes Argument an die `set` Funktion \xfcbergeben und der Wert wird als zweites Argument eingegeben. Der Key ist die _Funktion_ `() => \'greeting\'` und der Wert ist `\'Hello world\'`. `myMap` ist jetzt `{ () => \'greeting\' => \'Hello world!\' }`.","1 ist falsch, weil der Key nicht `\'greeting\'`, sondern `() => \'greeting\'` ist.\\n3 ist falsch, weil wir eine neue Funktion erstellen, indem wir sie als Argument \xfcbergeben. Objekte interagieren anhand von _Referenzen_. Funktionen sind Objekte, weshalb zwei Funktionen streng gesehen nie gleich sind, selbst wenn sie sich nicht unterscheiden."],"id":114,"options":["1","2","2 und 3","Alle"],"problem":"const myMap = new Map()\\nconst myFunc = () => \'greeting\'\\n\\nmyMap.set(myFunc, \'Hello world!\')\\n\\n//1\\nmyMap.get(\'greeting\')\\n//2\\nmyMap.get(myFunc)\\n//3\\nmyMap.get(() => \'greeting\'))\\n","question":"Welche Methode(n) geben den Wert `\'Hello world!\'` aus?"},{"answer":2,"explanation":["Beide Funktionen, `changeAge` und `changeAgeAndName`, haben Standard Parameter, n\xe4mlich ein neu erstelltes Objekt `{ ...person }`. Dieses Objekt hat Kopien aller Key/Werte Paare im `person` Objekt.","Zuerst f\xfchren wir die `changeAge` Funktion aus und \xfcbergeben ihr das `person` Objekt als Argument. Daher wird `age` um 1 erh\xf6ht. `person` ist jetzt `{ name: \\"Lydia\\", age: 22 }`.","Dann f\xfchren wir `changeAgeAndName` aus, allerdings ohne Parameter. Stattdessen ist der Wert von `x` gleich dem neuen Objekt `{ ...person }`. Da dies ein neues Objekt ist hat es keinen Einfluss auf die Werte des `person` Objekts. `person` ist immernoch gleich `{ name: \\"Lydia\\", age: 22 }`."],"id":115,"options":["`{name\\"Sarah\\", age22}`","`{name\\"Sarah\\", age23}`","`{name\\"Lydia\\", age22}`","`{name\\"Lydia\\", age23}`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n}\\n\\nconst changeAge = (x = { ...person }) => x.age += 1\\nconst changeAgeAndName = (x = { ...person }) => {\\n  x.age += 1\\n  x.name = \\"Sarah\\"\\n}\\n\\nchangeAge(person)\\nchangeAgeAndName()\\n\\nconsole.log(person)\\n","question":"Was ist der Output?"}]')}}]);
//# sourceMappingURL=36.a8bc5328.chunk.js.map