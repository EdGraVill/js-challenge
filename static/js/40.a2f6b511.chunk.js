(this["webpackJsonpjs-challenge"]=this["webpackJsonpjs-challenge"]||[]).push([[40],{115:function(e){e.exports=JSON.parse('[{"answer":3,"explanation":["Dans la fonction, nous d\xe9clarons en premier la variable `name` gr\xe2ce au mot cl\xe9 `var`. Cela signifie que la variable est \\"lev\xe9e\\" _(hoisted)_ (l\'espace m\xe9moire est d\xe9finie \xe0 la phase de cr\xe9ation) avec pour valeur par d\xe9faut `undefined`, jusqu\'\xe0 ce que le script atteigne la ligne de d\xe9finition de la variable. Nous n\'avons pas encore d\xe9fini la variable lorsque nous essayons d\'afficher la variable `name`, donc elle a toujours la valeur `undefined`.","Les variables avec le mot cl\xe9 `let` (et `const`) sont \\"lev\xe9es\\" _(hoisted)_, mais contrairement \xe0 `var`, elle n\'est pas <i>initialis\xe9e</i>. Elles ne sont pas accessible avant la ligne qui les d\xe9clare (initialise). C\'est appel\xe9 la \\"zone morte temporaire\\". Lorsque nous essayons d\'acc\xe9der aux variables avant leur d\xe9claration, JavaScript renvoie une `ReferenceError`."],"id":0,"options":["`Lydia` et `undefined`","`Lydia` et `ReferenceError`","`ReferenceError` et `21`","`undefined` et `ReferenceError`"],"problem":"function sayHi() {\\n  console.log(name);\\n  console.log(age);\\n  var name = \\"Lydia\\";\\n  let age = 21;\\n}\\n\\nsayHi();\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["\xc0 cause du syst\xe8me de queue dans JavaScript, la fonction de rappel _(callback)_ du `setTimeout` est appel\xe9e _apr\xe8s_ que la boucle soit ex\xe9cut\xe9e. Comme la variable `i` dans la premi\xe8re boucle est d\xe9clar\xe9e avec le mot-cl\xe9 `var`, c\'est une variable globale. Pendant la boucle, nous incr\xe9mentons la valeur de `i` de `1` \xe0 chaque fois, en utilisant l\'op\xe9rateur arithm\xe9tique `++`. Lorsque la fonction de rappel _(callback)_ du `setTimeout` est invoqu\xe9e, `i` est \xe9gal \xe0 `3` dans le premier exemple.","Dans la seconde boucle, la variable `i` est d\xe9clar\xe9e avec le mot cl\xe9 `let` : les variables d\xe9clar\xe9es avec `let` (et `const`) ont une port\xe9e de bloc (tout ce qui est entre `{ }` est consid\xe9r\xe9 comme un bloc). Pendant chaque it\xe9ration, `i` aura une nouvelle valeur, et chaque valeur sera d\xe9finie dans la boucle."],"id":1,"options":["`0 1 2` et `0 1 2`","`0 1 2` et `3 3 3`","`3 3 3` et `0 1 2`"],"problem":"for (var i = 0; i < 3; i++) {\\n  setTimeout(() => console.log(i), 1);\\n}\\n\\nfor (let i = 0; i < 3; i++) {\\n  setTimeout(() => console.log(i), 1);\\n}\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Notez que la valeur de `diameter` est une fonction r\xe9guli\xe8re, alors que celle de `perimeter` est une fonction fl\xe9ch\xe9e.","Avec les fonctions fl\xe9ch\xe9e, le mot cl\xe9 `this` r\xe9f\xe8re \xe0 son p\xe9rim\xe8tre actuel, contrairement aux fonctions r\xe9guli\xe8res ! Cela signifie que lorsque nous appelons `perimeter`, elle ne r\xe9f\xe8re pas \xe0 l\'objet `shape`, mais \xe0 son p\xe9rim\xe8tre actuel (`window` par exemple).","Il n\'y a pas de valeur `radius` dans cet objet, on retournera `undefined`."],"id":2,"options":["`20` et `62.83185307179586`","`20` et `NaN`","`20` et `63`","`NaN` et `63`"],"problem":"const shape = {\\n  radius: 10,\\n  diameter() {\\n    return this.radius * 2;\\n  },\\n  perimeter: () => 2 * Math.PI * this.radius\\n};\\n\\nshape.diameter();\\nshape.perimeter();\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["L\'op\xe9rateur arithm\xe9tique `+` essait de convertir un op\xe9rande en une valeur num\xe9rique. `true` devient `1`, et `false` devient `0`.","La cha\xeene de caract\xe8re `\'Lydia\'` est une valeur consid\xe9r\xe9e comme vraie _(truthy)_. Ce que nous sommes actuellement en train de demander, c\'est \\"est-ce que cette valeur consid\xe9r\xe9e comme vraie est fausse ?\\". Ce qui retournera `false`."],"id":3,"options":["`1` et `false`","`false` et `NaN`","`false` et `false`"],"problem":"+true;\\n!\\"Lydia\\";\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["En JavaScript, toutes les cl\xe9s d\'objet sont des cha\xeenes de caract\xe8res (sauf si c\'est un Symbol). Bien que nous ne puissions pas les _typer_ comme des cha\xeenes de caract\xe8res, elles sont converties en cha\xeenes de caract\xe8res sous le capot.","JavaScript interpr\xe8te (ou d\xe9compresse) les instructions. Lorsque nous utilisons la notation pas crochet, il voit le premier crochet `[` et continue jusqu\'\xe0 ce qu\'il trouve le crochet fermant `]`. Seulement apr\xe8s, il \xe9value l\'instruction.","`mouse[bird.size]` : Premi\xe8rement, il \xe9value `bird.size`, qui est `\\"small\\"`. `mouse[\\"small\\"]` retourne `true`.","Cependant, avec la notation par points, cela n\'arrive pas. `mouse` n\'a pas de cl\xe9 appel\xe9e `bird`, ce qui signifie que `mouse.bird` est `undefined`. Puis, on demande `size` en utilisant la notation par point : `mouse.bird.size`. Comme `mouse.bird` est `undefined`, on demande `undefined.size`. Cela n\'est pas valide, et nous aurons une erreur similaire \xe0 `Impossible de lire la propri\xe9t\xe9 \\"size\\" de undefined`."],"id":4,"options":["`mouse.bird.size` n\'est pas valide","`mouse[bird.size]` n\'est pas valide","`mouse[bird[\\"size\\"]]` n\'est pas valide","Toutes sont valides"],"problem":"const bird = {\\n  size: \\"small\\"\\n};\\n\\nconst mouse = {\\n  name: \\"Mickey\\",\\n  small: true\\n};\\n","question":"Laquelle est vraie ?"},{"answer":0,"explanation":["En JavaScript, tous les objets interagissent par _r\xe9f\xe9rence_ lorsqu\'on les d\xe9finit \xe9gaux les uns aux autres.","Premi\xe8rement, la variable `c` contaient une valeur d\'objet. Plus tard, nous assignons `d` avec la m\xeame r\xe9f\xe9rence que `c` \xe0 l\'objet.","<img src=\\"https://i.imgur.com/ko5k0fs.png\\" width=\\"200\\">","Quand on modifie un objet, on les modifie donc tous."],"id":5,"options":["`Hello`","`Hey`","`undefined`","`ReferenceError`","`TypeError`"],"problem":"let c = { greeting: \\"Hey!\\" };\\nlet d;\\n\\nd = c;\\nc.greeting = \\"Hello\\";\\nconsole.log(d.greeting);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["`new Number()` est une fonction globale. Bien qu\'il ressemble \xe0 un nombre, ce n\'en est pas vraiment un : il a une poign\xe9e de fonctionnalit\xe9s suppl\xe9mentaire et est un objet.","Quand nous utilisons l\'op\xe9rateur `==`, il v\xe9rifie seulement qu\'il s\'agisse de la m\xeame _valeur_. Les deux ont pour valeur `3`, donc il retourne `true`.","Cependant, quand on utilise l\'op\xe9rateur `===`, les 2 valeurs _et_ types doivent \xeatre les m\xeames. `new Number()` n\'est pas un nombre, c\'est un **objet**, il retourne `false`."],"id":6,"options":["`true` `false` `true`","`false` `false` `true`","`true` `false` `false`","`false` `true` `true`"],"problem":"let a = 3;\\nlet b = new Number(3);\\nlet c = 3;\\n\\nconsole.log(a == b);\\nconsole.log(a === b);\\nconsole.log(b === c);\\n","question":"Quelle est la sortie ?"},{"answer":3,"explanation":["La fonction `colorChange` est statique. Les m\xe9thodes statiques sont d\xe9sign\xe9es pour vivre seulement dans le constructeur qui les a cr\xe9\xe9 et ne peuvent pas \xeatre transf\xe9rer aux enfants. Comme `freddie` est un enfant, la fonction n\'est pas transf\xe9r\xe9e et n\'est pas disponible dans l\'instance de `freddie` : une erreur `TypeError` est renvoy\xe9e."],"id":7,"options":["`orange`","`purple`","`green`","`TypeError`"],"problem":"class Chameleon {\\n  static colorChange(newColor) {\\n    this.newColor = newColor;\\n    return this.newColor;\\n  }\\n\\n  constructor({ newColor = \\"green\\" } = {}) {\\n    this.newColor = newColor;\\n  }\\n}\\n\\nconst freddie = new Chameleon({ newColor: \\"purple\\" });\\nfreddie.colorChange(\\"orange\\");\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Il affiche l\'objet, car on a juste cr\xe9\xe9 un objet vide dans l\'objet global ! Quand on \xe9crit mal `greeting` en `greetign`, JavaScript l\'interpr\xe8te comme il le voit `global.greetign = {}` (ou `window.greetign = {}` dans le navigateur).","Pour \xe9viter cela, on peut utiliser `\\"use strict\\"`. Cela nous assure de devoir d\xe9clarer la variable avant de lui assigner une valeur."],"id":8,"options":["`{}`","`ReferenceErrorgreetign is not defined`","`undefined`"],"problem":"let greeting;\\ngreetign = {}; // Typo!\\nconsole.log(greetign);\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["C\'est possible en JavaScript, car les fonctions sont des objets ! (Tout ce qui n\'est pas de type primitif est un objet)","Une fonction est un type sp\xe9cial d\'objet. Le code que vous \xe9crivez vous-m\xeame n\'est pas la fonction. La fonction est un objet avec des propri\xe9t\xe9s. Cette propri\xe9t\xe9 est invocable."],"id":9,"options":["Rien, c\'est tout \xe0 fait bon !","`SyntaxError`. Vous ne pouvez pas ajouter de propri\xe9t\xe9s \xe0 une fonction de cette fa\xe7on.","`undefined`","`ReferenceError`"],"problem":"function bark() {\\n  console.log(\\"Woof!\\");\\n}\\n\\nbark.animal = \\"dog\\";\\n","question":"Que se passe-t-il lorsque nous faisons \xe7a ?"},{"answer":0,"explanation":["Vous ne pouvez pas ajouter de propri\xe9t\xe9s \xe0 un constructeur comme pour des objets normaux. Si vous voulez ajouter une fonctionnalit\xe9 pour tous les objets en une fois, vous devez utiliser le prototype. Donc dans ce cas,","rendra fonctionnel `member.getFullName`. Pourquoi est-ce b\xe9n\xe9fique\xa0? Disons que nous ajoutons cette m\xe9thode au constructeur directement. Peut-\xeatre que toutes les instances de `Person` n\'ont pas besoin de cette m\xe9thode. Cela fera perdre de l\'espace m\xe9moire, car elles auront tous cette propri\xe9t\xe9, ce qui prendra de l\'espace m\xe9moire pour chaque instance. Alors que, si nous ajoutons la m\xe9thode au prototype uniquement, nous n\'utilisons qu\'un seul slot m\xe9moire, et ils y auront tous acc\xe8s\xa0!"],"id":10,"options":["`TypeError`","`SyntaxError`","`Lydia Hallie`","`undefined` `undefined`"],"problem":"function Person(firstName, lastName) {\\n  this.firstName = firstName;\\n  this.lastName = lastName;\\n}\\n\\nconst member = new Person(\\"Lydia\\", \\"Hallie\\");\\nPerson.getFullName = function() {\\n  return `${this.firstName} ${this.lastName}`;\\n};\\n\\nconsole.log(member.getFullName());\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Pour `sarah`, nous n\'avons pas utilis\xe9 le mot cl\xe9 `new`. Quand nous utilisons `new`, il fait r\xe9f\xe9rence \xe0 un nouvel objet vide que nous cr\xe9ons. Cependant, nous n\'ajoutons pas `new`. Il r\xe9f\xe8re \xe0 **l\'objet global**\xa0!","Nous disons que `this.firstName` est \xe9gal \xe0 `\\"Sarah\\"` et que `this.lastName` est \xe9gal \xe0 `Smith`. Ce que nous faisons c\'est d\xe9finir `global.firstName = \'Sarah\'` et `global.lastName = \'Smith\'`. La variable `sarah` elle-m\xeame reste \xe0 `undefined`."],"id":11,"options":["`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` et `undefined`","`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` et `Person {firstName\\"Sarah\\", lastName\\"Smith\\"}`","`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` et `{}`","\\"Lydia\\", lastName\\"Hallie\\"}` et `ReferenceError`"],"problem":"function Person(firstName, lastName) {\\n  this.firstName = firstName;\\n  this.lastName = lastName;\\n}\\n\\nconst lydia = new Person(\\"Lydia\\", \\"Hallie\\");\\nconst sarah = Person(\\"Sarah\\", \\"Smith\\");\\n\\nconsole.log(lydia);\\nconsole.log(sarah);\\n","question":"Quelle est la sortie ?"},{"answer":3,"explanation":["Durant la phase de **capture** _(capturing)_, l\'\xe9v\xe9nement passe par les \xe9l\xe9ments parents jusqu\'\xe0 l\'\xe9l\xe9ment cibl\xe9. Il atteint ensuite l\'\xe9l\xe9ment **cibl\xe9** _(target)_, et commence \xe0 **bouillonner** _(bubbling)_.","<img src=\\"https://i.imgur.com/N18oRgd.png\\" width=\\"200\\">"],"id":12,"options":["Target > Capturing > Bubbling","Bubbling > Target > Capturing","Target > Bubbling > Capturing","Capturing > Target > Bubbling"],"problem":"","question":"Quelle sont les trois phases de propagation des \xe9v\xe9nements ?"},{"answer":1,"explanation":["Tous les objets ont des prototypes, except\xe9 pour les **objets standards**. Les objets standards ont acc\xe8s \xe0 certaines m\xe9thodes et propri\xe9t\xe9s, comme `.toString`. C\'est pour cette raison que vous pouvez utiliser les m\xe9thodes natives de JavaScript ! Toutes ces m\xe9thodes sont disponibles dans le prototype. Bien que JavaScript ne trouve pas la fonction dans l\'objet, il parcourt le prototype et la m\xe9thode afin de la rendre accessible."],"id":13,"options":["vrai","faux"],"problem":"","question":"Tous les objets ont des prototypes."},{"answer":2,"explanation":["JavaScript est un **langage \xe0 types dynamiques**\xa0: nous n\'avons pas besoin de sp\xe9cifier le types des variables. Les valeurs peuvent \xeatre automatiquement converties vers les autres types sans que vous le sachiez, c\'est ce que l\'on appelle _la conversion de types implicites_ _(implicit type coercion)_.","Dans cette exemple, JavaScript convertit le nombre `1` en une cha\xeene de caract\xe8re, afin que la fonction ait du sens et puisse renvoyer une valeur. Durant l\'addition d\'un type num\xe9rique (`1`) et d\'un type cha\xeene de caract\xe8re (`\'2\'`), le nombre est trait\xe9 comme une cha\xeene de caract\xe8re. Nous pouvons concat\xe9ner les cha\xeenes de caract\xe8res comme `\\"Hello\\" + \\"World\\"`, c\'est donc ce qui arrive ici avec `\\"1\\" + \\"2\\"` qui retourne `\\"12\\"`."],"id":14,"options":["`NaN`","`TypeError`","`\\"12\\"`","`3`"],"problem":"function sum(a, b) {\\n  return a + b;\\n}\\n\\nsum(1, \\"2\\");\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["L\'op\xe9rateur arithm\xe9tique **postfix** `++` :","Retourne la valeur (ici il retourne `0`)","Incr\xe9mente la valeur (le nombre est maintenant \xe9gal \xe0 `1`)","L\'op\xe9rateur arithm\xe9tique **pr\xe9fix** `++` :","Incr\xe9mente la valeur (le nombre est maintenant \xe9gal \xe0 `2`)","Retourne la valeur (ici il retourne `2`)","Cela retourne donc `0 2 2`."],"id":15,"options":["`1` `1` `2`","`1` `2` `2`","`0` `2` `2`","`0` `1` `2`"],"problem":"let number = 0;\\nconsole.log(number++);\\nconsole.log(++number);\\nconsole.log(number);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Si vous utilisez les litt\xe9raux de gabarits, la valeur du premier argument sera toujours un tableau de valeurs des cha\xeenes de caract\xe8re. Le reste des arguments seront les valeurs des expressions utilis\xe9es !"],"id":16,"options":["`\\"Lydia\\"` `21` `[\\"\\", \\" is \\", \\" years old\\"]`","`[\\"\\", \\" is \\", \\" years old\\"]` `\\"Lydia\\"` `21`","`\\"Lydia\\"` `[\\"\\", \\" is \\", \\" years old\\"]` `21`"],"problem":"function getPersonInfo(one, two, three) {\\n  console.log(one);\\n  console.log(two);\\n  console.log(three);\\n}\\n\\nconst person = \\"Lydia\\";\\nconst age = 21;\\n\\ngetPersonInfo`${person} is ${age} years old`;\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Lorsque l\'on teste une \xe9galit\xe9, les primitifs sont compar\xe9s par leur valeur, alors que les objets sont compar\xe9s par leur _r\xe9f\xe9rence_. JavaScript v\xe9rifie si les objets ont une r\xe9f\xe9rence \xe0 la m\xeame zone de la m\xe9moire.=","Les 2 objets que nous comparons n\'ont pas \xe7a : l\'objet pass\xe9 en param\xe8tre fait r\xe9f\xe9rence \xe0 une zone m\xe9moire diff\xe9rente que l\'objet que nous utilisons pour faire la comparaison.","C\'est pourquoi les 2 conditions `{ age: 18 } === { age: 18 }` et `{ age: 18 } == { age: 18 }` retournent `false`."],"id":17,"options":["`Vous \xeates un adulte !`","`Vous \xeates toujours un adulte.`","`Hmm.. Vous n\'avez pas l\'\xe2ge, je suppose.`"],"problem":"function checkAge(data) {\\n  if (data === { age: 18 }) {\\n    console.log(\\"Vous \xeates un adulte !\\");\\n  } else if (data == { age: 18 }) {\\n    console.log(\\"Vous \xeates toujours un adulte.\\");\\n  } else {\\n    console.log(`Hmm.. Vous n\'avez pas l\'\xe2ge, je suppose.`);\\n  }\\n}\\n\\ncheckAge({ age: 18 });\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["La syntaxe des param\xe8tres du reste _(rest parameters)_ (`...args`) retourne un tableau avec les arguments. Un tableau est un objet, donc `typeof args` retournera `\\"object\\"`."],"id":18,"options":["`\\"number\\"`","`\\"array\\"`","`\\"object\\"`","`\\"NaN\\"`"],"problem":"function getAge(...args) {\\n  console.log(typeof args);\\n}\\n\\ngetAge(21);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Avec `\\"use strict\\"`, vous pouvez \xeates s\xfbr de ne pas d\xe9clarer accidentellement des variables gloables. Nous ne d\xe9clarerons jamais la variable `age`, et temps que nous utiliserons `\\"use strict\\"`, cela cr\xe9era une erreur de r\xe9f\xe9rence. Si nous n\'utilisons pas `\\"use strict\\"`, cela fonctionnera et la variable `age` sera attribu\xe9 \xe0 l\'objet global."],"id":19,"options":["`21`","`undefined`","`ReferenceError`","`TypeError`"],"problem":"function getAge() {\\n  \\"use strict\\";\\n  age = 21;\\n  console.log(age);\\n}\\n\\ngetAge();\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["`eval` \xe9value les codes que nous passons en param\xe8tre de type cha\xeene de caract\xe8res. Si c\'est une expression, comme dans notre cas, il \xe9valuera l\'expression. L\'expression est `10 * 10 + 5`, ce qui retourne le nombre `105`."],"id":20,"options":["`105`","`\\"105\\"`","`TypeError`","`\\"10*10+5\\"`"],"problem":"const sum = eval(\\"10*10+5\\");\\n","question":"Quelle est la valeur de `sum` ?"},{"answer":1,"explanation":["La donn\xe9e stock\xe9e dans le `sessionStorage` est supprim\xe9e apr\xe8s la fermeture de l\'onglet.","Si vous utilisez le `localStorage`, la donn\xe9e sera l\xe0 pour toujours, jusqu\'\xe0 ce que, par exemple, `localStorage.clear()` soit invoqu\xe9e."],"id":21,"options":["Pour toujours, les donn\xe9es ne seront pas perdues.","Jusqu\'\xe0 ce que l\'utilisateur ferme l\'onglet.","Jusqu\'\xe0 ce que l\'utilisateur ferme son navigateur en entier, pas seulement son onglet.","Jusqu\'\xe0 ce que l\'utilisateur \xe9teindra son ordinateur."],"problem":"sessionStorage.setItem(\\"cool_secret\\", 123);\\n","question":"Pendant combien de temps `cool_secret` sera-t-il accessible ?"},{"answer":1,"explanation":["Avec le mot cl\xe9 `var`, vous pouvez d\xe9clarer plusieurs variables avec le m\xeame nom. La variable aura pour valeur la derni\xe8re assign\xe9e.","Vous ne pouvez pas faire cela avec `let` ou `const` puisqu\'ils ont une port\xe9e de bloc."],"id":22,"options":["`8`","`10`","`SyntaxError`","`ReferenceError`"],"problem":"var num = 8;\\nvar num = 10;\\n\\nconsole.log(num);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Toutes les cl\xe9s d\'objet (\xe0 l\'exception des symboles) sont des cha\xeenes de caract\xe8res sous le capot, m\xeame si vous ne les tapez pas vous-m\xeame en tant que cha\xeene. C\'est pourquoi `obj.hasOwnProperty(\\"1\\")` renvoie \xe9galement la valeur `true`.","\xc7a ne marche pas comme \xe7a pour un set. Il n\'y a pas de `\'1\'` dans notre ensemble : `set.has(\'1\')` renvoie `false`. Il a le type num\xe9rique `1`, `set.has(1)` renvoie `true`."],"id":23,"options":["`false` `true` `false` `true`","`false` `true` `true` `true`","`true` `true` `false` `true`","`true` `true` `true` `true`"],"problem":"const obj = { 1: \\"a\\", 2: \\"b\\", 3: \\"c\\" };\\nconst set = new Set([1, 2, 3, 4, 5]);\\n\\nobj.hasOwnProperty(\\"1\\");\\nobj.hasOwnProperty(1);\\nset.has(\\"1\\");\\nset.has(1);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Si vous avez deux cl\xe9s portant le m\xeame nom, la cl\xe9 sera remplac\xe9e. Elle sera toujours dans sa premi\xe8re position, mais avec la derni\xe8re valeur sp\xe9cifi\xe9e."],"id":24,"options":["`{ a\\"un\\", b\\"deux\\" }`","`{ b\\"deux\\", a\\"trois\\" }`","`{ a\\"trois\\", b\\"deux\\" }`","`SyntaxError`"],"problem":"const obj = { a: \\"un\\", b: \\"deux\\", a: \\"trois\\" };\\nconsole.log(obj);\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Le contexte d\'ex\xe9cution de base est le contexte d\'ex\xe9cution global : c\'est ce qui est accessible partout dans votre code."],"id":25,"options":["Vrai","Faux","\xc7a d\xe9pend"],"problem":"","question":"Le contexte global d\'ex\xe9cution de JavaScript cr\xe9e 2 choses pour vous : l\'objet global and le mot-cl\xe9 `this`."},{"answer":2,"explanation":["L\'instruction `continue` ignore une it\xe9ration si une condition donn\xe9e renvoie `true`."],"id":26,"options":["`1` `2`","`1` `2` `3`","`1` `2` `4`","`1` `3` `4`"],"problem":"for (let i = 1; i < 5; i++) {\\n  if (i === 3) continue;\\n  console.log(i);\\n}\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["`String` est un constructeur int\xe9gr\xe9, auquel nous pouvons ajouter des propri\xe9t\xe9s. Je viens d\'ajouter une m\xe9thode \xe0 son prototype. Les cha\xeenes de caract\xe8re primitives sont automatiquement converties en un objet cha\xeene, g\xe9n\xe9r\xe9 par la fonction prototype de cha\xeene. Ainsi, toutes les cha\xeenes (objets de cha\xeene) ont acc\xe8s \xe0 cette m\xe9thode !"],"id":27,"options":["`\\"Just give Lydia pizza already!\\"`","`TypeErrornot a function`","`SyntaxError`","`undefined`"],"problem":"String.prototype.giveLydiaPizza = () => {\\n  return \\"Just give Lydia pizza already!\\";\\n};\\n\\nconst name = \\"Lydia\\";\\n\\nname.giveLydiaPizza();\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Les cl\xe9s d\'objet sont automatiquement converties en cha\xeenes de caract\xe8res. Nous essayons de d\xe9finir un objet en tant que cl\xe9 de l\'objet `a`, avec la valeur `123`.","Cependant, lorsque nous transformons un objet en cha\xeene de caract\xe8re, il devient `\\"[Objet objet]\\"`. Donc, ce que nous disons ici, c\'est que un `a[\\"Objet objet\\"] = 123`. Ensuite, nous pouvons essayer de refaire la m\xeame chose. `c` est un autre objet que nous sommes implicitement en train de transformer en cha\xeene de caract\xe8re. Donc, `a[\\"Objet objet\\"] = 456`.","Ensuite, nous affichons `a[b]`, qui est en fait `a[\\"Objet objet\\"]`. Que nous venons de d\xe9finir \xe0 `456`, nous renvoyons donc `456`."],"id":28,"options":["`123`","`456`","`undefined`","`ReferenceError`"],"problem":"const a = {};\\nconst b = { key: \\"b\\" };\\nconst c = { key: \\"c\\" };\\n\\na[b] = 123;\\na[c] = 456;\\n\\nconsole.log(a[b]);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Nous avons une fonction `setTimeout` et nous l\'avons d\'abord appel\xe9e. Pourtant, il a \xe9t\xe9 affich\xe9 en dernier.","En effet, dans les navigateurs, nous n\u2019avons pas seulement le moteur d\u2019ex\xe9cution, nous avons aussi quelque chose appel\xe9 `WebAPI`. `WebAPI` nous donne la fonction` setTimeout` pour commencer, et par exemple le DOM.","Une fois que la fonction de rappel _(callback)_ est pouss\xe9e via la WebAPI, la fonction `setTimeout` elle-m\xeame (mais pas la fonction de rappel !) est extraite de la pile.","<img src=\\"https://i.imgur.com/X5wsHOg.png\\" width=\\"200\\">","Maintenant, `foo` est invoqu\xe9 et `\\"Premier\\"` est affich\xe9.","<img src=\\"https://i.imgur.com/Pvc0dGq.png\\" width=\\"200\\">","`foo` est extrait de la pile et `baz` est invoqu\xe9. `\\"Troisi\xe8me\\"` est affich\xe9.","<img src=\\"https://i.imgur.com/WhA2bCP.png\\" width=\\"200\\">","WebAPI ne peut simplement pas ajouter des \xe9l\xe9ments \xe0 la pile d\xe8s qu\u2019elle est pr\xeate. Au lieu de cela, elle pousse la fonction de rappel vers quelque chose appel\xe9 la _file d\'attente_.","<img src=\\"https://i.imgur.com/NSnDZmU.png\\" width=\\"200\\">","C\'est ici qu\'une boucle d\'\xe9v\xe9nement commence \xe0 fonctionner. La **boucle d\'\xe9v\xe9nement** examine la pile et la file d\'attente des t\xe2ches. Si la pile est vide, il prend la premi\xe8re chose dans la file d\'attente et la pousse sur la pile.","<img src=\\"https://i.imgur.com/uyiScAI.png\\" width=\\"200\\">","`bar` est invoqu\xe9, `\\"Second\\"` est affich\xe9 et il est sorti de la pile."],"id":29,"options":["`Premier` `Second` `Troisi\xe8me`","`Premier` `Troisi\xe8me` `Second`","`Second` `Premier` `Troisi\xe8me`","`Second` `Troisi\xe8me` `Premier`"],"problem":"const foo = () => console.log(\\"Premier\\");\\nconst bar = () => setTimeout(() => console.log(\\"Second\\"));\\nconst baz = () => console.log(\\"Troisi\xe8me\\");\\n\\nbar();\\nfoo();\\nbaz();\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["L\'\xe9l\xe9ment imbriqu\xe9 le plus profond qui a provoqu\xe9 l\'\xe9v\xe9nement est la cible de l\'\xe9v\xe9nement. Vous pouvez arr\xeater le bouillonnement _(bubbling)_ en utilisant `event.stopPropagation`."],"id":30,"options":["La `div` ext\xe9rieure","La `div` int\xe9rieure","`button`","Un tableau de tous les \xe9l\xe9ments imbriqu\xe9s."],"problem":"<div onclick=\\"console.log(\'first div\')\\">\\n  <div onclick=\\"console.log(\'second div\')\\">\\n    <button onclick=\\"console.log(\'button\')\\">\\n      Click!\\n    </button>\\n  </div>\\n</div>\\n","question":"Quel est l\'\xe9l\xe9ment cibl\xe9 _(event.target)_ au clic sur le bouton _(button)_ ?"},{"answer":0,"explanation":["Si nous cliquons sur `p`, nous verrons deux lignes : `p` et `div`. Lors de la propagation d\'un \xe9v\xe9nement, il y a 3 phases: capture, cible et bouillonnement _(bubbling)_. Par d\xe9faut, les gestionnaires d\'\xe9v\xe9nements sont ex\xe9cut\xe9s dans la phase de bouillonnement (sauf si vous d\xe9finissez `useCapture` sur` true`). Il va de l\'\xe9l\xe9ment imbriqu\xe9 le plus profond vers l\'ext\xe9rieur."],"id":31,"options":["`p` `div`","`div` `p`","`p`","`div`"],"problem":"<div onclick=\\"console.log(\'div\')\\">\\n  <p onclick=\\"console.log(\'p\')\\">\\n    Click here!\\n  </p>\\n</div>\\n","question":"Quand vous cliquez sur le paragraphe, quelle est la sortie ?"},{"answer":3,"explanation":["Avec les deux, nous pouvons transmettre l\'objet auquel nous voulons que le mot cl\xe9 `this` fasse r\xe9f\xe9rence. Cependant, `.call` est aussi _ex\xe9cut\xe9 imm\xe9diatement_ !","`.bind.` renvoie une copie de la fonction, mais avec un contexte li\xe9 ! Elle n\'est pas ex\xe9cut\xe9e imm\xe9diatement."],"id":32,"options":["`undefined is 21` `Lydia is 21`","`function` `function`","`Lydia is 21` `Lydia is 21`","`Lydia is 21` `function`"],"problem":"const person = { name: \\"Lydia\\" };\\n\\nfunction sayHi(age) {\\n  console.log(`${this.name} is ${age}`);\\n}\\n\\nsayHi.call(person, 21);\\nsayHi.bind(person, 21);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["La fonction `sayHi` renvoie la valeur renvoy\xe9e par la fonction imm\xe9diatement appel\xe9e (IIFE). Cette fonction a renvoy\xe9 `0`, qui est du type `\\"nombre\\"`.","Pour info : il n\'y a que 7 types natifs : `null`, `undefined`, `boolean`, `number`, `string`, `object`, `symbol` et `bigint`. `\\"function\\"` n\'est pas un type, puisque les fonctions sont des objets, il est de type `\\"object\\"`."],"id":33,"options":["`\\"object\\"`","`\\"number\\"`","`\\"function\\"`","`\\"undefined\\"`"],"problem":"function sayHi() {\\n  return (() => 0)();\\n}\\n\\ntypeof sayHi();\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Il n\'y a que six valeurs de fausses :","`undefined`","`null`","`NaN`","`0`","`\'\'` (cha\xeene de caract\xe8re vide)","`false`","Les constructeurs de fonctions, comme `new Number` et `new Boolean` sont la vraies."],"id":34,"options":["`0`, `\'\'`, `undefined`","`0`, `new Number(0)`, `\'\'`, `new Boolean(false)`, `undefined`","`0`, `\'\'`, `new Boolean(false)`, `undefined`","All of them are falsy"],"problem":"0;\\nnew Number(0);\\n(\\"\\");\\n(\\" \\");\\nnew Boolean(false);\\nundefined;\\n","question":"Lesquelles de ces valeurs sont fausses ?"},{"answer":1,"explanation":["`typeof 1` retourne `\\"number\\"`.\\n`typeof \\"number\\"` retourne `\\"string\\"`"],"id":35,"options":["`\\"number\\"`","`\\"string\\"`","`\\"object\\"`","`\\"undefined\\"`"],"problem":"console.log(typeof typeof 1);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Lorsque vous d\xe9finissez une valeur sur un \xe9l\xe9ment d\'un tableau qui d\xe9passe la longueur du tableau, JavaScript cr\xe9e un quelque chose appel\xe9 \\"emplacements vides\\". Ceux-ci ont en fait la valeur `undefined`, mais vous verrez quelque chose comme :","`[1, 2, 3, 7 x empty, 11]`","en fonction de l\'endroit o\xf9 vous l\'ex\xe9cutez (diff\xe9rent pour chaque navigateur, n\u0153ud, etc.)."],"id":36,"options":["`[1, 2, 3, 7 x null, 11]`","`[1, 2, 3, 11]`","`[1, 2, 3, 7 x empty, 11]`","`SyntaxError`"],"problem":"const numbers = [1, 2, 3];\\nnumbers[10] = 11;\\nconsole.log(numbers);\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Le bloc `catch` re\xe7oit l\'argument `x`. Ce n\'est pas le m\xeame `x` que la variable que nous passons en arguments. Cette variable `x` a une port\xe9e de bloc.","Plus tard, nous d\xe9finissons cette variable de bloc \xe9gale \xe0 `1` et d\xe9finissons la valeur de la variable `y`. Maintenant, nous affichons la variable `x` de port\xe9e de bloc, dont la valeur est \xe9gale \xe0 `1`.","En dehors du bloc `catch`, `x` est toujours `undefined` et `y` est \xe9gal \xe0 `2`. Lorsque nous voulons `console.log(x)` en dehors du bloc `catch`, il renvoie `undefined`, et `y` renvoie `2`."],"id":37,"options":["`1` `undefined` `2`","`undefined` `undefined` `undefined`","`1` `1` `2`","`1` `undefined` `undefined`"],"problem":"(() => {\\n  let x, y;\\n  try {\\n    throw new Error();\\n  } catch (x) {\\n    (x = 1), (y = 2);\\n    console.log(x);\\n  }\\n  console.log(x);\\n  console.log(y);\\n})();\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["JavaScript n\'a que des types et des objets primitifs.","Les types primitifs sont `boolean`, `null`, `undefined`, `bigint`, `number`, `string` et `symbol`.","Ce qui diff\xe9rencie une primitive d\'un objet, c\'est que les primitives n\'ont aucune propri\xe9t\xe9 ou m\xe9thode. Cependant, vous remarquerez que  `\'foo\'.toUpperCase()` est \xe9valu\xe9 \xe0 `\'FOO\'` et n\'entra\xeene pas de `TypeError`. En effet, lorsque vous essayez d\'acc\xe9der \xe0 une propri\xe9t\xe9 ou \xe0 une m\xe9thode sur une primitive telle qu\'une cha\xeene, JavaScript encapsule implicitement l\'objet \xe0 l\'aide de l\'une des classes d\'encapsulation, \xe0 savoir `String`, puis supprime imm\xe9diatement l\'encapsulation apr\xe8s l\'\xe9valuation de l\'expression. Toutes les primitives \xe0 l\'exception de `null` et` undefined` pr\xe9sentent ce comportement."],"id":38,"options":["primitif ou objet","fonction ou objet","question d\xe9licate ! Seulement des objets","nombre ou objet"],"problem":"","question":"Tout en JavaScript est..."},{"answer":2,"explanation":["`[1, 2]` est notre valeur initiale. C\'est la valeur avec laquelle nous commen\xe7ons et la valeur du tout premier `acc`. Au premier tour, `acc` est `[1,2]` et `cur` est `[0, 1]`. Nous les concat\xe9nons, ce qui donne `[1, 2, 0, 1]`.","Ensuite, `acc` est `[1, 2, 0, 1]` et `cur` est `[2, 3]`. Nous les concat\xe9nons et obtenons `[1, 2, 0, 1, 2, 3]`"],"id":39,"options":["`[0, 1, 2, 3, 1, 2]`","`[6, 1, 2]`","`[1, 2, 0, 1, 2, 3]`","`[1, 2, 6]`"],"problem":"[[0, 1], [2, 3]].reduce(\\n  (acc, cur) => {\\n    return acc.concat(cur);\\n  },\\n  [1, 2]\\n);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["`null` est faux. `!null` retourne `true`. `!true` retourne `false`.","`\\"\\"` est faux. `!\\"\\"` retourne `true`. `!true` retourne `false`.","`1` est vrai. `!1` retourne `false`. `!false` retourne `true`."],"id":40,"options":["`false` `true` `false`","`false` `false` `true`","`false` `true` `true`","`true` `true` `false`"],"problem":"!!null;\\n!!\\"\\";\\n!!1;\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Il retourne un identifiant unique. Cet identifiant peut \xeatre utilis\xe9 pour effacer cet interval avec la fonction `clearInterval()`."],"id":41,"options":["un identifiant unique","le temps de millisecondes sp\xe9cifi\xe9","la fonction pass\xe9e en param\xe8tre","`undefined`"],"problem":"setInterval(() => console.log(\\"Hi\\"), 1000);\\n","question":"Que retourne la m\xe9thode `setInterval` ?"},{"answer":0,"explanation":["Une cha\xeene de caract\xe8re est it\xe9rable. L\'op\xe9rateur de d\xe9construction transforme chaque caract\xe8re d\'un it\xe9rable en un \xe9l\xe9ment."],"id":42,"options":["`[\\"L\\", \\"y\\", \\"d\\", \\"i\\", \\"a\\"]`","`[\\"Lydia\\"]`","`[[], \\"Lydia\\"]`","`[[\\"L\\", \\"y\\", \\"d\\", \\"i\\", \\"a\\"]]`"],"problem":"[...\\"Lydia\\"];\\n","question":"Que retourne ceci ?"},{"answer":2,"explanation":["Les fonctions r\xe9guli\xe8res ne peuvent pas \xeatre arr\xeat\xe9es \xe0 mi-parcours apr\xe8s l\'invocation. Cependant, une fonction de g\xe9n\xe9rateur peut \xeatre \\"arr\xeat\xe9e\\" \xe0 mi-chemin et continuer plus tard \xe0 partir de son point d\'arr\xeat. Chaque fois qu\'une fonction g\xe9n\xe9ratrice rencontre un mot-cl\xe9 `yield`, elle renvoie la valeur sp\xe9cifi\xe9e apr\xe8s celui-ci. Notez que la fonction du g\xe9n\xe9rateur dans ce cas ne _return_ pas la valeur, il _yields_ la valeur.","Premi\xe8rement, nous initialisons la fonction du g\xe9n\xe9rateur avec `i` \xe9gal \xe0` 10`. Nous appelons la fonction g\xe9n\xe9ratrice en utilisant la m\xe9thode `next()`. La premi\xe8re fois que nous appelons la fonction de g\xe9n\xe9rateur, `i` est \xe9gal \xe0 `10`. Il rencontre le premier mot-cl\xe9 `yield` : il donne la valeur de `i`. Le g\xe9n\xe9rateur est maintenant \\"en pause\\" et `10` est affich\xe9.","Ensuite, nous appelons \xe0 nouveau la fonction avec la m\xe9thode `next()`. Il commence \xe0 continuer l\xe0 o\xf9 il s\u2019\xe9tait arr\xeat\xe9 pr\xe9c\xe9demment, toujours avec `i` \xe9gal \xe0 `10`. Maintenant, il rencontre le prochain mot-cl\xe9 `yield` et donne `i * 2`. `i` est \xe9gal \xe0 `10`, donc il renvoie `10 * 2`, ce qui correspond \xe0 `20`. Cela donne `10, 20`."],"id":43,"options":["`[0, 10], [10, 20]`","`20, 20`","`10, 20`","`0, 10 and 10, 20`"],"problem":"function* generator(i) {\\n  yield i;\\n  yield i * 2;\\n}\\n\\nconst gen = generator(10);\\n\\nconsole.log(gen.next().value);\\nconsole.log(gen.next().value);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Lorsque nous passons plusieurs promesses \xe0 la m\xe9thode `Promise.race`, elle r\xe9sout/rejette la promesse _first_ qui r\xe9sout/rejette. Nous passons, \xe0 la m\xe9thode `setTimeout`, un timer: 500 ms pour la premi\xe8re promesse (`firstPromise`), et 100 ms pour la deuxi\xe8me promesse (`secondPromise`). Cela signifie que le `secondPromise` se r\xe9sout en premier avec la valeur de `\'two\'`. `res` contient maintenant la valeur de `\'deux\'`, qui est affich\xe9."],"id":44,"options":["`\\"one\\"`","`\\"two\\"`","`\\"two\\" \\"one\\"`","`\\"one\\" \\"two\\"`"],"problem":"const firstPromise = new Promise((res, rej) => {\\n  setTimeout(res, 500, \\"one\\");\\n});\\n\\nconst secondPromise = new Promise((res, rej) => {\\n  setTimeout(res, 100, \\"two\\");\\n});\\n\\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\\n","question":"Qu\'est-ce que cela retourne ?"},{"answer":3,"explanation":["Tout d\'abord, nous d\xe9clarons une variable `person` avec la valeur d\'un objet poss\xe9dant une propri\xe9t\xe9 `name`.","<img src=\\"https://i.imgur.com/TML1MbS.png\\" width=\\"200\\">","Ensuite, nous d\xe9clarons une variable appel\xe9e `membres`. Nous d\xe9finissons le premier \xe9l\xe9ment de ce tableau \xe9gal \xe0 la valeur de la variable `person`. Les objets interagissent par r\xe9f\xe9rence quand ils sont \xe9gaux. Lorsque vous affectez une r\xe9f\xe9rence d\'une variable \xe0 une autre, vous cr\xe9ez une copie de cette r\xe9f\xe9rence. (notez qu\'ils n\'ont pas la m\xeame r\xe9f\xe9rence !)","<img src=\\"https://i.imgur.com/FSG5K3F.png\\" width=\\"300\\">","Ensuite, nous d\xe9finissons la variable `person` \xe9gale \xe0 `null`.","<img src=\\"https://i.imgur.com/sYjcsMT.png\\" width=\\"300\\">","Nous modifions seulement la valeur de la variable `person`, et non le premier \xe9l\xe9ment du tableau, car cet \xe9l\xe9ment a une r\xe9f\xe9rence (copi\xe9e) diff\xe9rente de l\'objet. Le premier \xe9l\xe9ment de `members` conserve sa r\xe9f\xe9rence \xe0 l\'objet d\'origine. Lorsque nous affichons le tableau `members`, le premier \xe9l\xe9ment contient toujours la valeur de l\'objet, qui est affich\xe9."],"id":45,"options":["`null`","`[null]`","`[{}]`","`[{ name\\"Lydia\\" }]`"],"problem":"let person = { name: \\"Lydia\\" };\\nconst members = [person];\\nperson = null;\\n\\nconsole.log(members);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Avec une boucle `for-in`, nous pouvons parcourir les cl\xe9s d\'objet, dans ce cas `name` et `age`. Sous le capot, les cl\xe9s d\'objet sont des cha\xeenes (si elles ne sont pas un symbole). A chaque boucle, nous d\xe9finissons la valeur de `item` \xe9gal \xe0 la cl\xe9 courante sur laquelle elle est entrain d\'it\xe9r\xe9. Premi\xe8rement, `item` est \xe9gal \xe0 `name` et est affich\xe9. Ensuite, `item` est \xe9gal \xe0 `age`, qui est affich\xe9."],"id":46,"options":["`{ name\\"Lydia\\" }, { age21 }`","`\\"name\\", \\"age\\"`","`\\"Lydia\\", 21`","`[\\"name\\", \\"Lydia\\"], [\\"age\\", 21]`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n};\\n\\nfor (const item in person) {\\n  console.log(item);\\n}\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["L\'associativit\xe9 des op\xe9rateurs correspond \xe0 l\'ordre dans lequel le compilateur \xe9value les expressions, de gauche \xe0 droite ou de droite \xe0 gauche. Cela se produit uniquement si tous les op\xe9rateurs ont la m\xeame priorit\xe9. Nous n\'avons qu\'un type d\'op\xe9rateur : `+`. De plus, l\'associativit\xe9 est de gauche \xe0 droite.","`3 + 4` est \xe9valu\xe9 en premier. Cela donne le nombre `7`.","`7 + \'5\'` donne `\'75\'` \xe0 cause de la conversion. JavaScript convertit le nombre `7` en une cha\xeene, voir question 15. Nous pouvons concat\xe9ner deux cha\xeenes en utilisant l\'op\xe9rateur `+`. `\\"7\\" + \\"5\\"` a pour r\xe9sultat `\\"75\\"`."],"id":47,"options":["`\\"345\\"`","`\\"75\\"`","`12`","`\\"12\\"`"],"problem":"console.log(3 + 4 + \\"5\\");\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Seuls les premiers nombres de la cha\xeene sont renvoy\xe9s. Bas\xe9 sur la base dix (le deuxi\xe8me argument permettant de sp\xe9cifier le type de nombre que nous voulons analyser: base 10, hexad\xe9cimal, octal, binaire, etc.), `parseInt` v\xe9rifie si les caract\xe8res de la cha\xeene sont valides. Une fois qu\'il rencontre un caract\xe8re qui n\'est pas un nombre valide dans la base, il arr\xeate l\'analyse et ignore les caract\xe8res suivants.","`*` n\'est pas un nombre valide. Il analyse seulement `7` dans la d\xe9cimale `7`. `num` contient maintenant la valeur de` 7`."],"id":48,"options":["`42`","`\\"42\\"`","`7`","`NaN`"],"problem":"const num = parseInt(\\"7*6\\", 10);\\n","question":"Quelle est la valeur de `num` ?"},{"answer":2,"explanation":["Lors du l\'utilisation de `map` sur le tableau, la valeur de `num` est \xe9gale \xe0 l\u2019\xe9l\xe9ment sur lequel elle est en train de boucler. Dans ce cas, les \xe9l\xe9ments sont des nombres. La condition de l\'instruction si `typeof num === \\"num\xe9ro\\"` renvoie `true`. La fonction map cr\xe9e un nouveau tableau et ins\xe8re les valeurs renvoy\xe9es par la fonction.","Cependant, nous ne renvoyons pas de valeur. Lorsque nous ne renvoyons pas de valeur \xe0 partir de la fonction, la fonction renvoie `undefined`. Le bloc de fonction est appel\xe9 pour chaque \xe9l\xe9ment du tableau. Ainsi, pour chaque \xe9l\xe9ment, nous renvoyons `undefined`."],"id":49,"options":["`[]`","`[null, null, null]`","`[undefined, undefined, undefined]`","`[ 3 x empty ]`"],"problem":"[1, 2, 3].map(num => {\\n  if (typeof num === \\"number\\") return;\\n  return num * 2;\\n});\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Les arguments sont pass\xe9s par _valeur_, \xe0 moins que leur valeur ne soit un objet, ils sont pass\xe9s par _r\xe9f\xe9rence_. `birthYear` est pass\xe9e par valeur, car c\'est une cha\xeene, pas un objet. Lorsque nous passons des arguments par valeur, une copie de cette valeur est cr\xe9\xe9e (voir question 46).","La variable `birthYear` a une r\xe9f\xe9rence \xe0 la valeur `\\"1997\\"`. L\'argument `year` fait \xe9galement r\xe9f\xe9rence \xe0 la valeur `\\"1997\\"`, mais il ne s\'agit pas de la m\xeame valeur que celle de `birthYear`. Lorsque nous mettons \xe0 jour la valeur de `year` en pla\xe7ant `year` \xe9gal \xe0 `\\"1998\\"`, nous ne mettons \xe0 jour que la valeur de `year`. `birthYear` est toujours \xe9gal \xe0 `\\"1997\\"`.","La valeur de `person` est un objet. L\'argument `membre` a une r\xe9f\xe9rence (copi\xe9e) au m\xeame objet. Lorsque nous modifions une propri\xe9t\xe9 de l\'objet, `membre` a une r\xe9f\xe9rence \xe0 la valeur de` person` sera \xe9galement modifi\xe9e, puisqu\'elles ont toutes les deux une r\xe9f\xe9rence au m\xeame objet. La propri\xe9t\xe9 `name` de `person` est maintenant \xe9gale \xe0 la valeur `\\"Lydia\\"`."],"id":50,"options":["`{ name\\"Lydia\\" }, \\"1997\\"`","`{ name\\"Sarah\\" }, \\"1998\\"`","`{ name\\"Lydia\\" }, \\"1998\\"`","`{ name\\"Sarah\\" }, \\"1997\\"`"],"problem":"function getInfo(member, year) {\\n  member.name = \\"Lydia\\";\\n  year = \\"1998\\";\\n}\\n\\nconst person = { name: \\"Sarah\\" };\\nconst birthYear = \\"1997\\";\\n\\ngetInfo(person, birthYear);\\n\\nconsole.log(person, birthYear);\\n","question":"Quelle est la sortie ?"},{"answer":3,"explanation":["Avec l\'instruction `throw`, nous pouvons cr\xe9er des erreurs personnalis\xe9es. Avec cette d\xe9claration, vous pouvez lancer des exceptions. Une exception peut \xeatre une <b>cha\xeene</b>, un <b>num\xe9ro</b>, un <b>bool\xe9en</b> ou un <b>objet</b>. Dans ce cas, notre exception est la cha\xeene `\'Hello world\'`.","Avec l\'instruction `catch`, nous pouvons sp\xe9cifier quoi faire si une exception est lev\xe9e dans le bloc `try`. Une exception est lev\xe9e : la cha\xeene `\'Hello world\'`. `e` est maintenant \xe9gal \xe0 cette cha\xeene, que nous affichons. Il en r\xe9sulte `\'Oh an error: Hello world\'`."],"id":51,"options":["`\\"It worked! Hello world!\\"`","`\\"Oh no an errorundefined`","`SyntaxErrorcan only throw Error objects`","`\\"Oh no an errorHello world!`"],"problem":"function greeting() {\\n  throw \\"Hello world!\\";\\n}\\n\\nfunction sayHi() {\\n  try {\\n    const data = greeting();\\n    console.log(\\"It worked!\\", data);\\n  } catch (e) {\\n    console.log(\\"Oh no an error!\\", e);\\n  }\\n}\\n\\nsayHi();\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Lorsque vous retournez une propri\xe9t\xe9, la valeur de la propri\xe9t\xe9 est \xe9gale \xe0 la valeur _retourn\xe9e_ et non \xe0 la valeur d\xe9finie dans la fonction constructeur. Nous renvoyons la cha\xeene `\\"Maserati\\"`, donc `myCar.make` est \xe9gal \xe0 `\\"Maserati\\"`."],"id":52,"options":["`\\"Lamborghini\\"`","`\\"Maserati\\"`","`ReferenceError`","`TypeError`"],"problem":"function Car() {\\n  this.make = \\"Lamborghini\\";\\n  return { make: \\"Maserati\\" };\\n}\\n\\nconst myCar = new Car();\\nconsole.log(myCar.make);\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["`let x = y = 10;` est en r\xe9alit\xe9 un raccourci pour :","Lorsque nous d\xe9finissons `y` \xe9gal \xe0 `10`, nous ajoutons en fait une propri\xe9t\xe9 `y` \xe0 l\'objet global (`window` dans le navigateur,` global` dans NodeJS). Dans un navigateur, `window.y` est \xe9gal \xe0 `10`.","Ensuite, nous d\xe9clarons une variable `x` avec la valeur de `y`, qui est `10`. Les variables d\xe9clar\xe9es avec le mot-cl\xe9 `let` ont une port\xe9e de bloc, elles ne sont d\xe9finies que dans le bloc dans lequel elles sont d\xe9clar\xe9es; la fonction imm\xe9diatement invoqu\xe9e (IIFE) dans ce cas. Lorsque nous utilisons l\'op\xe9rateur `typeof`, l\'op\xe9rande `x` n\'est pas d\xe9fini: nous essayons d\'acc\xe9der \xe0 `x` en dehors du bloc dans lequel il est d\xe9clar\xe9. Cela signifie que `x` n\'est pas d\xe9fini. Les valeurs auxquelles aucune valeur n\'a \xe9t\xe9 attribu\xe9e ni d\xe9clar\xe9e sont du type `\\"undefined\\"`. `console.log (typeof x)` renvoie `\\"undefined\\"`.","Cependant, nous avons cr\xe9\xe9 une variable globale `y` lorsque `y` est \xe9gal \xe0 `10`. Cette valeur est accessible n\'importe o\xf9 dans notre code. `y` est d\xe9fini et contient une valeur de type `\\"number\\"`. `console.log (typeof y)` renvoie `\\"number\\"`."],"id":53,"options":["`\\"undefined\\", \\"number\\"`","`\\"number\\", \\"number\\"`","`\\"object\\", \\"number\\"`","`\\"number\\", \\"undefined\\"`"],"problem":"(() => {\\n  let x = (y = 10);\\n})();\\n\\nconsole.log(typeof x);\\nconsole.log(typeof y);\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Nous pouvons supprimer des propri\xe9t\xe9s d\'objets en utilisant le mot-cl\xe9 `delete`, \xe9galement dans le prototype. En supprimant une propri\xe9t\xe9 dans le prototype, elle n\u2019est plus disponible dans la cha\xeene de prototypes. Dans ce cas, la fonction `bark` n\'est plus disponible dans le prototype apr\xe8s `delete Dog.prototype.bark`, mais nous essayons toujours d\'y acc\xe9der.","Lorsque nous essayons d\'appeler quelque chose qui n\'est pas une fonction, un `TypeError` est lev\xe9. Dans ce cas, `TypeError: pet.bark n\'est pas une fonction`, puisque` pet.bark` est `undefined`."],"id":54,"options":["`\\"Woof I am Mara\\"`, `TypeError`","`\\"Woof I am Mara\\"`,`\\"Woof I am Mara\\"`","`\\"Woof I am Mara\\"`, `undefined`","`TypeError`, `TypeError`"],"problem":"class Dog {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n}\\n\\nDog.prototype.bark = function() {\\n  console.log(`Woof I am ${this.name}`);\\n};\\n\\nconst pet = new Dog(\\"Mara\\");\\n\\npet.bark();\\n\\ndelete Dog.prototype.bark;\\n\\npet.bark();\\n","question":"Quelle est la sortie ?"},{"answer":3,"explanation":["L\'objet `Set` est une collection de valeurs _uniques_ : une valeur ne peut appara\xeetre qu\'une seule fois dans un ensemble.","Nous avons pass\xe9 l\'it\xe9rable `[1, 1, 2, 3, 4]` avec une valeur dupliqu\xe9e `1`. Puisque nous ne pouvons pas avoir deux valeurs identiques dans un ensemble, l\'une d\'entre elles est supprim\xe9e. Cela donne `{1, 2, 3, 4}`."],"id":55,"options":["`[1, 1, 2, 3, 4]`","`[1, 2, 3, 4]`","`{1, 1, 2, 3, 4}`","`{1, 2, 3, 4}`"],"problem":"const set = new Set([1, 1, 2, 3, 4]);\\n\\nconsole.log(set);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Un module import\xe9 est _en lecture seule_ : vous ne pouvez pas modifier le module import\xe9. Seul le module qui les exporte peut en changer la valeur.","Lorsque nous essayons d\'incr\xe9menter la valeur de `myCounter`, une erreur est g\xe9n\xe9r\xe9e : `myCounter` est en lecture seule et ne peut pas \xeatre modifi\xe9."],"id":56,"options":["`10`","`11`","`Error`","`NaN`"],"problem":"// counter.js\\nlet counter = 10;\\nexport default counter;\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["L\'op\xe9rateur `delete` renvoie une valeur bool\xe9enne : `true` en cas de suppression r\xe9ussie, sinon il renvoie `false`. Toutefois, les variables d\xe9clar\xe9es avec les mots cl\xe9s `var`,` const` ou `let` ne peuvent pas \xeatre supprim\xe9es \xe0 l\'aide de l\'op\xe9rateur` delete`.","La variable `name` a \xe9t\xe9 d\xe9clar\xe9e avec un mot-cl\xe9 `const`. Par cons\xe9quent, sa suppression a \xe9chou\xe9 : `false` est renvoy\xe9. Lorsque nous d\xe9finissons `age` \xe9gal \xe0 `21`, nous avons en fait ajout\xe9 une propri\xe9t\xe9 appel\xe9e `age` \xe0 l\'objet global. De cette fa\xe7on, vous pouvez supprimer des propri\xe9t\xe9s d\u2019objets, ainsi que de l\u2019objet global, pour que `delete age` renvoie` true`."],"id":57,"options":["`false`, `true`","`\\"Lydia\\"`, `21`","`true`, `true`","`undefined`, `undefined`"],"problem":"const name = \\"Lydia\\";\\nage = 21;\\n\\nconsole.log(delete name);\\nconsole.log(delete age);\\n","question":"Quelle est la sortie ?"},{"answer":2,"explanation":["Nous pouvons d\xe9compresser les valeurs des tableaux ou les propri\xe9t\xe9s des objets en les d\xe9truisant. Par exemple :","<img src=\\"https://i.imgur.com/ADFpVop.png\\" width=\\"200\\">","La valeur de `a` est maintenant `1` et la valeur de `b` est maintenant `2`. Ce que nous avons r\xe9ellement fait dans la question, c\'est :","<img src=\\"https://i.imgur.com/NzGkMNk.png\\" width=\\"200\\">","Cela signifie que la valeur de `y` est \xe9gale \xe0 la premi\xe8re valeur du tableau, qui correspond au nombre `1`. Lorsque nous affichons `y`,` 1` est renvoy\xe9."],"id":58,"options":["`[[1, 2, 3, 4, 5]]`","`[1, 2, 3, 4, 5]`","`1`","`[1]`"],"problem":"const numbers = [1, 2, 3, 4, 5];\\nconst [y] = numbers;\\n\\nconsole.log(y);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Il est possible de combiner des objets en utilisant l\'op\xe9rateur de d\xe9construction `...`. Il vous permet de cr\xe9er des copies des paires cl\xe9 / valeur d\'un objet et de les ajouter \xe0 un autre objet. Dans ce cas, nous cr\xe9ons des copies de l\'objet `user` et nous les ajoutons \xe0 l\'objet` admin`. L\'objet `admin` contient maintenant les paires cl\xe9 / valeur copi\xe9es, ce qui donne `{admin: true, nom: \\"Lydia\\", age: 21}`."],"id":59,"options":["`{ admintrue, user{ name\\"Lydia\\", age21 } }`","`{ admintrue, name\\"Lydia\\", age21 }`","`{ admintrue, user[\\"Lydia\\", 21] }`","`{ admintrue }`"],"problem":"const user = { name: \\"Lydia\\", age: 21 };\\nconst admin = { admin: true, ...user };\\n\\nconsole.log(admin);\\n","question":"Quelle est la sortie ?"},{"answer":1,"explanation":["Avec la m\xe9thode `defineProperty`, nous pouvons ajouter de nouvelles propri\xe9t\xe9s \xe0 un objet ou modifier celles existantes. Lorsque nous ajoutons une propri\xe9t\xe9 \xe0 un objet en utilisant la m\xe9thode `defineProperty`, il s\u2019agit par d\xe9faut d\'une propri\xe9t\xe9 _non \xe9num\xe9rable_. La m\xe9thode `Object.keys` renvoie tous les noms de propri\xe9t\xe9s _\xe9num\xe9rable_ \xe0 partir d\'un objet, dans ce cas uniquement `\\"name\\"`.","Les propri\xe9t\xe9s ajout\xe9es \xe0 l\'aide de la m\xe9thode `defineProperty` sont immuables par d\xe9faut. Vous pouvez remplacer ce comportement en utilisant les propri\xe9t\xe9s `writeable`, `configurable` et `enumerable`. De cette fa\xe7on, la m\xe9thode `defineProperty` vous donne beaucoup plus de contr\xf4le sur les propri\xe9t\xe9s que vous ajoutez \xe0 un objet."],"id":60,"options":["`{ name\\"Lydia\\", age21 }`, `[\\"name\\", \\"age\\"]`","`{ name\\"Lydia\\", age21 }`, `[\\"name\\"]`","`{ name\\"Lydia\\"}`, `[\\"name\\", \\"age\\"]`","`{ name\\"Lydia\\"}`, `[\\"age\\"]`"],"problem":"const person = { name: \\"Lydia\\" };\\n\\nObject.defineProperty(person, \\"age\\", { value: 21 });\\n\\nconsole.log(person);\\nconsole.log(Object.keys(person));\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["Le second argument de `JSON.stringify` est le _repla\xe7ant_. Le rempla\xe7ant peut \xeatre une fonction ou un tableau, et vous permet de contr\xf4ler quoi et comment les valeurs doivent \xeatre stringifi\xe9es.","Si le rempla\xe7ant est un _tableau_, seules les propri\xe9t\xe9s dont les noms sont inclus dans le tableau seront ajout\xe9es \xe0 la cha\xeene JSON. Dans ce cas, seules les propri\xe9t\xe9s avec les noms `\\"level\\"` et `\\"health\\"` sont incluses, `\\"username\\"` est exclu. `data` est maintenant \xe9gal \xe0 `\\"{\\"level\\":19, \\"health\\":90}\\"`.","Si le rempla\xe7ant est une _fonction_, cette fonction est appel\xe9e sur chaque propri\xe9t\xe9 de l\'objet que vous personnalisez. La valeur renvoy\xe9e par cette fonction sera la valeur de la propri\xe9t\xe9 lorsqu\'elle sera ajout\xe9e \xe0 la cha\xeene JSON. Si la valeur est `undefined`, cette propri\xe9t\xe9 est exclue de la cha\xeene JSON."],"id":61,"options":["`\\"{\\"level\\":19, \\"health\\":90}\\"`","`\\"{\\"username\\"\\"lydiahallie\\"}\\"`","`\\"[\\"level\\", \\"health\\"]\\"`","`\\"{\\"username\\"\\"lydiahallie\\", \\"level\\":19, \\"health\\":90}\\"`"],"problem":"const settings = {\\n  username: \\"lydiahallie\\",\\n  level: 19,\\n  health: 90\\n};\\n\\nconst data = JSON.stringify(settings, [\\"level\\", \\"health\\"]);\\nconsole.log(data);\\n","question":"Quelle est la sortie ?"},{"answer":0,"explanation":["L\'op\xe9rateur arithm\xe9tique `++` _renvoie en premier_ la valeur de l\'op\xe9rande, _puis incr\xe9mente_ la valeur de l\'op\xe9rande. La valeur de `num1` est \xe9gale \xe0 `10`, puisque la fonction `increaseNumber` renvoie d\'abord la valeur de `num`, qui correspond \xe0 `10`, et augmente la valeur de `num` par la suite.","`num2` est \xe9gal \xe0 `10`, puisque nous avons pass\xe9 `num1` \xe0 la commande `increasePassedNumber`. `number` est \xe9gal \xe0 `10` (la valeur de `num1`). Encore une fois, l\'op\xe9rateur arithm\xe9tique `++` _renvoie d\'abord_ la valeur de l\'op\xe9rande, puis incr\xe9mente_ la valeur de l\'op\xe9rande. La valeur de `nombre` est `10`, donc `num2` est \xe9gal \xe0 `10`."],"id":62,"options":["`10`, `10`","`10`, `11`","`11`, `11`","`11`, `12`"],"problem":"let num = 10;\\n\\nconst increaseNumber = () => num++;\\nconst increasePassedNumber = number => number++;\\n\\nconst num1 = increaseNumber();\\nconst num2 = increasePassedNumber(num1);\\n\\nconsole.log(num1);\\nconsole.log(num2);\\n","question":"Quelle est la sortie ?"}]')}}]);
//# sourceMappingURL=40.a2f6b511.chunk.js.map