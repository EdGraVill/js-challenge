(this["webpackJsonpjs-challenge"]=this["webpackJsonpjs-challenge"]||[]).push([[36],{114:function(e){e.exports=JSON.parse('[{"answer":3,"explanation":["Dentro de la funci\xf3n, primero declaramos la variable `name` con la palabra reservada ` var`. Esto significa que la variable se _eleva_ (el espacio de memoria se configura durante la fase de creaci\xf3n. Hace referencia al termino [hoisting](https://developer.mozilla.org/es/docs/Glossary/Hoisting)) con el valor predeterminado de `indefinido`, hasta que realmente llegamos a la l\xednea donde definimos la variable. A\xfan no hemos definido la variable en la l\xednea donde intentamos registrar la variable `name`, por lo que a\xfan mantiene el valor de` undefined`.","Las variables con la palabra clave `let` (y` const`) se _elevan_, pero a diferencia de `var`, no se inicializa <i> </i>. No son accesibles antes de la l\xednea que los declaramos (inicializamos). Esto se llama la [\\"zona muerta temporal\\"](https://wesbos.com/temporal-dead-zone/). Cuando intentamos acceder a las variables antes de que se declaren, JavaScript lanza un `ReferenceError`\\n</p>\\n</details>"],"id":0,"options":["`Lydia` y `undefined`","`Lydia` y `ReferenceError`","`ReferenceError` y `21`","`undefined` y `ReferenceError`"],"problem":"function sayHi() {\\n  console.log(name);\\n  console.log(age);\\n  var name = \\"Lydia\\";\\n  let age = 21;\\n}\\n\\nsayHi();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Debido a la cola de eventos en JavaScript, la funci\xf3n `setTimeout` se llama una vez el ciclo se ha ejecutado. Dado que la variable `i` en el primer bucle se declar\xf3 utilizando la palabra reservada ` var`, este valor es global. Durante el bucle, incrementamos el valor de `i` en` 1` cada vez, utilizando el operador unario `++`. Cuando se invoc\xf3 la funci\xf3n `setTimeout`,` i` era igual a `3` en el primer ejemplo.","En el segundo bucle, la variable `i` se declar\xf3 utilizando la palabra reservada` let`: las variables declaradas con la palabra reservada `let` (y` const`) tienen un \xe1mbito de bloque (un bloque es lo que se encuentra entre `{}`). Durante cada iteraci\xf3n, `i` tendr\xe1 un nuevo valor, y cada valor se encuentra dentro del bucle."],"id":1,"options":["`0 1 2` y `0 1 2`","`0 1 2` y `3 3 3`","`3 3 3` y `0 1 2`"],"problem":"for (var i = 0; i < 3; i++) {\\n  setTimeout(() => console.log(i), 1);\\n}\\n\\nfor (let i = 0; i < 3; i++) {\\n  setTimeout(() => console.log(i), 1);\\n}\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":1,"explanation":["Hay que tener en cuenta aqui que el valor de `di\xe1metro` es una funci\xf3n regular o _normal_, mientras que el valor de `per\xedmetro` es una funci\xf3n de flecha.","Con las funciones de flecha, la palabra clave `this` se refiere a su \xe1mbito actual, a diferencia de las funciones regulares. Esto significa que cuando llamamos \\"per\xedmetro\\", no se refiere al objeto en s\xed mismo, sino a su \xe1mbito circundante (ventana por ejemplo).","No hay valor `radius` en ese objeto, que devuelve` undefined`."],"id":2,"options":["`20` y `62.83185307179586`","`20` y `NaN`","`20` y `63`","`NaN` y `63`"],"problem":"const shape = {\\n  radius: 10,\\n  diameter() {\\n    return this.radius * 2;\\n  },\\n  perimeter: () => 2 * Math.PI * this.radius\\n};\\n\\nshape.diameter();\\nshape.perimeter();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["En el primera caso se intenta convertir un operando en un n\xfamero. `true` es` 1`, y `false` es` 0`.","En el segundo caso la cadena `\'Lydia\'` es un valor verdadero. Lo que realmente estamos preguntando es \\"\xbfes este verdadero valor falso?\\". Esto devuelve `false`."],"id":3,"options":["`1` y `false`","`false` y `NaN`","`false` y `false`"],"problem":"+true;\\n!\\"Lydia\\";\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["En JavaScript, todas las _keys_ son cadenas (a menos que sea un s\xedmbolo). A pesar de que no podr\xedamos escribirlos como cadenas, siempre funcionan como cadenas de manera interna.","JavaScript interpreta declaraciones. Cuando usamos la notaci\xf3n de corchetes, ve el corchete de apertura `[` y contin\xfaa hasta que encuentra el corchete de cierre `]`. Solo de esta manera se evaluar\xe1 la afirmaci\xf3n.","`mouse [bird.size]`: Primero eval\xfaa `bird.size`, que es` \\"small\\" `. `mouse [\\"small\\"]` devuelve `true`","Sin embargo, con la notaci\xf3n de puntos, esto no sucede. `mouse` no tiene una clave llamada` bird`, lo que significa que `mouse.bird` es` undefined`. Luego, pedimos el `tama\xf1o` usando la notaci\xf3n de puntos:` mouse.bird.size`. Como `mouse.bird` es` undefined`, en realidad estamos preguntando `undefined.size`. Esto no es v\xe1lido y generar\xe1 un error similar `al Cannot read property \\"size\\" of undefined`"],"id":4,"options":["`mouse.bird.size`","`mouse[bird.size]`","`mouse[bird[\\"size\\"]]`","Todas son correctas"],"problem":"const bird = {\\n  size: \\"small\\"\\n};\\n\\nconst mouse = {\\n  name: \\"Mickey\\",\\n  small: true\\n};\\n","question":"\xbfCu\xe1l NO es v\xe1lida?"},{"answer":0,"explanation":["En JavaScript, TODOS los objetos interact\xfaan por referencia, de modo que cuando se establecen iguales o pasan a una funci\xf3n, todos apuntan a la misma ubicaci\xf3n. De esta manera cuando cambia un objeto, los cambia a todos.","Primero, la variable `c` tiene un valor para un objeto. M\xe1s tarde, asignamos `d` con la misma referencia que` c` tiene al objeto.","<img src = \\"https://i.imgur.com/ko5k0fs.png\\" width = \\"200\\">","Cuando cambias un objeto, cambias todos ellos."],"id":5,"options":["`Hello`","`undefined`","`ReferenceError`","`TypeError`"],"problem":"let c = { greeting: \\"Hey!\\" };\\nlet d;\\n\\nd = c;\\nc.greeting = \\"Hello\\";\\nconsole.log(d.greeting);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["`new Number ()` es un constructor de funciones incorporado. Aunque parece un n\xfamero, no es realmente un n\xfamero: tiene muchas caracter\xedsticas adicionales y es un objeto.","Cuando usamos el operador `==`, solo verifica si tiene el mismo _valor_. Ambos tienen el valor de `3`, por lo que devuelve` true`.","Sin embargo, cuando usamos el operador `===`, tanto el **valor** como el **tipo** deben ser iguales. Entonces: `new Number ()` no es un n\xfamero, es un **objeto**. Ambos devuelven \\"false\\"."],"id":6,"options":["`true` `false` `true`","`false` `false` `true`","`true` `false` `false`","`false` `true` `true`"],"problem":"let a = 3;\\nlet b = new Number(3);\\nlet c = 3;\\n\\nconsole.log(a == b);\\nconsole.log(a === b);\\nconsole.log(b === c);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":3,"explanation":["La funci\xf3n `colorChange` es est\xe1tica. Los m\xe9todos est\xe1ticos est\xe1n dise\xf1ados para _vivir_ solo en el constructor en el que se crean y no se pueden transmitir a ning\xfan elemento secundario. Como `freddie` es un ni\xf1o, la funci\xf3n no se transmite y no est\xe1 disponible en la instancia de `freddie`: por lo tanto se lanza un `TypeError`."],"id":7,"options":["`orange`","`purple`","`green`","`TypeError`"],"problem":"class Chameleon {\\n  static colorChange(newColor) {\\n    this.newColor = newColor;\\n    return this.newColor;\\n  }\\n\\n  constructor({ newColor = \\"green\\" } = {}) {\\n    this.newColor = newColor;\\n  }\\n}\\n\\nconst freddie = new Chameleon({ newColor: \\"purple\\" });\\nfreddie.colorChange(\\"orange\\");\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["Lo que hace JS aqu\xed es registrar el objeto debido a que acabamos de crear un objeto vac\xedo en el objeto global. Cuando escribimos err\xf3neamente `greeting` como `greetign`, el int\xe9rprete de JS ve esto como `global.greetign = {}` (o `window.greetign = {}` en un navegador).","Para evitar esto, podemos usar el [\\"uso estricto\\"](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Modo_estricto). Esto asegura que se haya declarado una variable antes de establecerla igual a cualquier cosa."],"id":8,"options":["`{}`","`ReferenceErrorgreetign is not defined`","`undefined`"],"problem":"let greeting;\\ngreetign = {}; // Typo!\\nconsole.log(greetign);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["Esto es perfectamente posible en JavaScript, porque las funciones son objetos (Recuerda: **todo** aparte de los tipos primitivos son objetos en JS)","Una funci\xf3n es un tipo especial de objeto. El c\xf3digo que escribes t\xfa mismo no es la funci\xf3n real. La funci\xf3n es un objeto con propiedades. Esta propiedad es invocable."],"id":9,"options":["No pasa nada, es totalmente correcto.","`SyntaxError`. No es posible agregar propiedades a una funci\xf3n de esta manera.","`undefined`","`ReferenceError`"],"problem":"function bark() {\\n  console.log(\\"Woof!\\");\\n}\\n\\nbark.animal = \\"dog\\";\\n","question":"\xbfQu\xe9 ocurre cuando hacemos esto?"},{"answer":0,"explanation":["En JS no se pueden a\xf1adir propiedades a un constructor como se puede hacer con los objetos. Si se desea a\xf1adir una caracter\xedstica a todos los objetos a la vez, se debe utilizar el [prototipo](https://www.w3schools.com/js/js_object_prototypes.asp) en su lugar. As\xed que en este caso,","habr\xeda hecho que `member.getFullName()` funcionara. \xbfPor qu\xe9 es bueno? Imaginemos que a\xf1adimos este m\xe9todo al constructor. Quiz\xe1s no todas las \\"personas\\" necesitaban este m\xe9todo. Esto desperdiciar\xeda mucho espacio de memoria, ya que todav\xeda tendr\xedan esa propiedad, que ocupa espacio de memoria para cada caso. En cambio, si s\xf3lo lo a\xf1adimos al prototipo, s\xf3lo lo tenemos en un lugar en la memoria, \xa1pero todos ellos tienen acceso a \xe9l!"],"id":10,"options":["`TypeError`","`SyntaxError`","`Lydia Hallie`","`undefined` `undefined`"],"problem":"function Person(firstName, lastName) {\\n  this.firstName = firstName;\\n  this.lastName = lastName;\\n}\\n\\nconst member = new Person(\\"Lydia\\", \\"Hallie\\");\\nPerson.getFullName = function () {\\n  return `${this.firstName} ${this.lastName}`;\\n}\\n\\nconsole.log(member.getFullName());\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["Para `sarah`, no usamos la palabra reservada `new`. Cuando se usa `new`, se refiere al nuevo objeto vac\xedo que creamos. Sin embargo, si no se agrega `new\', se refiere al **objeto global**!","En el ejemplo `this.firstName` equivale a `\\"Sarah\\"` y `this.lastName` equivale a `\\"Smith\\"`. Lo que realmente hicimos fue definir `global.firstName = `Sarah\'` y `global.lastName = `Smith\'`. La misma `sarah` se deja `indefinida`."],"id":11,"options":["`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` and `undefined`","`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` and `Person {firstName\\"Sarah\\", lastName\\"Smith\\"}`","`Person {firstName\\"Lydia\\", lastName\\"Hallie\\"}` and `{}`","\\"Lydia\\", lastName\\"Hallie\\"}` and `ReferenceError`"],"problem":"function Person(firstName, lastName) {\\n  this.firstName = firstName;\\n  this.lastName = lastName;\\n}\\n\\nconst lydia = new Person(\\"Lydia\\", \\"Hallie\\");\\nconst sarah = Person(\\"Sarah\\", \\"Smith\\");\\n\\nconsole.log(lydia);\\nconsole.log(sarah);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":3,"explanation":["Durante la fase de **Capturing**, el evento pasa a trav\xe9s de los elementos ancestrales hasta el elemento objetivo. A continuaci\xf3n, alcanza el elemento **Target** y comienza el **bubbling**. M\xe1s informaci\xf3n [aqu\xed](https://www.sitepoint.com/event-bubbling-javascript/).","<img src=\\"https://i.imgur.com/N18oRgd.png\\" width=\\"200\\">"],"id":12,"options":["Target > Capturing > Bubbling","Bubbling > Target > Capturing","Target > Bubbling > Capturing","Capturing > Target > Bubbling"],"problem":"","question":"\xbfCu\xe1les son las tres fases de la propagaci\xf3n de eventos?"},{"answer":1,"explanation":["Todos los objetos tienen prototipos, excepto el **objeto base** (M\xe1s info [aqu\xed](https://stackoverflow.com/questions/56659303/what-is-base-object-in-javascript)). El componente tiene acceso a algunos m\xe9todos y propiedades, como `.toString`. Esta es la raz\xf3n principal por la que se puede utilizar los m\xe9todos JavaScript incorporados. Todos estos m\xe9todos est\xe1n disponibles en el prototipo. Aunque JavaScript no puede encontrar de manera directa en su objeto, baja por la cadena de prototipos y lo encuentra all\xed, lo que lo hace accesible para poder usarse posteriormente."],"id":13,"options":["true","false"],"problem":"","question":"All object have prototypes."},{"answer":2,"explanation":["JavaScript es un **lenguaje din\xe1micamente tipado** o de tipado d\xe9bil, esto significa que no es necesario declarar el tipo de variable antes de usarla pues ser\xe1 determinado autom\xe1ticamente cuando el programa comience a ser procesado. Los valores se pueden convertir autom\xe1ticamente en otro tipo sin que se sepa, esto se llama denomina _implicit type coercion_ (M\xe1s info [aqu\xed](https://medium.com/@ManuCastrillonM/entendiendo-la-coerci%C3%B3n-en-javascript-bc202d22d23f)). **La coerci\xf3n es la conversi\xf3n de un tipo a otro.**","En este ejemplo, JavaScript convierte el n\xfamero `1` en una cadena, para que la funci\xf3n tenga sentido y devuelva un valor. Durante la suma de un tipo num\xe9rico (`1`) y un tipo de cadena (`\'2\'`), el n\xfamero se trata como una cadena. Podemos concatenar cadenas como `\\"Hello\\" + \\"World\\"``, as\xed que lo que est\xe1 pasando aqu\xed es `\\"1\\" + \\"2\\"` que devuelve `\\"12\\"`"],"id":14,"options":["`NaN`","`TypeError`","`\\"12\\"`","`3`"],"problem":"function sum(a, b) {\\n  return a + b;\\n}\\n\\nsum(1, \\"2\\");\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["El operador **postfix** unario `++`:","Devuelve el valor (esto devuelve `0`)","Incrementa el valor (el n\xfamero es ahora `1`)","El operador unario **prefix** `++`:","Incrementa el valor (el n\xfamero es ahora `2`)","Devuelve el valor (esto devuelve `2`)","Por lo tanto, devuelve `0 2 2 2`."],"id":15,"options":["`1` `1` `2`","`1` `2` `2`","`0` `2` `2`","`0` `1` `2`"],"problem":"let number = 0;\\nconsole.log(number++);\\nconsole.log(++number);\\nconsole.log(number);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":1,"explanation":["_Tagged templates_ es un caso de uso de [template literals](https://codeburst.io/javascript-template-literals-tag-functions-for-beginners-758a041160e1). Una _plantilla etiquetada_ es una llamada de funci\xf3n que utiliza una plantilla literal de la que obtener sus argumentos. Si se usan literales de plantillas etiquetadas, el valor del primer argumento es siempre una matriz de los valores de las cadenas. El resto de los argumentos obtienen los valores de las expresiones pasadas.\\n</p>\\n</details>"],"id":16,"options":["`\\"Lydia\\"` `21` `[\\"\\", \\" is \\", \\" years old\\"]`","`[\\"\\", \\" is \\", \\" years old\\"]` `\\"Lydia\\"` `21`","`\\"Lydia\\"` `[\\"\\", \\" is \\", \\" years old\\"]` `21`"],"problem":"function getPersonInfo(one, two, three) {\\n  console.log(one);\\n  console.log(two);\\n  console.log(three);\\n}\\n\\nconst person = \\"Lydia\\";\\nconst age = 21;\\n\\ngetPersonInfo`${person} is ${age} years old`;\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Al probar la igualdad, las primitivas se comparan por su _valor_, mientras que los objetos se comparan por su _referencia_. JavaScript comprueba si los objetos tienen una referencia a la misma ubicaci\xf3n en la memoria.","Los dos objetos que estamos comparando no tienen eso: el objeto que pasamos como par\xe1metro se refiere a una ubicaci\xf3n diferente en la memoria que el objeto que usamos para comprobar la igualdad.","Esta es la raz\xf3n por la que ambos `{ edad: 18 } === { edad: 18 }` y `{ edad: 18 }} == { edad: 18 }` devuelven `false`"],"id":17,"options":["`You are an adult!`","`You are still an adult.`","`Hmm.. You don\'t have an age I guess`"],"problem":"function checkAge(data) {\\n  if (data === { age: 18 }) {\\n    console.log(\\"You are an adult!\\");\\n  } else if (data == { age: 18 }) {\\n    console.log(\\"You are still an adult.\\");\\n  } else {\\n    console.log(`Hmm.. You don\'t have an age I guess`);\\n  }\\n}\\n\\ncheckAge({ age: 18 });\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["El operador spread (`...args`.) devuelve un array con argumentos. Una matriz es un objeto, as\xed que `typeof args` devuelve `\\"object\\"`"],"id":18,"options":["`\\"number\\"`","`\\"array\\"`","`\\"object\\"`","`\\"NaN\\"`"],"problem":"function getAge(...args) {\\n  console.log(typeof args);\\n}\\n\\ngetAge(21);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Con `\\"use strict\\"`, es posible asegurarse de que no se declara accidentalmente variables globales. Nunca declaramos la variable `age`, y como usamos `\\"use strict\\"`, nos dar\xe1 un error de referencia. Si no hubi\xe9ramos usado `\\"use strict\\"`, habr\xeda funcionado, ya que la propiedad `age` se habr\xeda a\xf1adido al objeto global."],"id":19,"options":["`21`","`undefined`","`ReferenceError`","`TypeError`"],"problem":"function getAge() {\\n  \\"use strict\\";\\n  age = 21;\\n  console.log(age);\\n}\\n\\ngetAge();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["`eval` eval\xfaa los c\xf3digos que se pasan como una cadena. Si es una expresi\xf3n, como en este caso, eval\xfaa la expresi\xf3n. La expresi\xf3n es `10 * 10 + 5`. Esto devuelve el n\xfamero `105`."],"id":20,"options":["`105`","`\\"105\\"`","`TypeError`","`\\"10*10+5\\"`"],"problem":"const sum = eval(\\"10*10+5\\");\\n","question":"\xbfCu\xe1l es el valor de `sum`?"},{"answer":1,"explanation":["Los datos almacenados en `sessionStorage` se eliminan despu\xe9s de cerrar la pesta\xf1a.","Si se us\xf3 `localStorage`, los datos habr\xedan estado all\xed siempre, a menos que por ejemplo `localStorage.clear()` sea invocado."],"id":21,"options":["Para siempre, los datos no se pierden.","Cuando el usuario cierra la pesta\xf1a.","Cuando el usuario cierra todo el navegador, no s\xf3lo la pesta\xf1a.","Cuando el usuario apaga su ordenador."],"problem":"sessionStorage.setItem(\\"cool_secret\\", 123);\\n","question":"\xbfCu\xe1nto tiempo es accesible cool_secret?"},{"answer":1,"explanation":["Con la palabra reservada `var`, se pueden declarar m\xfaltiples variables con el mismo nombre. La variable tendr\xe1 entonces el \xfaltimo valor.","No es posible hacer esto con `let` o `const` ya que tienen un alcance de bloque."],"id":22,"options":["`8`","`10`","`SyntaxError`","`ReferenceError`"],"problem":"var num = 8;\\nvar num = 10;\\n\\nconsole.log(num);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Todas las claves de un objeto (excepto los s\xedmbolos) act\xfaan como cadenas, incluso si no son escritas como una cadena. Es por eso que `obj.hasOwnProperty(\'1\')` tambi\xe9n devuelve verdadero.","No funciona as\xed para un conjunto. No hay un \\"1\\" en nuestro set: `set.has(\'1\')` devuelve `falso`. Tiene el tipo num\xe9rico `1`, `set.has(1)` devuelve `true`."],"id":23,"options":["`false` `true` `false` `true`","`false` `true` `true` `true`","`true` `true` `false` `true`","`true` `true` `true` `true`"],"problem":"const obj = { 1: \\"a\\", 2: \\"b\\", 3: \\"c\\" };\\nconst set = new Set([1, 2, 3, 4, 5]);\\n\\nobj.hasOwnProperty(\\"1\\");\\nobj.hasOwnProperty(1);\\nset.has(\\"1\\");\\nset.has(1);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Si tiene dos claves con el mismo nombre, la clave ser\xe1 reemplazada. Seguir\xe1 estando en su primera posici\xf3n, pero con el \xfaltimo valor especificado"],"id":24,"options":["`{ a\\"one\\", b\\"two\\" }`","`{ b\\"two\\", a\\"three\\" }`","`{ a\\"three\\", b\\"two\\" }`","`SyntaxError`"],"problem":"const obj = { a: \\"one\\", b: \\"two\\", a: \\"three\\" };\\nconsole.log(obj);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["El contexto de ejecuci\xf3n base es el contexto de ejecuci\xf3n global: es accesible en todo el c\xf3digo."],"id":25,"options":["true","false","it depends"],"problem":"","question":"El contexto de ejecuci\xf3n de JS crea dos cosas: el objecto global y la palabra reservada \\"this\\"."},{"answer":2,"explanation":["La sentencia `continue` omite una iteraci\xf3n si una cierta condici\xf3n, en este caso `(i === 3)`,  devuelve `true`."],"id":26,"options":["`1` `2`","`1` `2` `3`","`1` `2` `4`","`1` `3` `4`"],"problem":"for (let i = 1; i < 5; i++) {\\n  if (i === 3) continue;\\n  console.log(i);\\n}\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["`String` es un constructor incorporado, al que podemos a\xf1adir propiedades. En este caso concreto, a\xf1adimos un m\xe9todo a su prototipo. Las cadenas primitivas se convierten autom\xe1ticamente en un objeto de cadena, generado por la funci\xf3n de prototipo de cadena. Por lo tanto, todas las cadenas (objetos de cadena) tienen acceso a ese m\xe9todo."],"id":27,"options":["`\\"Just give Lydia pizza already!\\"`","`TypeErrornot a function`","`SyntaxError`","`undefined`"],"problem":"String.prototype.giveLydiaPizza = () => {\\n  return \\"Just give Lydia pizza already!\\";\\n};\\n\\nconst name = \\"Lydia\\";\\n\\nname.giveLydiaPizza();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":1,"explanation":["Las claves se convierten autom\xe1ticamente en strings. Estamos tratando en este pregunta de establecer un objeto como clave para el objeto `a`, con el valor de `123`.","Sin embargo, cuando se _stringfy_ (compleja traducci\xf3n) un objeto, se convierte en `\\"[object Object]\\"`. As\xed que lo que estamos diciendo aqu\xed, es que `a[\\"object Object\\"] = 123`. Entonces, podemos intentar hacer lo mismo de nuevo. `c` es otro objeto que estamos impl\xedcitamente encadenando. Entonces, `a[\\"object Object\\"] = 456`.","Para finalizar, registramos `a[b]`, que en realidad es `a[\\"Object\\"]`. Acabamos de ponerlo en `456`, as\xed que devuelve `456`."],"id":28,"options":["`123`","`456`","`undefined`","`ReferenceError`"],"problem":"const a = {};\\nconst b = { key: \\"b\\" };\\nconst c = { key: \\"c\\" };\\n\\na[b] = 123;\\na[c] = 456;\\n\\nconsole.log(a[b]);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":1,"explanation":["Tenemos una funci\xf3n `setTimeout` y la invocamos primero. Sin embargo, fue el \xfaltimo en ser registrado.","Esto se debe a que en los navegadores, no s\xf3lo tenemos el motor de tiempo de ejecuci\xf3n, tambi\xe9n tenemos algo llamado `WebAPI`. El `WebAPI` nos da la funci\xf3n `setTimeout` para empezar, y por ejemplo el DOM.","Despu\xe9s de que la _callback_ es empujada a la WebAPI, la funci\xf3n `setTimeout` en s\xed misma (\xa1pero no la callback!) es removida de la pila.","<img src=\\"https://i.imgur.com/X5wsHOg.png\\" width=\\"200\\">","Ahora, `foo` es invocado, y ``\\"First\\"`` est\xe1 siendo registrado.","<img src=\\"https://i.imgur.com/Pvc0dGq.png\\" width=\\"200\\">","`Foo` se quita de la pila, y `Baz` es invocado. `Third` se registra.","<img src=\\"https://i.imgur.com/WhA2bCP.png\\" width=\\"200\\">","La WebAPI no puede simplemente a\xf1adir cosas a la pila cuando est\xe1 lista. En su lugar, empuja la funci\xf3n de devoluci\xf3n de llamada a algo llamado la _queue_ (cola en espa\xf1ol).","<img src=\\"https://i.imgur.com/NSnDZmU.png\\" width=\\"200\\">","Aqu\xed es donde un bucle de eventos comienza a funcionar. Un **lazo de evento** mira la pila y la cola de tareas. Si la pila est\xe1 vac\xeda, toma lo primero que encuentra en la cola y la empuja sobre la pila.","<img src=\\"https://i.imgur.com/uyiScAI.png\\" width=\\"200\\">","Se invoca el `bar`, se registra el `\\"Second\\"` y se quita de la pila."],"id":29,"options":["`First` `Second` `Third`","`First` `Third` `Second`","`Second` `First` `Third`","`Second` `Third` `First`"],"problem":"const foo = () => console.log(\\"First\\");\\nconst bar = () => setTimeout(() => console.log(\\"Second\\"));\\nconst baz = () => console.log(\\"Third\\");\\n\\nbar();\\nfoo();\\nbaz();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["El elemento anidado m\xe1s profundo que causa el evento es el destino de ese evento."],"id":30,"options":["Outer `div`","Inner `div`","`button`","An array of all nested elements."],"problem":"<div onclick=\\"console.log(\'first div\')\\">\\n  <div onclick=\\"console.log(\'second div\')\\">\\n    <button onclick=\\"console.log(\'button\')\\">\\n      Click!\\n    </button>\\n  </div>\\n</div>\\n","question":"\xbfCu\xe1l es la referencia al objeto que lanza el evento cuando se hace click en el bot\xf3n?"},{"answer":0,"explanation":["Si hacemos clic en `p`, vemos dos _outputs_: `p` y `div`. Durante la propagaci\xf3n del evento, hay 3 [fases](https://www.sitepoint.com/event-bubbling-javascript/): _capturing_, _target_ y _bubbling_. De forma predeterminada, los controladores de eventos se ejecutan en la fase uno (a menos que se establezca `useCapture` en `true`). Va desde el elemento anidado m\xe1s profundo hacia el exterior."],"id":31,"options":["`p` `div`","`div` `p`","`p`","`div`"],"problem":"<div onclick=\\"console.log(\'div\')\\">\\n  <p onclick=\\"console.log(\'p\')\\">\\n    Click here!\\n  </p>\\n</div>\\n","question":"Al hacer click en el p\xe1rrafo, \xbfqu\xe9 se muestra por pantalla?"},{"answer":3,"explanation":["En ambos  podemos pasar el objeto al que queremos que se refiera la palabra reservada `this`. Sin embargo, la diferencia es que `.call` es *ejecutado inmediatamente*!","`.bind` devuelve una copia de la funci\xf3n, pero con un contexto enlazado. Es decir, no se ejecuta de inmediato."],"id":32,"options":["`undefined is 21` `Lydia is 21`","`function` `function`","`Lydia is 21` `Lydia is 21`","`Lydia is 21` `function`"],"problem":"const person = { name: \\"Lydia\\" };\\n\\nfunction sayHi(age) {\\n  console.log(`${this.name} is ${age}`);\\n}\\n\\nsayHi.call(person, 21);\\nsayHi.bind(person, 21);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":1,"explanation":["La funci\xf3n `sayHi` devuelve el valor devuelto de la funci\xf3n invocada inmediatamente ([IIFE](https://developer.mozilla.org/es/docs/Glossary/IIFE)). Esta funci\xf3n devuelve `0`, que es el tipo `\\"number\\"`.","En JS solo hay 7 tipos incorporados (En ingl\xe9s se llaman _built-in types_, y pueden identificarse con el operador `typeof`. M\xe1s informaci\xf3n [aqu\xed](https://www.oreilly.com/library/view/you-dont-know/9781491905159/ch01.html)): `null`,` undefined`, `boolean`,` number`, `string`,` object` y `symbol`. `\\"function\\"` no es un tipo, ya que las funciones son objetos, es de tipo `\\"object\\"`."],"id":33,"options":["`\\"object\\"`","`\\"number\\"`","`\\"function\\"`","`\\"undefined\\"`"],"problem":"function sayHi() {\\n  return (() => 0)();\\n}\\n\\ntypeof sayHi();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["Solo hay seis valores falsos:","`undefined`","`null`","`NaN`","`0`","`\'\'` (cadena vac\xeda)","`false`","Los constructores de funciones, como `new Number` y `new Boolean` son correctos."],"id":34,"options":["`0`, `\'\'`, `undefined`","`0`, `new Number(0)`, `\'\'`, `new Boolean(false)`, `undefined`","`0`, `\'\'`, `new Boolean(false)`, `undefined`","All of them are falsy"],"problem":"0;\\nnew Number(0);\\n(\\"\\");\\n(\\" \\");\\nnew Boolean(false);\\nundefined;\\n","question":"\xbfCu\xe1les de estos valores son falsos?"},{"answer":1,"explanation":["`typeof 1` devuelve `\\"number\\" `.\\n`typeof \\"number\\"` devuelve `\\"string\\"`"],"id":35,"options":["`\\"number\\"`","`\\"string\\"`","`\\"object\\"`","`\\"undefined\\"`"],"problem":"console.log(typeof typeof 1);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Cuando se establece un valor en un elemento de una matriz que excede la longitud de la matriz, JS crea algo llamado \\"ranuras vac\xedas\\". Estos realmente tienen el valor de `undefined`, pero se podr\xe1 ver algo como:","`[1, 2, 3, 7 x empty, 11]`","dependiendo de d\xf3nde lo ejecute (es diferente para cada navegador, nodo, etc.)"],"id":36,"options":["`[1, 2, 3, 7 x null, 11]`","`[1, 2, 3, 11]`","`[1, 2, 3, 7 x empty, 11]`","`SyntaxError`"],"problem":"const numbers = [1, 2, 3];\\nnumbers[10] = 11;\\nconsole.log(numbers);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["El bloque `catch` recibe el argumento` x`. Este no es el mismo `x` que la variable cuando pasamos los argumentos. Esta variable `x` tiene un \xe1mbito de bloque.","M\xe1s adelante, establecemos esta variable de \xe1mbito de bloque igual a `1`, y establecemos el valor de la variable `y`. Ahora, registramos la variable de \xe1mbito de bloque `x`, que es igual a `1`.","Fuera del bloque `catch`,` x` sigue siendo `undefined`, e `y` es `2`. Cuando queremos `console.log (x)` fuera del bloque `catch`, devuelve `undefined`, y `y` devuelve` 2`."],"id":37,"options":["`1` `undefined` `2`","`undefined` `undefined` `undefined`","`1` `1` `2`","`1` `undefined` `undefined`"],"problem":"(() => {\\n  let x, y;\\n  try {\\n    throw new Error();\\n  } catch (x) {\\n    (x = 1), (y = 2);\\n    console.log(x);\\n  }\\n  console.log(x);\\n  console.log(y);\\n})();\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["JavaScript solo tiene tipos y objetos primitivos.","Los tipos primitivos son `boolean`, `null`, `undefined`, `bigint`, `number`, `string` y `symbol`.","Lo que diferencia a un tipo primitivo de un objeto es que los primeros no tienen propiedades o m\xe9todos; sin embargo, se puede ver que `\'foo\'.toUpperCase ()` se eval\xfaa como `\'FOO\'` y no da como resultado un `TypeError`. Esto se debe a que cuando se intenta acceder a una propiedad o m\xe9todo en un tipo primitivo, como una cadena, JavaScript envolver\xe1 impl\xedcitamente el objeto utilizando una de las clases de envoltura, por ejemplo `string`, y luego descartar\xe1 la envoltura inmediatamente despu\xe9s de evaluar la expresi\xf3n. Todas los tipos primitivos excepto `null` y `undefined` poseen este comportamiento."],"id":38,"options":["tipo primitivo o un objeto","funci\xf3n u objeto","\xa1pregunta trampa! solo objetos","n\xfamero u objeto"],"problem":"","question":"Todo en Javascript es o bien un(a).."},{"answer":2,"explanation":["`[1, 2]` es nuestro valor inicial. Este es el valor con el que empezamos y el valor del primer `acc`. Durante la primera ronda, `acc` es` [1,2] `, y `cur` es `[0, 1]`. Los concatenamos, lo que resulta en `[1, 2, 0, 1]`.","Entonces, `[1, 2, 0, 1]` es `acc` y` [2, 3]` es `cur`. Los concatenamos, y obtenemos `[1, 2, 0, 1, 2, 3]`"],"id":39,"options":["`[0, 1, 2, 3, 1, 2]`","`[6, 1, 2]`","`[1, 2, 0, 1, 2, 3]`","`[1, 2, 6]`"],"problem":"[[0, 1], [2, 3]].reduce(\\n  (acc, cur) => {\\n    return acc.concat(cur);\\n  },\\n  [1, 2]\\n);\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":1,"explanation":["`null` es falso. `! null` devuelve `true`. `! true` devuelve `false`.","`\\" \\"` es falso. `!\\" \\"` devuelve `true`. `! true` devuelve `false`.","\'1\' es verdadero. `! 1` devuelve `false`. `! false` devuelve `true`."],"id":40,"options":["`false` `true` `false`","`false` `false` `true`","`false` `true` `true`","`true` `true` `false`"],"problem":"!!null;\\n!!\\"\\";\\n!!1;\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":0,"explanation":["Devuelve una identificaci\xf3n \xfanica, un id \xfanico. Este id se puede usar para borrar ese intervalo con la funci\xf3n `clearInterval ()`."],"id":41,"options":["una id \xfanico","la cantidad de milisegundos especificada","la funci\xf3n pasada","`undefined`"],"problem":"setInterval(() => console.log(\\"Hi\\"), 1000);\\n","question":"\xbfQu\xe9 devuelveel m\xe9todo `setInterval`?"},{"answer":0,"explanation":["Una cadena es un iterable. El [operador de propagaci\xf3n](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/Spread_operator) asigna todos los caracteres de un iterable a un elemento."],"id":42,"options":["`[\\"L\\", \\"y\\", \\"d\\", \\"i\\", \\"a\\"]`","`[\\"Lydia\\"]`","`[[], \\"Lydia\\"]`","`[[\\"L\\", \\"y\\", \\"d\\", \\"i\\", \\"a\\"]]`"],"problem":"[...\\"Lydia\\"];\\n","question":"\xbfQu\xe9 devuelve la siguiente funci\xf3n?"},{"answer":2,"explanation":["Las funciones regulares no pueden pararse a mitad de ejecuci\xf3n despu\xe9s de invocarse. Sin embargo, una funci\xf3n generadora s\xed puede ser parada, y m\xe1s adelante continuar desde donde fue detenida. Cada vez que una funci\xf3n generadora encuentra un `yield`, la funci\xf3n cede el valor especificado despu\xe9s de \xe9l. Observa que la funci\xf3n generadora en este caso no _devuelve_ el valor, _cede_ el valor.","Primero, iniciamos la funci\xf3n generadora con `i` igual a `10`. Invocamos la funci\xf3n generadora usando el m\xe9todo `next()`. La primera vez que invocamos la funci\xf3n generadora, `i` es igual a `10`. Encuentra el primer `yield`: cede el valor de `i`. El generador est\xe1 ahora \\"pausado\\", y `10` es mostrado por consola.","Despu\xe9s, invocamos la funci\xf3n otra vez con el m\xe9todo `next()`. Contin\xfaa donde fue detenida previamente, todav\xeda con `i` igual a `10`. Ahora, encuentra el siguiente `yield`, y cede `i * 2`. `i` es igual a `10`, as\xed que devuelve `10 * 2`, que es `20`. Esto da como resultado `10, 20`."],"id":43,"options":["`[0, 10], [10, 20]`","`20, 20`","`10, 20`","`0, 10 y 10, 20`"],"problem":"function* generator(i) {\\n  yield i;\\n  yield i * 2;\\n}\\n\\nconst gen = generator(10);\\n\\nconsole.log(gen.next().value);\\nconsole.log(gen.next().value);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Cuando pasamos m\xfaltiples promesas al m\xe9todo `Promise.race`, resuelve/rechaza la _primera_ promesa que sea resuelta/rechazada. Para el m\xe9todo `setTimeout`, pasamos un cron\xf3metro: 500ms para la primera promesa (`firstPromise`), y 100ms para la segunda promesa (`secondPromise`). Esto significa que `secondPromise` se resuelve primero con el valor de `\'two\'`. `res` ahora guarda el valor `\'two\'`, el cual se muestra por consola."],"id":44,"options":["`\\"one\\"`","`\\"two\\"`","`\\"two\\" \\"one\\"`","`\\"one\\" \\"two\\"`"],"problem":"const firstPromise = new Promise((res, rej) => {\\n  setTimeout(res, 500, \\"one\\");\\n});\\n\\nconst secondPromise = new Promise((res, rej) => {\\n  setTimeout(res, 100, \\"two\\");\\n});\\n\\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));\\n","question":"\xbfQu\xe9 devuelve esto?"},{"answer":3,"explanation":["Primero, declaramos la variable `person` con el valor de un objeto que tiene una propiedad `name`.","<img src=\\"https://i.imgur.com/TML1MbS.png\\" width=\\"200\\">","Despu\xe9s, declaramos una variable llamada `members`. Asignamos el primer elemento de ese array igual al valor de la variable `person`. Un objeto interact\xfaa por _referencia_ cuando es asignado igual a otro objeto. Cuando asignas una referencia de una variable a otra, haces una _copia_ de esa referencia. (\xa1observa que no tienen la _misma_ referencia!)","<img src=\\"https://i.imgur.com/FSG5K3F.png\\" width=\\"300\\">","Despu\xe9s, asignamos que la variable `person` es igual a `null`.","<img src=\\"https://i.imgur.com/sYjcsMT.png\\" width=\\"300\\">","Solo estamos modificando el valor de la variable `person`, y no el primer elemento del array, ya que este elemento tiene una referencia diferente (copiada) al objeto. El primer elemento en `members` todav\xeda mantiene su referencia hacia el objeto original. Cuando mostramos por consola el array `members`, el primer elemento todav\xeda mantiene el valor del objeto, el cual se muestra por consola."],"id":45,"options":["`null`","`[null]`","`[{}]`","`[{ name\\"Lydia\\" }]`"],"problem":"let person = { name: \\"Lydia\\" };\\nconst members = [person];\\nperson = null;\\n\\nconsole.log(members);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Con un bucle `for-in`, podemos iterar sobre claves de objetos, en este caso `name` y `age`. Internamente, las claves de objetos son strings (si no son Symbol). En cada bucle, asignamos `item` igual a la clave actual que se est\xe1 iterando. Primero, `item` es igual a `name`, y se muestra por consola. Despu\xe9s, `item` es igual a `age`, que se muestra por consola."],"id":46,"options":["`{ name\\"Lydia\\" }, { age21 }`","`\\"name\\", \\"age\\"`","`\\"Lydia\\", 21`","`[\\"name\\", \\"Lydia\\"], [\\"age\\", 21]`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n};\\n\\nfor (const item in person) {\\n  console.log(item);\\n}\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["La asociatividad de operadores es el orden en el que el compilador eval\xfaa las expresiones, ya sea de izquierda a derecha o de derecha a izquierda. Esto solo pasa si todos los operadores tienen la _misma_ precedencia. Solo tenemos un tipo de operador: `+`. Para la suma, la asociatividad es de izquierda a derecha.","`3 + 4` se eval\xfaa primero. Esto da como resultado el n\xfamero `7`.","`7 + \'5\'` da `\\"75\\"` por la coerci\xf3n. JavaScript convierte el n\xfamero `7` a string, mira la pregunta 15. Podemos concatenar dos strings usando el operador `+`. `7 + \'5\'` da como resultado `\\"75\\"`."],"id":47,"options":["`\\"345\\"`","`\\"75\\"`","`12`","`\\"12\\"`"],"problem":"console.log(3 + 4 + \\"5\\");\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Solo el primer n\xfamero en el string es devuelto. Seg\xfan en la _base_ seleccionada (el segundo argumento para especificar a qu\xe9 tipo de n\xfamero queremos transformarlo: base 10, hexadecimal, octal, binario, etc.), el `parseInt` comprueba si los caracteres del string son v\xe1lidos. Una vez encuentra un caracter que no es un n\xfamero v\xe1lido en la base seleccionada, deja de recorrer el string e ignora los siguientes caracteres.","`*` no es un n\xfamero v\xe1lido. Solo convierte `\\"7\\"` al decimal `7`. `num` tiene el valor `7`."],"id":48,"options":["`42`","`\\"42\\"`","`7`","`NaN`"],"problem":"const num = parseInt(\\"7*6\\", 10);\\n","question":"\xbfCu\xe1l es el valor de `num`?"},{"answer":2,"explanation":["Cuando se mapea sobre un array, el valor de `num` es igual al elemento que se est\xe1 iterando. En este caso, los elementos son n\xfameros, por lo que la condici\xf3n del if `typeof num === \\"number\\"` devuelve `true`. La funci\xf3n de mapeo crea un nuevo array e inserta los valores devueltos por la funci\xf3n.","Sin embargo, no devolvemos un valor. Cuando no devolvemos un valor desde la funci\xf3n, la funci\xf3n devuelve `undefined`. Para cada elemento en el array, la funci\xf3n de bloque es llamada, as\xed que por cada elemento devolvemos `undefined`."],"id":49,"options":["`[]`","`[null, null, null]`","`[undefined, undefined, undefined]`","`[ 3 huecos vac\xedos ]`"],"problem":"[1, 2, 3].map(num => {\\n  if (typeof num === \\"number\\") return;\\n  return num * 2;\\n});\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Los argumentos son pasados por _valor_, a no ser que su valor sea un objeto, en cuyo caso con pasados por _referencia_. `birthYear` es pasado por valor, ya que es un string, no un objeto. Cuando pasamos argumentos por valor, una _copia_ de ese valor es creada (ver pregunta 46).","La variable `birthYear` tiene una referencia al valor `\\"1997\\"`. El argumento `year` tambi\xe9n tiene una referencia al valor `\\"1997\\"`, pero no es el mismo valor al que `birthYear` referencia. Cuando actualizamos el valor de `year` igual\xe1ndolo a `\\"1998\\"`, solo estamos actualizando el valor de `year`. `birthYear` todav\xeda es igual a `\\"1997\\"`.","El valor de `person` es un objeto. El argumento `member` tiene una referencia (copiada) al _mismo_ objeto. Cuando modificamos la propiedad a la que el objeto `member` referencia, el valor de `person` tambi\xe9n ser\xe1 modificado, ya que ambos tienen una referencia al mismo objeto. La propiedad `name` de `person` es ahora igual al valor `\\"Lydia\\"`."],"id":50,"options":["`{ name\\"Lydia\\" }, \\"1997\\"`","`{ name\\"Sarah\\" }, \\"1998\\"`","`{ name\\"Lydia\\" }, \\"1998\\"`","`{ name\\"Sarah\\" }, \\"1997\\"`"],"problem":"function getInfo(member, year) {\\n  member.name = \\"Lydia\\";\\n  year = \\"1998\\";\\n}\\n\\nconst person = { name: \\"Sarah\\" };\\nconst birthYear = \\"1997\\";\\n\\ngetInfo(person, birthYear);\\n\\nconsole.log(person, birthYear);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["Con la sentencia `throw`, podemos crear errores personalizados. Con esta sentencia, puedes lanzar excepciones. Una excepci\xf3n puede ser un <b>string</b>, un <b>n\xfamero</b>, un <b>boolean</b> o un <b>objeto</b>. En este caso, nuestra excepci\xf3n es el string `\'Hello world\'`.","Con la sentencia `catch`, podemos especificar qu\xe9 queremos hacer si una excepci\xf3n es lanzada en el bloque `try`. Se lanza una excepci\xf3n: el string `\'Hello world\'`. `e` es ahora igual a ese string, el cual se muestra por consola. Esto da como resultado `\'Oh an error: Hello world\'`."],"id":51,"options":["`\\"It worked! Hello world!\\"`","`\\"Oh no an error! undefined`","`SyntaxErrorcan only throw Error objects`","`\\"Oh no an error! Hello world!`"],"problem":"function greeting() {\\n  throw \\"Hello world!\\";\\n}\\n\\nfunction sayHi() {\\n  try {\\n    const data = greeting();\\n    console.log(\\"It worked!\\", data);\\n  } catch (e) {\\n    console.log(\\"Oh no an error!\\", e);\\n  }\\n}\\n\\nsayHi();\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Cuando devuelves una propiedad, el valor de la propiedad es igual al valor _retornado_, no el valor indicado en el constructor de la funci\xf3n. Devolvemos el string `\\"Maserati\\"`, por lo que `myCar.make` es igual a `\\"Maserati\\"`."],"id":52,"options":["`\\"Lamborghini\\"`","`\\"Maserati\\"`","`ReferenceError`","`TypeError`"],"problem":"function Car() {\\n  this.make = \\"Lamborghini\\";\\n  return { make: \\"Maserati\\" };\\n}\\n\\nconst myCar = new Car();\\nconsole.log(myCar.make);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["`let x = y = 10;` es en realidad una forma m\xe1s corta de escribir:","Cuando asignamos `y` igual a `10`, en realidad a\xf1adimos una propiedad `y` al objeto global (`window` en navegador, `global` en Node). En un navegador, `window.y` es ahora igual a `10`.","Despu\xe9s, declaramos una variable `x` con el valor de `y`, el cual es `10`. Las variables declaradas con `let` tienen _alcance de bloque_, solo son definidas dentro del bloque en el que son declaradas; las expresiones de funci\xf3n ejecutadas inmediatamente (IIFE por sus siglas en ingl\xe9s) en este caso. Cuando usamos el operador `typeof`, el operando `x` no est\xe1 definido: estamos intentando acceder a `x` fuera del bloque en el que es declarado. Esto significa que `x` no est\xe1 definido. Los valores a los que no se les ha asignado un valor o que no han sido declarados son de tipo `\\"undefined\\"`. `console.log(typeof x)` devuelve `\\"undefined\\"`.","Sin embargo, hemos creado una variable global `y` cuando la hemos igualado a `10`. Este valor es accesible desde cualquier parte en nuestro c\xf3digo. `y` es definida, y tiene un valor de tipo `\\"number\\"`. `console.log(typeof y)` devuelve `\\"number\\"`."],"id":53,"options":["`\\"undefined\\", \\"number\\"`","`\\"number\\", \\"number\\"`","`\\"object\\", \\"number\\"`","`\\"number\\", \\"undefined\\"`"],"problem":"(() => {\\n  let x = (y = 10);\\n})();\\n\\nconsole.log(typeof x);\\nconsole.log(typeof y);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Podemos borrar propiedades de objetos usando `delete`, tambi\xe9n en el prototipo (prototype). Borrando una propiedad en el prototipo, hace que no vuelva a estar disponible en la cadena de prototipo. En este caso, la funci\xf3n `bark` deja de estar disponible en el prototipo despu\xe9s de `delete Dog.prototype.bark`, pero a\xfan intentamos acceder a ella.","Cuando intentamos invocar algo que no es una funci\xf3n, un `TypeError` es lanzado. En este caso `TypeError: pet.bark is not a function`, ya que `pet.bark` es `undefined`."],"id":54,"options":["`\\"Woof I am Mara\\"`, `TypeError`","`\\"Woof I am Mara\\"`, `\\"Woof I am Mara\\"`","`\\"Woof I am Mara\\"`, `undefined`","`TypeError`, `TypeError`"],"problem":"class Dog {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n}\\n\\nDog.prototype.bark = function() {\\n  console.log(`Woof I am ${this.name}`);\\n};\\n\\nconst pet = new Dog(\\"Mara\\");\\n\\npet.bark();\\n\\ndelete Dog.prototype.bark;\\n\\npet.bark();\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["El objeto `Set` es una colecci\xf3n de valores _\xfanicos_: un valor solo puede aparecer una vez en un set.","Pasamos el iterable `[1, 1, 2, 3, 4]` con el valor `1` duplicado. Como no podemos tener dos valores iguales en el set, uno de ellos es eliminado. Esto da como resultado `{1, 2, 3, 4}`."],"id":55,"options":["`[1, 1, 2, 3, 4]`","`[1, 2, 3, 4]`","`{1, 1, 2, 3, 4}`","`{1, 2, 3, 4}`"],"problem":"const set = new Set([1, 1, 2, 3, 4]);\\n\\nconsole.log(set);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Un m\xf3dulo importado es de _solo lectura_: no puedes modificar el m\xf3dulo importado. Solo el m\xf3dulo que los exporta puede cambiar su valor.","Cuando intentamos incrementar el valor de `myCounter`, lanza un error: `myCounter` es de solo lectura y no puede ser modificado."],"id":56,"options":["`10`","`11`","`Error`","`NaN`"],"problem":"// counter.js\\nlet counter = 10;\\nexport default counter;\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["El operador `delete` devuelve un valor booleano: `true` en una eliminaci\xf3n exitosa, sino devolver\xe1 `false`. Sin embargo, las variables declaradas con `var`, `const` o `let` no pueden ser borradas usando el operador `delete`.","La variable `name` se declara con `const`, por lo que su eliminaci\xf3n no es exitosa: se devuelve `false`. Cuando asignamos `age` igual a `21`, en realidad hemos a\xf1adido una propiedad llamada `age` al objeto global. Puedes borrar exitosamente propiedades de objetos de esta forma, tambi\xe9n del objeto global, as\xed que `delete age` devuelve `true`."],"id":57,"options":["`false`, `true`","`\\"Lydia\\"`, `21`","`true`, `true`","`undefined`, `undefined`"],"problem":"const name = \\"Lydia\\";\\nage = 21;\\n\\nconsole.log(delete name);\\nconsole.log(delete age);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Podemos desempaquetar valores de arrays o propiedades de objetos con desestructuraci\xf3n. Por ejemplo:","<img src=\\"https://i.imgur.com/ADFpVop.png\\" width=\\"200\\">","El valor de `a` es ahora `1`, y el valor de `b` es ahora `2`. Lo que realmente se hizo en la pregunta es:","<img src=\\"https://i.imgur.com/NzGkMNk.png\\" width=\\"200\\">","Esto significa que el valor de `y` es igual al primer valor del array, el cual es el n\xfamero `1`. Cuando mostramos por consola `y`, `1` es devuelto."],"id":58,"options":["`[[1, 2, 3, 4, 5]]`","`[1, 2, 3, 4, 5]`","`1`","`[1]`"],"problem":"const numbers = [1, 2, 3, 4, 5];\\nconst [y] = numbers;\\n\\nconsole.log(y);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Se pueden combinar objetos usando el operador de propagaci\xf3n `...`. Te permite crear copias de los pares clave/valor de un objeto, y a\xf1adirlos a otro objeto. En este caso, creamos copias del objeto `user`, y las a\xf1adimos al objeto `admin`. El objeto `admin` ahora contiene los pares clave/valor copiados, lo cual da como resultado `{ admin: true, name: \\"Lydia\\", age: 21 }`."],"id":59,"options":["`{ admintrue, user{ name\\"Lydia\\", age21 } }`","`{ admintrue, name\\"Lydia\\", age21 }`","`{ admintrue, user[\\"Lydia\\", 21] }`","`{ admintrue }`"],"problem":"const user = { name: \\"Lydia\\", age: 21 };\\nconst admin = { admin: true, ...user };\\n\\nconsole.log(admin);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Con el m\xe9todo `defineProperty`, podemos a\xf1adir nuevas propiedades a un objeto, o modificar las existentes. Cuando a\xf1adimos una propiedad a un objeto usando el m\xe9todo `defineProperty`, es por defecto _no enumerable_. El m\xe9todo `Object.keys` devuelve todos los nombres de propiedades _enumerables_ de un objeto, en este caso solo `\\"name\\"`.","Las propiedades a\xf1adidas usando el m\xe9todo `defineProperty` son inmutables por defecto. Puedes sobrescribir este comportamiento usando las propiedades `writable`, `configurable` y `enumerable`. De esta forma, el m\xe9todo `defineProperty` te da mucho m\xe1s control sobre las propiedades que est\xe1s a\xf1adiendo a un objeto."],"id":60,"options":["`{ name\\"Lydia\\", age21 }`, `[\\"name\\", \\"age\\"]`","`{ name\\"Lydia\\", age21 }`, `[\\"name\\"]`","`{ name\\"Lydia\\"}`, `[\\"name\\", \\"age\\"]`","`{ name\\"Lydia\\"}`, `[\\"age\\"]`"],"problem":"const person = { name: \\"Lydia\\" };\\n\\nObject.defineProperty(person, \\"age\\", { value: 21 });\\n\\nconsole.log(person);\\nconsole.log(Object.keys(person));\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["El segundo argumento de `JSON.stringify` es el _replacer_ (reemplazador). El reemplazador puede ser una funci\xf3n o un array, y te permite controlar qu\xe9 y c\xf3mo deber\xedan convertirse los valores a string.","Si el reemplazador es un _array_, solo los nombres de las propiedades incluidos en el array ser\xe1n agregados al string JSON. En este caso, solo las propiedades con nombres `\\"level\\"` y `\\"health\\"` son incluidas, `\\"username\\"` es excluido. `data` es ahora igual a `\\"{\\"level\\":19, \\"health\\":90}\\"`.","Si el reemplazador es una _funci\xf3n_, esta funci\xf3n es llamada en cada propiedad en el objeto que est\xe1s convirtiendo a string. El valor retornado por esta funci\xf3n ser\xe1 el valor de la propiedad cuando es a\xf1adida al string JSON. Si el valor es `undefined`, esta propiedad es excluida del string JSON."],"id":61,"options":["`\\"{\\"level\\":19, \\"health\\":90}\\"`","`\\"{\\"username\\"\\"lydiahallie\\"}\\"`","`\\"[\\"level\\", \\"health\\"]\\"`","`\\"{\\"username\\"\\"lydiahallie\\", \\"level\\":19, \\"health\\":90}\\"`"],"problem":"const settings = {\\n  username: \\"lydiahallie\\",\\n  level: 19,\\n  health: 90\\n};\\n\\nconst data = JSON.stringify(settings, [\\"level\\", \\"health\\"]);\\nconsole.log(data);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["El operador unario `++` _devuelve primero_ el valor del operando, _y despu\xe9s incrementa_ el valor del operando. El valor de `num1` es `10`, ya que la funci\xf3n `increaseNumber` primero devuelve el valor de `num`, que es `10`, y solo incrementa el valor de `num` despu\xe9s.","`num2` es `10`, ya que pasamos `num1` a `increasePassedNumber`. `number` es igual a `10` (el valor de `num1`. Una vez m\xe1s, el operador unario `++` _primero devuelve_ el valor del operando, _y despu\xe9s incrementa_ el valor del operando. El valor de `number` es `10`, as\xed que `num2` es igual a `10`."],"id":62,"options":["`10`, `10`","`10`, `11`","`11`, `11`","`11`, `12`"],"problem":"let num = 10;\\n\\nconst increaseNumber = () => num++;\\nconst increasePassedNumber = number => number++;\\n\\nconst num1 = increaseNumber();\\nconst num2 = increasePassedNumber(num1);\\n\\nconsole.log(num1);\\nconsole.log(num2);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["En ES6, podemos inicializar par\xe1metros con un valor por defecto. El valor del par\xe1metro ser\xe1 el valor por defecto si no se pasa otro valor a la funci\xf3n, o si el valor del par\xe1metro es `\\"undefined\\"`. En este caso, propagamos las propiedades del objeto `value` en un nuevo objeto, por lo que `x` tiene el valor por defecto de `{ number: 10 }`.","\xa1El argumento por defecto es evaluado _cuando es llamado_! Cada vez que llamamos a la funci\xf3n, un _nuevo_ objeto es creado. Invocamos la funci\xf3n `multiply` las dos primeras veces sin pasar un valor: `x` tiene el valor por defecto de `{ number: 10 }`. Despu\xe9s mostramos por consola el valor multiplicado de ese n\xfamero, que es `20`.","La tercera vez que invocamos `multiply`, pasamos un argumento: el objeto llamado `value`. El operador `*=` es en realidad una forma corta de escribir `x.number = x.number * 2`: modificamos el valor de `x.number` y mostramos por consola el valor multiplicado de `20`.","La cuarta vez, pasamos el objeto `value` otra vez. `x.number` fue previamente modificado a `20`, por lo que `x.number *= 2` devuelve `40`."],"id":63,"options":["`20`, `40`, `80`, `160`","`20`, `40`, `20`, `40`","`20`, `20`, `20`, `40`","`NaN`, `NaN`, `20`, `40`"],"problem":"const value = { number: 10 };\\n\\nconst multiply = (x = { ...value }) => {\\n  console.log((x.number *= 2));\\n};\\n\\nmultiply();\\nmultiply();\\nmultiply(value);\\nmultiply(value);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["El primer argumento que el m\xe9todo `reduce` recibe es el _acumulador_, `x` en este caso. El segundo argumento es el _valor actual_, `y`. Con el m\xe9todo `reduce`, podemos ejecutar una funci\xf3n de callback en cada elemento en el array, lo cual puede resultar en un \xfanico valor al final.","En este ejemplo, no estamos devolviendo ning\xfan valor, simplemente estamos mostrando por consola los valores del acumulador y del valor actual.","El valor del acumulador es igual al valor previamente devuelto por la funci\xf3n de callback. Si no pasas el argumento opcional `initialValue` al m\xe9todo `reduce`, el acumulador es igual al primer elemento de la primera llamada.","En la primera llamada, el acumulador (`x`) es `1`, y el valor actual (`y`) es `2`. No devolvemos desde la funci\xf3n de callback, mostramos por consola el acumulador y el valor actual: se muestra `1` y `2`.","Si no devuelves un valor de una funci\xf3n, se devuelve `undefined`. En la siguiente llamada, el acumulador es `undefined`, y el valor actual es `3`. Se muestra por consola `undefined` y `3`.","En la cuarta llamada, otra vez no devolvemos desde la funci\xf3n de callback. El acumulador es una vez m\xe1s `undefined`, y el valor actual es `4`. Se muestra por consola `undefined` y `4`."],"id":64,"options":["`1` `2` y `3` `3` y `6` `4`","`1` `2` y `2` `3` y `3` `4`","`1` `undefined` y `2` `undefined` y `3` `undefined` y `4` `undefined`","`1` `2` y `undefined` `3` y `undefined` `4`"],"problem":"[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["En una clase derivada, no puedes acceder a `this` antes de llamar a `super`. Si intentas hacerlo, se lanzar\xe1 un `ReferenceError`: 1 y 4 lanzar\xedan este error.","Con `super`, llamamos al constructor del padre con unos argumentos. El constructor del padre recibe el argumento `name`, por lo que necesitamos pasar `name` a `super`.","La clase `Labrador` recibe dos argumentos, `name` porque extiende de `Dog`, y `size` como una propiedad adicional en la clase `Labrador`. Ambos necesitan ser pasados al constructor de `Labrador`, lo cual se realiza correctamente usando el constructor 2."],"id":65,"options":["1","2","3","4"],"problem":"class Dog {\\n  constructor(name) {\\n    this.name = name;\\n  }\\n};\\n\\nclass Labrador extends Dog {\\n  // 1 \\n  constructor(name, size) {\\n    this.size = size;\\n  }\\n  // 2\\n  constructor(name, size) {\\n    super(name);\\n    this.size = size;\\n  }\\n  // 3\\n  constructor(size) {\\n    super(name);\\n    this.size = size;\\n  }\\n  // 4 \\n  constructor(name, size) {\\n    this.name = name;\\n    this.size = size;\\n  }\\n\\n};\\n","question":"\xbfCon qu\xe9 constructor podemos extender correctamente la clase `Dog`?"},{"answer":1,"explanation":["Con `import`, todos los m\xf3dulos importados son _pre-convertidos_. Esto significa que los m\xf3dulos importados son ejecutados _primero_, y el c\xf3digo en el fichero que importa el m\xf3dulo se ejecuta _despu\xe9s_.","\xa1Esto es una diferencia existente entre `require()` en CommonJS e `import`! Con `require()`, puedes cargar dependencias bajo demanda mientras el c\xf3digo est\xe1 siendo ejecutado. Si hubi\xe9ramos usado `require` en lugar de `import`, se habr\xeda mostrado por consola `running index.js`, `running sum.js`, `3`."],"id":66,"options":["`running index.js`, `running sum.js`, `3`","`running sum.js`, `running index.js`, `3`","`running sum.js`, `3`, `running index.js`","`running index.js`, `undefined`, `running sum.js`"],"problem":"// index.js\\nconsole.log(\'running index.js\');\\nimport { sum } from \'./sum.js\';\\nconsole.log(sum(1, 2));\\n\\n// sum.js\\nconsole.log(\'running sum.js\');\\nexport const sum = (a, b) => a + b;\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Cada Symbol es completamente \xfanico. El prop\xf3sito del argumento pasado a Symbol es para darle una descripci\xf3n. El valor de Symbol no depende del argumento pasado. Como se comprueba igualdad, estamos creando dos Symbol completamente nuevos: el primer `Symbol(\'foo\')`, y el segundo `Symbol(\'foo\')`. Estos dos valores son \xfanicos y no iguales, `Symbol(\'foo\') === Symbol(\'foo\')` devuelve `false`."],"id":67,"options":["`true`, `true`, `false`","`false`, `true`, `false`","`true`, `false`, `true`","`true`, `true`, `true`"],"problem":"console.log(Number(2) === Number(2))\\nconsole.log(Boolean(false) === Boolean(false))\\nconsole.log(Symbol(\'foo\') === Symbol(\'foo\'))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Con el m\xe9todo `padStart`, podemos a\xf1adir relleno al principio de un string. El valor pasado a este m\xe9todo es la longitud _total_ del string incluyendo el relleno. El string `\\"Lydia Hallie\\"` tiene una longitud de `12`. `name.padStart(13)` inserta 1 espacio al principio del string, porque 12 + 1 es 13.","Si el argumento pasado al m\xe9todo `padStart` es m\xe1s peque\xf1o que la longitud del string, no se a\xf1ade relleno."],"id":68,"options":["`\\"Lydia Hallie\\"`, `\\"Lydia Hallie\\"`","`\\"           Lydia Hallie\\"`, `\\"  Lydia Hallie\\"` (`\\"[13 espacios en blanco]Lydia Hallie\\"`, `\\"[2 espacios en blanco]Lydia Hallie\\"`)","`\\" Lydia Hallie\\"`, `\\"Lydia Hallie\\"` (`\\"[1 espacio en blanco]Lydia Hallie\\"`, `\\"Lydia Hallie\\"`)","`\\"Lydia Hallie\\"`, `\\"Lyd\\"`,"],"problem":"const name = \\"Lydia Hallie\\"\\nconsole.log(name.padStart(13))\\nconsole.log(name.padStart(2))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Con el operador `+` puedes concatenar strings. En este caso, estamos concatenando el string `\\"\ud83e\udd51\\"` con el string `\\"\ud83d\udcbb\\"`, lo que da como resultado `\\"\ud83e\udd51\ud83d\udcbb\\"`."],"id":69,"options":["`\\"\ud83e\udd51\ud83d\udcbb\\"`","`257548`","Un string con una secuencia de puntos de c\xf3digo","Error"],"problem":"console.log(\\"\ud83e\udd51\\" + \\"\ud83d\udcbb\\");\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Una funci\xf3n generadora \\"pausa\\" su ejecuci\xf3n cuando ve un `yield`. Primero, tenemos que dejar a la funci\xf3n ceder el string \\"Do you love JavaScript?\\", lo cual se puede hacer llamando a `game.next().value`.","Todas las l\xedneas son ejecutadas, hasta que encuentra el primer `yield`. Hay un `yield` en la primera l\xednea dentro de la funci\xf3n: \xa1la ejecuci\xf3n se para en el primer yield! _\xa1Esto significa que la variable `answer` todav\xeda no est\xe1 definida!_","Cuando llamamos a `game.next(\\"Yes\\").value`, el `yield` anterior se reemplaza con el valor de los par\xe1metros pasados en la funci\xf3n `next()`, `\\"Yes\\"` en este caso. El valor de la variable `answer` es ahora igual a `\\"Yes\\"`. La condici\xf3n del if devuelve `false`, y `JavaScript loves you back \u2764\ufe0f` se muestra por consola."],"id":70,"options":["`game.next(\\"Yes\\").value` y `game.next().value`","`game.next.value(\\"Yes\\")` y `game.next.value()`","`game.next().value` y `game.next(\\"Yes\\").value`","`game.next.value()` y `game.next.value(\\"Yes\\")`"],"problem":"function* startGame() {\\n  const answer = yield \\"Do you love JavaScript?\\";\\n  if (answer !== \\"Yes\\") {\\n    return \\"Oh wow... Guess we\'re gone here\\";\\n  }\\n  return \\"JavaScript loves you back \u2764\ufe0f\\";\\n}\\n\\nconst game = startGame();\\nconsole.log(/* 1 */); // Do you love JavaScript?\\nconsole.log(/* 2 */); // JavaScript loves you back \u2764\ufe0f\\n","question":"\xbfC\xf3mo puedes mostrar por consola los valores comentados junto a las sentencias console.log?"},{"answer":2,"explanation":["`String.raw` devuelve un string donde las secuencias de escape (`\\\\n`, `\\\\v`, `\\\\t` etc.) son ignoradas. Las contrabarras pueden ser un problema ya que puedes acabar con algo como:","`` const path = `C:\\\\Documents\\\\Projects\\\\table.html` ``","Que resultar\xeda en:","`\\"C:DocumentsProjects able.html\\"`","Con `String.raw`, simplemente ignorar\xeda las secuencias de escape e imprimir\xeda:","`C:\\\\Documents\\\\Projects\\\\table.html`","En este caso, el string es `Hello\\\\nworld`, que es lo que se muestra por consola."],"id":71,"options":["`Hello world!`","`Hello` <br />&nbsp; &nbsp; &nbsp;`world`","`Hello\\\\nworld`","`Hello\\\\n` <br /> &nbsp; &nbsp; &nbsp;`world`"],"problem":"console.log(String.raw`Hello\\\\nworld`);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Una funci\xf3n as\xedncrona siempre devuelve una promesa. El `await` todav\xeda tiene que esperar a que la promesa se resuelva: cuando llamamos a `getData()` para asignarle que es igual a `data`, se devuelve una promesa pendiente.","Si quisi\xe9ramos tener acceso al valor resuelto `\\"I made it\\"`, tendr\xedamos que haber usado el m\xe9todo `.then()` en `data`:","`data.then(res => console.log(res))`","Esto habr\xeda mostrado por consola `\\"I made it!\\"`"],"id":72,"options":["`\\"I made it!\\"`","`Promise {<resolved>\\"I made it!\\"}`","`Promise {<pending>}`","`undefined`"],"problem":"async function getData() {\\n  return await Promise.resolve(\\"I made it!\\");\\n}\\n\\nconst data = getData();\\nconsole.log(data);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["\xa1El m\xe9todo `.push()` devuelve la _longitud_ del nuevo array! Al principio, el array conten\xeda un elemento (el string `\\"banana\\"`) y ten\xeda una longitud de `1`. Despu\xe9s de a\xf1adir el string `\\"apple\\"` al array, el array contiene dos elementos, y tiene una longitud de `2`. Esto es lo que devuelve la funci\xf3n `addToList`.","El m\xe9todo `push` modifica el array original. Si quisieras devolver el _array_ de la funci\xf3n en lugar de la _longitud del array_ deber\xedas haber devuelto `list` despu\xe9s de introducir `item` en \xe9l."],"id":73,"options":["`[\'apple\', \'banana\']`","`2`","`true`","`undefined`"],"problem":"function addToList(item, list) {\\n  return list.push(item);\\n}\\n\\nconst result = addToList(\\"apple\\", [\\"banana\\"]);\\nconsole.log(result);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["`Object.freeze` congela e imposibilita la adici\xf3n, eliminaci\xf3n o modificaci\xf3n de las propiedades de un objeto (a no ser que el valor de la propiedad sea otro objeto).","Cuando creamos la variable `shape` y la igualamos al objeto congelado `box`, `shape` tambi\xe9n referencia al objeto congelado. Puedes comprobar si un objeto est\xe1 congelado usando `Object.isFrozen`. En este caso, `Object.isFrozen(shape)` devuelve `true`, ya que la variable `shape` tiene una referencia a un objeto congelado.","Como `shape` est\xe1 congelado, y como el valor de `x` no es un objeto, no podemos modificar la propiedad `x`. `x` es todav\xeda igual a `10`, y `{ x: 10, y: 20 }` se muestra por consola."],"id":74,"options":["`{ x100, y20 }`","`{ x10, y20 }`","`{ x100 }`","`ReferenceError`"],"problem":"const box = { x: 10, y: 20 };\\n\\nObject.freeze(box);\\n\\nconst shape = box;\\nshape.x = 100;\\n\\nconsole.log(shape);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["Cuando desempaquetamos la propiedad `name` del objeto de la parte derecha, asignamos su valor `\\"Lydia\\"` a una variable con el nombre `myName`.","Con `{ name: myName }`, le decimos a JavaScript que queremos crear una nueva variable llamada `myName` con el valor de la propiedad `name` de la parte derecha.","Como intentamos mostrar por consola `name`, una variable que no est\xe1 definida, se lanza un `ReferenceError`."],"id":75,"options":["`\\"Lydia\\"`","`\\"myName\\"`","`undefined`","`ReferenceError`"],"problem":"const { name: myName } = { name: \\"Lydia\\" };\\n\\nconsole.log(name);\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Una funci\xf3n pura es una funci\xf3n que _siempre_ devuelve el mismo resultado, si se le pasan los mismos argumentos.","La funci\xf3n `sum` siempre devuelve el mismo resultado. Si pasamos `1` y `2`, _siempre_ devuelve `3` sin efectos secundarios. Si pasamos `5` y `10`, _siempre_ devuelve `15`, etc\xe9tera. Esta es la definici\xf3n de una funci\xf3n pura."],"id":76,"options":["S\xed","No"],"problem":"function sum(a, b) {\\n  return a + b;\\n}\\n","question":"\xbfEsta es una funci\xf3n pura?"},{"answer":2,"explanation":["La funci\xf3n `add` es una funci\xf3n _memoizada_. Con la memoizaci\xf3n, podemos guardar en cach\xe9 los resultados de una funci\xf3n para acelerar su ejecuci\xf3n. En este caso, creamos el objeto `cache` que guarda los valores previamente retornados.","Si llamamos a la funci\xf3n `addFunction` otra vez con el mismo argumento, primero comprueba si ya tiene ese valor en su cach\xe9. Si es el caso, se devuelve el valor de la cach\xe9. Si no est\xe1 en la cach\xe9, calcular\xe1 el valor y lo almacenar\xe1 justo despu\xe9s.","Llamamos a la funci\xf3n `addFunction` tres veces con el mismo valor: en la primera invocaci\xf3n, el valor de la funci\xf3n cuando `num` es igual a `10` no est\xe1 en cach\xe9 todav\xeda. La condici\xf3n del if `num in cache` devuelve `false`, y se ejecuta el bloque `else`: `Calculated! 20` se muestra por consola, y el valor del resultado se a\xf1ade al objeto `cache`. `cache` ahora contiene `{ 10: 20 }`.","La segunda vez, el objeto `cache` contiene el valor que se devuelve para `10`. La condici\xf3n del if `num in cache` devuelve `true`, y se muestra por consola `\'From cache! 20\'`.","La tercera vez, pasamos `5 * 2` a la funci\xf3n, que se eval\xfaa como `10`. El objeto `cache` contiene el valor que se devuelve para `10`. La condici\xf3n del if `num in cache` devuelve `true`, y se muestra por consola `\'From cache! 20\'`."],"id":77,"options":["`Calculated! 20` `Calculated! 20` `Calculated! 20`","`Calculated! 20` `From cache! 20` `Calculated! 20`","`Calculated! 20` `From cache! 20` `From cache! 20`","`Calculated! 20` `From cache! 20` `Error`"],"problem":"const add = () => {\\n  const cache = {};\\n  return num => {\\n    if (num in cache) {\\n      return `From cache! ${cache[num]}`;\\n    } else {\\n      const result = num + 10;\\n      cache[num] = result;\\n      return `Calculated! ${result}`;\\n    }\\n  };\\n};\\n\\nconst addFunction = add();\\nconsole.log(addFunction(10));\\nconsole.log(addFunction(10));\\nconsole.log(addFunction(5 * 2));\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Con el bucle _for-in_, podemos iterar sobre propiedades **enumerables**. En un array, las propiedades enumerables son las \\"claves\\" de los elementos del array, las cuales son sus \xedndices. Puedes ver el array como:","`{0: \\"\u2615\\", 1: \\"\ud83d\udcbb\\", 2: \\"\ud83c\udf77\\", 3: \\"\ud83c\udf6b\\"}`","Donde las claves son las propiedades enumerables. `0` `1` `2` `3` se muestran por consola.","Con un bucle _for-of_, podemos iterar sobre **iterables**. Un array es un iterable. Cuando iteramos sobre un array, la variable \\"item\\" es igual al elemento sobre el que se est\xe1 iterando en ese momento, `\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"` se muestra por consola."],"id":78,"options":["`0` `1` `2` `3` y `\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"`","`\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"` y `\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"`","`\\"\u2615\\"` ` \\"\ud83d\udcbb\\"` `\\"\ud83c\udf77\\"` `\\"\ud83c\udf6b\\"` y `0` `1` `2` `3`"," `0` `1` `2` `3` y `{0\\"\u2615\\", 1\\"\ud83d\udcbb\\", 2\\"\ud83c\udf77\\", 3\\"\ud83c\udf6b\\"}`"],"problem":"const myLifeSummedUp = [\\"\u2615\\", \\"\ud83d\udcbb\\", \\"\ud83c\udf77\\", \\"\ud83c\udf6b\\"]\\n\\nfor (let item in myLifeSummedUp) {\\n  console.log(item)\\n}\\n\\nfor (let item of myLifeSummedUp) {\\n  console.log(item)\\n}\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Los elementos de un array pueden contener cualquier valor. N\xfameros, strings,objetos, otros arrays, null, valores booleanos, undefined, y otras expresiones como fechas, funciones o c\xe1lculos.","El elemento ser\xe1 igual al valor retornado. `1 + 2` devuelve `3`, `1 * 2` devuelve `2`, y `1 / 2` devuelve `0.5`."],"id":79,"options":["`[\\"1 + 2\\", \\"1 * 2\\", \\"1 / 2\\"]`","`[\\"12\\", 2, 0.5]`","`[3, 2, 0.5]`"," `[1, 1, 1]`"],"problem":"const list = [1 + 2, 1 * 2, 1 / 2]\\nconsole.log(list)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Por defecto, los argumentos tienen el valor `undefined`, a no ser que un valor haya sido pasado a la funci\xf3n. En este caso, no pasamos ning\xfan valor para el argumento `name`. `name` es igual a `undefined`, que es mostrado por consola.","En ES6, podemos sobrescribir este valor `undefined` por defecto con par\xe1metros por defecto. Por ejemplo:","`function sayHi(name = \\"Lydia\\") { ... }`","En ese caso, si no pas\xe1ramos un valor o si pas\xe1ramos `undefined`, `name` siempre ser\xeda igual al string `Lydia`."],"id":80,"options":["`Hi there, `","`Hi there, undefined`","`Hi there, null`"," `ReferenceError`"],"problem":"function sayHi(name) {\\n  return `Hi there, ${name}`\\n}\\n\\nconsole.log(sayHi())\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["El valor de `this` depende de d\xf3nde lo uses. En un m\xe9todo, como el m\xe9todo `getStatus`, `this` referencia al _objeto al que el m\xe9todo pertenece_. El m\xe9todo pertenece al objeto `data`, por lo que `this` referencia al objeto `data`. Cuando mostramos por consola `this.status`, la propiedad `status` en el objeto `data` es mostrada por consola, la cual es `\\"\ud83e\udd51\\"`.","Con el m\xe9todo `call`, podemos cambiar el objeto al cual `this` referencia. En **funciones**, el `this` referencia al _objeto al que la funci\xf3n pertenece_, por lo que dentro de la funci\xf3n `setTimeout`, el `this` referencia al _objeto global_. En el objeto global, hay una variable llamada _status_ con el valor `\\"\ud83d\ude0e\\"`. Cuando se muestra `this.status` por consola, `\\"\ud83d\ude0e\\"` aparece por pantalla."],"id":81,"options":["`\\"\ud83e\udd51\\"` y `\\"\ud83d\ude0d\\"`","`\\"\ud83e\udd51\\"` y `\\"\ud83d\ude0e\\"`","`\\"\ud83d\ude0d\\"` y `\\"\ud83d\ude0e\\"`","`\\"\ud83d\ude0e\\"` y `\\"\ud83d\ude0e\\"`"],"problem":"var status = \\"\ud83d\ude0e\\"\\n\\nsetTimeout(() => {\\n  const status = \\"\ud83d\ude0d\\"\\n\\n  const data = {\\n    status: \\"\ud83e\udd51\\",\\n    getStatus() {\\n      return this.status\\n    }\\n  }\\n\\n  console.log(data.getStatus())\\n  console.log(data.getStatus.call(this))\\n}, 0)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Asignamos a la variable `city` el valor de la propiedad `city` del objeto `person`. No existe ninguna propiedad en este objeto llamada `city`, por lo que la variable `city` tiene el valor `undefined`.","\xa1Observa que _no_ estamos referenciando al objeto `person` en s\xed mismo! Solo asignamos a la variable `city` el valor actual de la propiedad `city` del objeto `person`.","Despu\xe9s, asignamos a la variable `city` el string `\\"Amsterdam\\"`. Esto no cambia el objeto `person`: no hay ninguna referencia a ese objeto.","Cuando se muestra por consola el objeto `person`, se devuelve el objeto sin modificar."],"id":82,"options":["`{ name\\"Lydia\\", age21 }`","`{ name\\"Lydia\\", age21, city\\"Amsterdam\\" }`","`{ name\\"Lydia\\", age21, cityundefined }`","`\\"Amsterdam\\"`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n}\\n\\nlet city = person.city\\ncity = \\"Amsterdam\\"\\n\\nconsole.log(person)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Las variables con `const` y `let` tienen _alcance de bloque_. Un bloque es cualquier cosa entre llaves (`{ }`). En este caso, las llaves del if/else. No puedes referenciar a una variable fuera del bloque en el que es declarada, se lanza un `ReferenceError`."],"id":83,"options":["`\\"Sorry, you\'re too young.\\"`","`\\"Yay! You\'re old enough!\\"`","`ReferenceError`","`undefined`"],"problem":"function checkAge(age) {\\n  if (age < 18) {\\n    const message = \\"Sorry, you\'re too young.\\"\\n  } else {\\n    const message = \\"Yay! You\'re old enough!\\"\\n  }\\n\\n  return message\\n}\\n\\nconsole.log(checkAge(21))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["El valor de `res` en el segundo `.then` es igual al valor retornado por el `.then` anterior. Puedes seguir encadenando `.then` como este, pasando el valor al siguiente manejador."],"id":84,"options":["El resultado del m\xe9todo `fetch`.","El resultado de la segunda invocaci\xf3n del m\xe9todo `fetch`.","El resultado de callback en el `.then()` anterior.","Ser\xeda siempre `undefined`."],"problem":"fetch(\'https://www.website.com/api/user/1\')\\n  .then(res => res.json())\\n  .then(res => console.log(res))\\n","question":"\xbfQu\xe9 tipo de informaci\xf3n se mostrar\xe1 por consola?"},{"answer":0,"explanation":["Con `!!name`, determinamos si el valor de `name` es convertible a verdadero o convertible a falso. Si `name` es convertible a verdadero, `!name` devuelve `false`. `!false` (el cual es pr\xe1cticamente lo mismo que `!!name`) devuelve `true`.","Asign\xe1ndole a `hasName` el valor de `name`, asignas a `hasName` cualquier valor que se haya pasado a la funci\xf3n `getName`, no el valor booleano `true`.","`new Boolean(true)` devuelve un envoltorio (wrapper), no el valor booleano en s\xed.","`name.length` devuelve la longitud del argumento pasado, no si es `true`."],"id":85,"options":["`!!name`","`name`","`new Boolean(name)`","`name.length`"],"problem":"function getName(name) {\\n  const hasName = //\\n}\\n","question":"\xbfQu\xe9 opci\xf3n es una forma de igualar `hasName` a `true`, teniendo en cuenta que no se puede pasar `true` como argumento?"},{"answer":1,"explanation":["Para obtener un caracter en un \xedndice espec\xedfico en un string, puedes usar corchetes. El primer caracter en el string tiene \xedndice 0, y as\xed sucesivamente. En este caso queremos obtener el elemento cuyo \xedndice es 0, el caracter `\\"I\\"`, el cual se muestra por consola.","Observa que este m\xe9todo no est\xe1 soportado en IE7 y versiones anteriores. En ese caso, usamos `.charAt()`."],"id":86,"options":["`\\"\\"\\"`","`\\"I\\"`","`SyntaxError`","`undefined`"],"problem":"console.log(\\"I want pizza\\"[0])\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Puedes asignar un valor por defecto para un par\xe1metro que sea igual a otro par\xe1metro de la funci\xf3n, siempre y cuando haya sido definido _antes_ del par\xe1metro por defecto. Pasamos el valor `10` a la funci\xf3n `sum`. Si la funci\xf3n `sum` solamente recibe 1 argumento, significa que el valor para `num2` no ha sido pasado, y el valor de `num1` es igual al valor `10` que hemos pasado en este caso. El valor por defecto de `num2` es el valor de `num1`, el cual es `10`. `num1 + num2` devuelve `20`.","Si estuvieras intentando asignar un valor por defecto a un par\xe1metro igual a otro par\xe1metro que es definido _despu\xe9s_ (a la derecha), el valor del par\xe1metro no habr\xeda sido inicializado todav\xeda, lo cual lanzar\xeda un error."],"id":87,"options":["`NaN`","`20`","`ReferenceError`","`undefined`"],"problem":"function sum(num1, num2 = num1) {\\n  console.log(num1 + num2)\\n}\\n\\nsum(10)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Con la sintaxis `import * as name`, importamos _todas las exportaciones_ del fichero `module.js` al fichero `index.js` creando un nuevo objeto llamado `data`. En el fichero `module.js` hay dos exportaciones: la exportaci\xf3n por defecto y una exportaci\xf3n con nombre. La exportaci\xf3n por defecto es una funci\xf3n que devuelve el string `\\"Hello World\\"`, y la exportaci\xf3n con nombre es una variable llamada `name` que tiene el valor del string `\\"Lydia\\"`.","El objeto `data` tiene una propiedad `default` para la exportaci\xf3n por defecto, el resto de propiedades tienen los nombres de las exportaciones con nombre y sus respectivos valores."],"id":88,"options":["`{ defaultfunction default(), name\\"Lydia\\" }`","`{ defaultfunction default() }`","`{ default\\"Hello world\\", name\\"Lydia\\" }`","Objeto global de `module.js`"],"problem":"// module.js \\nexport default () => \\"Hello world\\"\\nexport const name = \\"Lydia\\"\\n\\n// index.js \\nimport * as data from \\"./module\\"\\n\\nconsole.log(data)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Las clases son az\xfacar sint\xe1ctico para los constructores de funciones. El equivalente a la clase `Person` como constructor de funci\xf3n ser\xeda:","Llamar a un constructor de funciones con `new` crea una instancia de `Person`, `typeof` devuelve `\\"object\\"` con una instancia. `typeof member` devuelve `\\"object\\"`."],"id":89,"options":["`\\"class\\"`","`\\"function\\"`","`\\"object\\"`","`\\"string\\"`"],"problem":"class Person {\\n  constructor(name) {\\n    this.name = name\\n  }\\n}\\n\\nconst member = new Person(\\"John\\")\\nconsole.log(typeof member)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["El m\xe9todo `.push` devuelve la _nueva longitud_ del array, \xa1no el array en s\xed mismo! Asignando `newList` igual a `[1, 2, 3].push(4)`, estamos asignando `newList` igual a la nueva longitud del array: `4`.","Despu\xe9s, intentamos usar el m\xe9todo `.push` en `newList`. Como `newList` es el valor num\xe9rico `4`, no podemos usar el m\xe9todo `.push`: se lanza un `TypeError`."],"id":90,"options":["`[1, 2, 3, 4, 5]`","`[1, 2, 3, 5]`","`[1, 2, 3, 4]`","`Error`"],"problem":"let newList = [1, 2, 3].push(4)\\n\\nconsole.log(newList.push(5))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["Las funciones regulares, como la funci\xf3n `giveLydiaPizza`, tienen la propiedad `prototype`, la cual es un objeto (objeto de prototipo) con una propiedad `constructor`. Sin embargo las funciones flecha, como la funci\xf3n `giveLydiaChocolate`, no tienen esta propiedad `prototype`. Se devuelve `undefined` cuando se intenta acceder a la propiedad `prototype` usando `giveLydiaChocolate.prototype`."],"id":91,"options":["`{ constructor...}` `{ constructor...}`","`{}` `{ constructor...}`","`{ constructor...}` `{}`","`{ constructor...}` `undefined`"],"problem":"function giveLydiaPizza() {\\n  return \\"Here is pizza!\\"\\n}\\n\\nconst giveLydiaChocolate = () => \\"Here\'s chocolate... now go hit the gym already.\\"\\n\\nconsole.log(giveLydiaPizza.prototype)\\nconsole.log(giveLydiaChocolate.prototype)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["`Object.entries(person)` devuelve un array de arrays anidados, conteniendo claves y objetos:","`[ [ \'name\', \'Lydia\' ], [ \'age\', 21 ] ]`","Usando el bucle `for-of`, podemos iterar sobre cada elemento en el array, los subarrays en este caso. Podemos desestructurar los subarrays instant\xe1neamente en el bucle for-of, usando `const [x, y]`. `x` es igual al primer elemento del subarray, `y` es igual al segundo elemento en el subarray.","El primer subarray es `[ \\"name\\", \\"Lydia\\" ]`, con `x` igual a `\\"name\\"` e `y` igual a `\\"Lydia\\"`, lo cual es mostrado por consola.","El segundo subarray es `[ \\"age\\", 21 ]`, con `x` igual a `\\"age\\"` e `y` igual a `21`, lo cual es mostrado por consola."],"id":92,"options":["`name` `Lydia` y `age` `21`","`[\\"name\\", \\"Lydia\\"]` y `[\\"age\\", 21]`","`[\\"name\\", \\"age\\"]` y `undefined`","`Error`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n}\\n\\nfor (const [x, y] of Object.entries(person)) {\\n  console.log(x, y)\\n}\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["`...args` es un par\xe1metro rest. El valor del par\xe1metro rest es un array que contiene el resto de argumentos, \xa1**y solo puede ser el \xfaltimo par\xe1metro**! En este ejemplo, el par\xe1metro rest es el segundo par\xe1metro. Esto no es correcto y lanzar\xe1 un error de sintaxis.","El ejemplo de arriba s\xed que funciona. Devuelve el array `[ \'banana\', \'apple\', \'orange\', \'pear\' ]`\\n</p>\\n</details>"],"id":93,"options":["`[\\"banana\\", \\"apple\\", \\"pear\\", \\"orange\\"]`","`[[\\"banana\\", \\"apple\\"], \\"pear\\", \\"orange\\"]`","`[\\"banana\\", \\"apple\\", [\\"pear\\"], \\"orange\\"]`","`SyntaxError`"],"problem":"function getItems(fruitList, ...args, favoriteFruit) {\\n  return [...fruitList, ...args, favoriteFruit]\\n}\\n\\ngetItems([\\"banana\\", \\"apple\\"], \\"pear\\", \\"orange\\")\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["En JavaScript, no _tenemos_ que escribir el punto y coma (`;`) de forma explicita, sin embargo el motor de JavaScript todav\xeda las a\xf1ade al final de cada sentencia. Esto se denomina **Insercci\xf3n autom\xe1tica de punto y coma**. Una sentencia puede ser, por ejemplo, variables, o palabras clave como `throw`, `return`, `break`, etc.","Aqui, escribimos una sentencia `return`, y otra sentencia de valor `a + b` en una _nueva l\xednea_. Sin embargo, como es una l\xednea nueva, el motor no sabe que en realidad es el valor que quer\xedamos devolver. En cambio, a\xf1adi\xf3 autom\xe1ticamente un punto y coma despu\xe9s de `return`. Puedes ver esto como:","Esto significa que nunca se alcanza `a + b`, ya que una funci\xf3n deja de ejecutarse despu\xe9s de la palabra clave` return`. Si no se devuelve ning\xfan valor, como aqu\xed, la funci\xf3n devuelve `undefined`. \xa1Ten en cuenta que no hay inserci\xf3n autom\xe1tica despu\xe9s de las sentencias `if/else`!"],"id":94,"options":["`a is bigger`, `6` y `b is bigger`, `3`","`a is bigger`, `undefined` y `b is bigger`, `undefined`","`undefined` y `undefined`","`SyntaxError`"],"problem":"function nums(a, b) {\\n  if\\n  (a > b)\\n  console.log(\'a is bigger\')\\n  else \\n  console.log(\'b is bigger\')\\n  return \\n  a + b\\n}\\n\\nconsole.log(nums(4, 2))\\nconsole.log(nums(1, 2))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["Podemos establecer clases iguales a otros constructures de clases/funciones. En este caso, establecemos `Person` igual a `AnotherPerson`. El nombre en este constructor es `Sarah`, por lo que la propiedad nombre en la nueva instancia de `Person` de `member` es `\\"Sarah\\"`."],"id":95,"options":["`\\"Lydia\\"`","`\\"Sarah\\"`","`Errorcannot redeclare Person`","`SyntaxError`"],"problem":"class Person {\\n  constructor() {\\n    this.name = \\"Lydia\\"\\n  }\\n}\\n\\nPerson = class AnotherPerson {\\n  constructor() {\\n    this.name = \\"Sarah\\"\\n  }\\n}\\n\\nconst member = new Person()\\nconsole.log(member.name)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":3,"explanation":["Un s\xedmbolo no es _enumerable_. El m\xe9todo Object.keys devuelve todas las propiedades _enumerables_ de un objeto. El s\xedmbolo no ser\xe1 visible, y un array vac\xedo ser\xe1 devuelto. Cuando se imprime el objeto completo, se mostrar\xe1n todas las propiedades, incluidas las no-enumerables.","Esta es una de las muchas cualidades de un s\xedmbolo: adem\xe1s de representar un valor completamente \xfanico (que evita la colisi\xf3n accidental de nombres en los objetos, por ejemplo, cuando se utilizan 2 bibliotecas que desean agregar propiedades al mismo objeto), tambi\xe9n puedes \\"ocultar\\" propiedades en los objetos de esta manera (aunque no del todo. Todav\xeda puedes acceder a los s\xedmbolos utilizando el m\xe9todo `Object.getOwnPropertySymbols()`)."],"id":96,"options":["`{Symbol(\'a\')\'b\'}` y `[\\"{Symbol(\'a\')\\"]`","`{}` y `[]`","`{ a\\"b\\" }` y `[\\"a\\"]`","`{Symbol(\'a\')\'b\'}` y `[]`"],"problem":"const info = {\\n  [Symbol(\'a\')]: \'b\'\\n}\\n\\nconsole.log(info)\\nconsole.log(Object.keys(info))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["La funci\xf3n `getList` recibe un array argumento. Entre los par\xe9ntesis de la funci\xf3n `getList`, desestructuramos este array de inmediato. Podr\xedas ver esto como:","`[x, ...y] = [1, 2, 3, 4]`","Con el par\xe1metro rest `...y`, ponemos todos los argumentos \\"restantes\\" en un array. Los argumentos restantes son `2`, `3` and `4` en este caso. El valor de `y` es un array, conteniendo todos los par\xe1metros restantes. El valor de `x` es igual a `1` en este caso, por la tanto cuando registramos `[x, y]`, se imprime `[1, [2, 3, 4]]`.","La funci\xf3n `getUser` recibe un objeto. Con las funciones flecha, no _tenemos_ que escribir llaves cuando simplemente devolvemos un valor. Sin embargo, si quieres devolver un _objeto_ desde una funci\xf3n llave, tienes que escribir el objeto entre par\xe9ntesis, \xa1de otra manera no se devuelve ning\xfan valor! La siguiente funci\xf3n habr\xeda devuelto un objeto:","```const getUser = user => ({ name: user.name, age: user.age })```","Como no se devuelve ning\xfan valor en este caso, la funci\xf3n devuelve `undefined`."],"id":97,"options":["`[1, [2, 3, 4]]` y `undefined`","`[1, [2, 3, 4]]` y `{ name\\"Lydia\\", age21 }`","`[1, 2, 3, 4]` y `{ name\\"Lydia\\", age21 }`","`Error` y `{ name\\"Lydia\\", age21 }`"],"problem":"const getList = ([x, ...y]) => [x, y]\\nconst getUser = user => { name: user.name, age: user.age }\\n\\nconst list = [1, 2, 3, 4]\\nconst user = { name: \\"Lydia\\", age: 21 }\\n\\nconsole.log(getList(list))\\nconsole.log(getUser(user))\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["La variable `name` contiene el valor de una cadena, que no es una funci\xf3n, por lo tanto no puede invocar.","Se genera una excepci\xf3n de tipo TypeError cuando un valor no es del tipo esperado. JavaScript esperaba que `name` fuera una funci\xf3n ya que estamos intentando invocarla. Era una cadena sin embargo, por lo tanto se lanza una excepci\xf3n del tipo TypeError: name is not a function!","Se lanzan errores del tipo SyntaxError cuando has escrito algo que no es v\xe1lido JavaScript, pro ejemplo cuando has escrito `return` como `retrun`. \\nSe lanzan errores del tipo ReferenceError cuando JavaScript no puede encontrar una referencia a un valor al que est\xe1s intentando acceder."],"id":98,"options":["`SyntaxError`","`ReferenceError`","`TypeError`","`undefined`"],"problem":"const name = \\"Lydia\\"\\n\\nconsole.log(name())\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":1,"explanation":["`[]` es un valor verdadero (se convierte a un valor verdadero en un contexto booleano). Con el operador `&&`, se devolver\xe1 el valor de la derecha si el valor de la izquierda es un valor verdadero. En este caso, el valor de la izquierda `[]` es un valor verdadero, por lo tanto se devuelve `\\"Im\'`.","`\\"\\"` es un valor falso (se convierte a un valor falso en un contexto booleano). Si el valor de la izquierda es falso, no se devuelve nada. `n\'t` no se devuelve."],"id":99,"options":["`possible! You should see a therapist after so much JavaScript lol`","`Impossible! You should see a therapist after so much JavaScript lol`","`possible! You shouldn\'t see a therapist after so much JavaScript lol`","`Impossible! You shouldn\'t see a therapist after so much JavaScript lol`"],"problem":"// \ud83c\udf89\u2728 This is my 100th question! \u2728\ud83c\udf89\\n\\nconst output = `${[] && \'Im\'}possible!\\nYou should${\'\' && `n\'t`} see a therapist after so much JavaScript lol`\\n","question":"\xbfCu\xe1l es el valor de la salida?"},{"answer":2,"explanation":["Con el operador `||`, podemos devolver el primer operando verdadero. Si todos los valores son falsos, se devuelve el \xfaltimo operando.","`(false || {} || null)`: el objecto vac\xedo `{}` es un valor verdadero. Este es el primero (y \xfanico) valor verdadero, que se devuelve. `one` es igual a `{}`.","`(null || false || \\"\\")`: todos los operandos son valores falsos. Esto significa que el \xfaltimo operando, `\\"\\"` es devuelto. `two` es igual a `\\"\\"`.","`([] || 0 || \\"\\")`: el array vac\xedo `[]` es un valor verdadero. Este es el primer valor verdadero, que se devuelve. `three` es igual a `[]`."],"id":100,"options":["`false` `null` `[]`","`null` `\\"\\"` `true`","`{}` `\\"\\"` `[]`","`null` `null` `true`"],"problem":"const one = (false || {} || null)\\nconst two = (null || false || \\"\\")\\nconst three = ([] || 0 || true)\\n\\nconsole.log(one, two, three)\\n","question":"\xbfCu\xe1l es el valor de la salida?"},{"answer":3,"explanation":["Con una promesa, b\xe1sicamente decimos _Quiero ejecutar esta funci\xf3n, pero la dejar\xe9 a un lado por ahora mientras se est\xe1 ejecutando, ya que esto puede llevar un tiempo. Solo cuando se resuelve (o se rechaza) un cierto valor, y cuando la pila de llamadas est\xe1 vac\xeda, quiero usar este valor._","Podemos obtener este valor con las palabras clave `.then` y `await` en una funci\xf3n `async`. Aunque podemos obtener el valor de una promesa tanto con `.then` como con` wait \', funcionan de manera un poco diferente.","En la funci\xf3n `firstFunction`, dejamos (de alg\xfan modo) a un lado la funci\xf3n myPromise mientras se estaba ejecutando, y seguimos ejecutando el otro c\xf3digo, que es `console.log(\'second\')` en este caso. Luego, la funci\xf3n se resolvi\xf3 con la cadena `I have resolved`, que luego se imprimi\xf3 una vez que pila de llamadas qued\xf3 vac\xeda.","Con la palabra clave await en `secondFunction`, literalmente hacemos una pausa en la ejecuci\xf3n de una funci\xf3n as\xedncrona hasta que el valor se haya resuelto antes de pasar a la siguiente l\xednea de c\xf3digo.","Esto significa que se esper\xf3 a que `myPromise` resolviera con el valor `I have resolved`, y solo una vez que eso sucedi\xf3, pasamos a la siguiente l\xednea: `second` que se imprime."],"id":101,"options":["`I have resolved!`, `second` y `I have resolved!`, `second`","`second`, `I have resolved!` y `second`, `I have resolved!`","`I have resolved!`, `second` y `second`, `I have resolved!`","`second`, `I have resolved!` y `I have resolved!`, `second`"],"problem":"const myPromise = () => Promise.resolve(\'I have resolved!\')\\n\\nfunction firstFunction() {\\n  myPromise().then(res => console.log(res))\\n  console.log(\'second\')\\n}\\n\\nasync function secondFunction() {\\n  console.log(await myPromise())\\n  console.log(\'second\')\\n}\\n\\nfirstFunction()\\nsecondFunction()\\n","question":"\xbfCu\xe1l es el valor de la salida?"},{"answer":2,"explanation":["El operador `+` no solo se usa para sumar valores num\xe9ricos, sino que tambi\xe9n podemos usarlo para concatenar cadenas. Cada vez que el motor de JavaScript ve que uno o m\xe1s valores no son un n\xfamero, coerce el n\xfamero en una cadena.","El primero es `1`, que es un valor num\xe9rico. `1 + 2` devuelve el n\xfamero 3.","Sin embargo, el segundo es la cadena `\\"Lydia\\"`. `\\"Lydia\\"` es una cadena y `2` es un n\xfamero: `2` coerce a una cadena. `\\"Lydia\\"` y `\\"2\\"` son concatenados, cuyo resultado es la cadena `\\"Lydia2\\"`.","`{ name: \\"Lydia\\" }` es un objeto. Ni un n\xfamero ni un objeto son una cadena, as\xed que se convierten a cadena ambos. Cada vez que convertimos un objeto estandar, se convierte en `\\"[Object object]\\"`. `\\"[Object object]\\"` concatenado con `\\"2\\"` resulta en `\\"[Object object]2\\"`."],"id":102,"options":["`3`, `NaN`, `NaN`","`3`, `7`, `NaN`","`3`, `Lydia2`, `[Object object]2`","`\\"12\\"`, `Lydia2`, `[Object object]2`"],"problem":"const set = new Set()\\n\\nset.add(1)\\nset.add(\\"Lydia\\")\\nset.add({ name: \\"Lydia\\" })\\n\\nfor (let item of set) {\\n  console.log(item + 2)\\n}\\n","question":"\xbfCu\xe1l es el valor de la salida?"},{"answer":2,"explanation":["Podemos pasar cualquier tipo de valor que queramos a `Promise.resolve`, ya sea una promesa o no promesa. El m\xe9todo en s\xed mismo devuelve una promesa con el valor resuelto. Si pasas una funci\xf3n estandar, ser\xe1 una promesa resuelta con un valor normal. Si pasas una promesa, ser\xe1 una promesa resuelta con el valor resuelto de esa promesa pasada.","En este caso, acabamos de pasar el valor num\xe9rico `5`. Devuelve una promesa resuelta con el valor `5`."],"id":103,"options":["`5`","`Promise {<pending>5}`","`Promise {<resolved>5}`","`Error`"],"problem":"Promise.resolve(5)\\n","question":"\xbfCu\xe1l es el valor?"},{"answer":1,"explanation":["Los objetos se pasan por referencia. Cuando verificamos la igualdad estricta de los objetos (`===`), estamos comparando sus referencias.","Establecemos el valor por defecto para `person2` igual al objeto `person`, y pasamos el objeto `person` como el valor de `person1`.","Esto significa que ambos valores tienen una referencia al mismo punto en la memoria, por lo tanto, son iguales.","El bloque de c\xf3digo en la instrucci\xf3n `else` se ejecuta, y se imprime `They are the same!`."],"id":104,"options":["`Not the same!`","`They are the same!`","`ReferenceError`","`SyntaxError`"],"problem":"function compareMembers(person1, person2 = person) {\\n  if (person1 !== person2) {\\n    console.log(\\"Not the same!\\")\\n  } else {\\n    console.log(\\"They are the same!\\")\\n  }\\n}\\n\\nconst person = { name: \\"Lydia\\" }\\n\\ncompareMembers(person)\\n","question":"\xbfCu\xe1l es el valor?"},{"answer":3,"explanation":["En JavaScript, tenemos dos formas de acceder a las propiedades de un objeto: notaci\xf3n por corchetes o notaci\xf3n por punto. En este ejemplo, usamos la notaci\xf3n por punto (`colorConfig.colors`) en lugar de la notaci\xf3n por corchetes (`colorConfig[\\"colors\\"]`).","Con la notaci\xf3n por punto, JavaScript intenta encontrar la propiedad en el objeto con ese nombre exacto. En este ejemplo, JavaScript intenta encontrar una propiedad llamada `colors` en el objeto `colorConfig`. No hay propiedad llamada `colors`, por lo que devuelve `undefined`. Luego, intentamos acceder al valor del primer elemento usando `[1]`. No podemos hacer esto en un valor que sea `undefined`, por lo que lanza una expeci\xf3n `TypeError`: `Cannot read property \'1\' of undefined`.","JavaScript interpreta (o descompone) las sentencias. Cuando usamos la notaci\xf3n por corchetes, ve el primer corchete de apertura `[` y contin\xfaa hasta que encuentra el corchete de cierre `]`. Solo entonces, evaluar\xe1 la declaraci\xf3n. Si hubi\xe9ramos utilizado `colorConfig[colors[1]]`, habr\xeda devuelto el valor de la propiedad `red` del objeto `colorConfig`."],"id":105,"options":["`true`","`false`","`undefined`","`TypeError`"],"problem":"const colorConfig = {\\n  red: true,\\n  blue: false,\\n  green: true,\\n  black: true,\\n  yellow: false,\\n}\\n\\nconst colors = [\\"pink\\", \\"red\\", \\"blue\\"]\\n\\nconsole.log(colorConfig.colors[1])\\n","question":"\xbfCu\xe1l es el valor?"},{"answer":0,"explanation":["Bajo el cap\xf3, los emojis son caracteres unicode. Los valores unicode para el emoji del coraz\xf3n son `\\"U+2764 U+FE0F\\"`. Estos son siempre los mismos para los mismos emojis, por lo que estamos comparando dos cadenas iguales entre s\xed, lo que devuelve verdadero."],"id":106,"options":["`true`","`false`"],"problem":"console.log(\'\u2764\ufe0f\' === \'\u2764\ufe0f\')\\n","question":"\xbfCu\xe1l es el valor?"},{"answer":3,"explanation":["Con el m\xe9todo `splice`, modificamos el array original eliminando, reemplazando o agregando elementos. En este caso, eliminamos 2 elementos desde el \xedndice 1 (eliminamos `\'\ud83e\udd51\'` y `\'\ud83d\ude0d\'`) y agregamos el emoji \u2728 en su lugar.","`map`, `filter` y `slice` devuelven un nuevo array, `find` devuelve un elemento, y `reduce` devuelve un valor reducido."],"id":107,"options":["`All of them`","`map` `reduce` `slice` `splice`","`map` `slice` `splice`","`splice`"],"problem":"const emojis = [\'\u2728\', \'\ud83e\udd51\', \'\ud83d\ude0d\']\\n\\nemojis.map(x => x + \'\u2728\')\\nemojis.filter(x => x !== \'\ud83e\udd51\')\\nemojis.find(x => x !== \'\ud83e\udd51\')\\nemojis.reduce((acc, cur) => acc + \'\u2728\')\\nemojis.slice(1, 2, \'\u2728\') \\nemojis.splice(1, 2, \'\u2728\')\\n","question":"\xbfCu\xe1l de estos m\xe9todos modifica el array original?"},{"answer":0,"explanation":["Establecemos el valor de la propiedad `favoriteFood` en el objeto` info` igual a la cadena con el emoji de la pizza, `\'\ud83c\udf55\'`. Una cadena es un tipo de dato primitivo. En JavaScript, los tipos de datos primitivos act\xfaan por referencia","En JavaScript, los tipos de datos primitivos (todo aquello que no es un objeto) interact\xfaan por _valor_. En este caso, establecemos el valor de la propiedad `favoriteFood` en el objeto` info` igual al valor del primer elemento en el array `food`, la cadena del emoji de la pizza en este caso (`\'\ud83c\udf55\'`). Una cadena es un tipo de datos primitivo e interact\xfaa por valor (consulte mi [art\xedculo](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) si est\xe1s interesado en aprender m\xe1s)","Luego, cambiamos el valor de la propiedad `favoriteFood` en el objeto` info`. El array `food` no cambia, ya que el valor de `favoriteFood` era simplemente una _copia_ del valor del primer elemento del array, y no tiene una referencia al mismo punto en la memoria que el elemento en `food[0]`. Cuando imprimimos food, \xe9ste sigue siendo el array original, `[\'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`."],"id":108,"options":["`[\'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`","`[\'\ud83c\udf5d\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`","`[\'\ud83c\udf5d\', \'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']`","`ReferenceError`"],"problem":"const food = [\'\ud83c\udf55\', \'\ud83c\udf6b\', \'\ud83e\udd51\', \'\ud83c\udf54\']\\nconst info = { favoriteFood: food[0] }\\n\\ninfo.favoriteFood = \'\ud83c\udf5d\'\\n\\nconsole.log(food)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Con el m\xe9todo `JSON.parse()`, podemos convertir la cadena de texto en formato JSON a un valor en JavaScript."],"id":109,"options":["Parses JSON to a JavaScript value","Parses a JavaScript object to JSON","Parses any JavaScript value to JSON","Parses JSON to a JavaScript object only"],"problem":"JSON.parse()\\n","question":"\xbfQu\xe9 hace este m\xe9todo?"},{"answer":3,"explanation":["Cada funci\xf3n tiene su propio _contexto de ejecuci\xf3n_ (o _\xe1mbito_). La funci\xf3n `getName` primero mira dentro de su propio contexto (\xe1mbito) para ver si contiene la variable `name` a la que estamos intentando acceder. En este caso, la funci\xf3n `getName` contiene su propia variable `name`: declaramos la variable `name` con la palabra clave` let`, y con el valor de `\'Sarah\'`.","Las variables con la palabra clave `let` (y `const`) se mueven al comienzo (hoisting), pero a diferencia de `var`, no se <i>inicializan</i>. No son accesibles antes de la l\xednea en la que las declaramos (inicializamos). Esto se llama la \\"zona muerta temporal\\". Cuando intentamos acceder a las variables antes de que se declaren, JavaScript genera una excepci\xf3n del tipo `ReferenceError`.","Si no hubi\xe9ramos declarado la variable `name` dentro de la funci\xf3n `getName`, el motor de JavaScript habr\xeda mirado hacia abajo _\xe1mbito encadenado_. El alcance externo tiene una variable llamada `name` con el valor de `Lydia`. En ese caso, habr\xeda imprimido `Lydia`."],"id":110,"options":["Lydia","Sarah","`undefined`","`ReferenceError`"],"problem":"let name = \'Lydia\'\\n\\nfunction getName() {\\n  console.log(name)\\n  let name = \'Sarah\'\\n}\\n\\ngetName()\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Con la palabra clave `yield`, cedemos valores en una funci\xf3n generadora. Con la palabra clave `yield*`, podemos obtener valores de otra funci\xf3n generadora u objeto iterable (por ejemplo, un array).","En la funci\xf3n `generatorOne`, cedemos todo el array `[\'a\', \'b\', \'c\']` usando la palabra clave `yield`. El valor de la propiedad `value` en el objeto devuelto por el m\xe9todo `next` en `one` (`one.next().value`) es igual a todo el array `[\'a\', \'b\', \'c\']`.","En la funci\xf3n `generatorTwo`, usamos la palabra clave `yield*`. Esto significa que el primer valor cedido de `two` es igual al primer valor cedido en el iterador. El iterador es el array `[\'a\', \'b\', \'c\']`. El primer valor producido es `a`, por lo que la primera vez que llamamos a `two.next().value`, se devuelve `a`."],"id":111,"options":["`a` y `a`","`a` y `undefined`","`[\'a\', \'b\', \'c\']` y `a`","`a` y `[\'a\', \'b\', \'c\']`"],"problem":"function* generatorOne() {\\n  yield [\'a\', \'b\', \'c\'];\\n}\\n\\nfunction* generatorTwo() {\\n  yield* [\'a\', \'b\', \'c\'];\\n}\\n\\nconst one = generatorOne()\\nconst two = generatorTwo()\\n\\nconsole.log(one.next().value)\\nconsole.log(two.next().value)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":0,"explanation":["Las expresiones dentro de las plantillas de cadena de texto se eval\xfaan primero. Esto significa que la cadena contendr\xe1 el valor devuelto de la expresi\xf3n, la funci\xf3n invocada inmediatamente `(x => x)(\'I love\')` en este caso. Pasamos el valor `\'I love\'` como argumento para la funci\xf3n de flecha `x => x`. `x` es igual a `\'I love\'`, que se devuelve tal cual. Esto da como resultado `I love to program`."],"id":112,"options":["`I love to program`","`undefined to program`","`${(x => x)(\'I love\') to program`","`TypeError`"],"problem":"console.log(`${(x => x)(\'I love\')} to program`)\\n","question":"\xbfCu\xe1l es el resultado?"},{"answer":2,"explanation":["Normalmente, cuando establecemos objetos iguales a `null`, esos objetos se recogen por el _recolector de basura_ ya que ya no hay ninguna referencia a ese objeto. Sin embargo, dado que la funci\xf3n de devoluci\xf3n de llamada dentro de `setInterval` es una funci\xf3n flecha (por lo tanto vinculada al objeto` config`), la funci\xf3n de devoluci\xf3n de llamada todav\xeda tiene una referencia al objeto `config`. Mientras haya una referencia, el objeto no ser\xe1 recolectado. Como no es recolectado, la funci\xf3n de devoluci\xf3n de llamada `setInterval` a\xfan se invocar\xe1 cada 1000ms (1s)."],"id":113,"options":["The `setInterval` callback won\'t be invoked","The `setInterval` callback gets invoked once","The `setInterval` callback will still be called every second","We never invoked `config.alert()`, config is `null`"],"problem":"let config = {\\n  alert: setInterval(() => {\\n    console.log(\'Alert!\')\\n  }, 1000)\\n}\\n\\nconfig = null\\n","question":"\xbfQu\xe9 ocurrir\xe1?"},{"answer":1,"explanation":["Al agregar un par clave/valor utilizando el m\xe9todo `set`, la clave ser\xe1 el valor del primer argumento pasado a la funci\xf3n `set`, y el valor ser\xe1 el segundo argumento pasado a la funci\xf3n `set`. La clave es la _funci\xf3n_ `() => \'greeting\'` en este caso, y el valor `\'Hello world\'`. `myMap` ahora es `{ () => \'greeting\' => \'Hello world!\' }`.","1 es incorrecto, ya que la clave no es `\'greeting\'` sino `() => \'greeting\'`.\\n3 es incorrecto, ya que estamos creando una nueva funci\xf3n pas\xe1ndola como par\xe1metro al m\xe9todo `get`. El objeto interact\xfaa por _referencia_. Las funciones son objetos, por eso dos funciones nunca son estrictamente iguales, aunque sean id\xe9nticas: tienen una referencia a un punto diferente en la memoria."],"id":114,"options":["1","2","2 and 3","All of them"],"problem":"const myMap = new Map()\\nconst myFunc = () => \'greeting\'\\n\\nmyMap.set(myFunc, \'Hello world!\')\\n\\n//1\\nmyMap.get(\'greeting\')\\n//2\\nmyMap.get(myFunc)\\n//3\\nmyMap.get(() => \'greeting\')\\n","question":"\xbfQu\xe9 m\xe9todo(s) devolver\xe1 el valor `\'Hello world!\'`?"},{"answer":2,"explanation":["Tanto las funciones `changeAge` como `changeAgeAndName` tienen un par\xe1metro por defecto, a saber, un objeto _nuevo_ creado `{ ...person }`. Este objeto tiene copias de todos los pares clave/valor en el objeto `person`.","Primero, invocamos la funci\xf3n `changeAge` y le pasamos el objeto `person` como argumento. Esta funci\xf3n aumenta el valor de la propiedad `age` en 1. `person` ahora es `{name: \\"Lydia\\", age: 22}`.","Luego, invocamos la funci\xf3n `changeAgeAndName`, sin embargo, no pasamos un par\xe1metro. En cambio, el valor de `x` es igual a un _nuevo_ objeto: `{ ...person }`. Dado que es un objeto nuevo, no afecta los valores de las propiedades en el objeto `person`. `person` sigue siendo igual a `{ name: \\"Lydia\\",age: 22 }`."],"id":115,"options":["`{name\\"Sarah\\", age22}`","`{name\\"Sarah\\", age23}`","`{name\\"Lydia\\", age22}`","`{name\\"Lydia\\", age23}`"],"problem":"const person = {\\n  name: \\"Lydia\\",\\n  age: 21\\n}\\n\\nconst changeAge = (x = { ...person }) => x.age += 1\\nconst changeAgeAndName = (x = { ...person }) => {\\n  x.age += 1\\n  x.name = \\"Sarah\\"\\n}\\n\\nchangeAge(person)\\nchangeAgeAndName()\\n\\nconsole.log(person)\\n","question":"\xbfCu\xe1l es el resultado?"}]')}}]);
//# sourceMappingURL=36.d9cf97f7.chunk.js.map