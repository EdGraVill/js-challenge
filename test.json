[
    "###### 1. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nfunction sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = \"Lydia\";\n  let age = 21;\n}\n\nsayHi();\n```\n</div>\n\n- أ: `Lydia` و `undefined`\n- ب: `Lydia` و `ReferenceError`\n- ج: `ReferenceError` و `21`\n- د: `undefined` و `ReferenceError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: د\n\nجوا الدالة احنا الاول عملنا متغير `name` بالكلمة الدالة `var`. ده معناه ان المتغير ده هيكون موجود في الذاكرة في مرحلة التكوين بالقيمة `undefined` قبل ما الكود يشتغل لحد ما نوصل تحديداً للسطر اللي فيه بنحط قيمة للمتغير ده. احنا بقى لحد السطر اللي بنبطع فيه المتغير ده مكانش لسه اتعمل وبالتالي كان لسه فيه قيمة `undefined`.\n\nالمتغيرات اللي بتتعمل بكلمة `let` و `const` بيعملوا نفس الموضوع, بس الفرق ان مبنقدرش ناخد قيم منهم الا لحد ما نضيفلهم قيم من الأساس. دي اسمها `temporal dead zone` او بالعربي \"منطقة الموت المؤقتة\". لما بنحاول ناخد قيمة متغير قبل ما نعمله جافاسكربت بترجع خطأ من نوع `ReferenceError`\n\n</p>\n</details>\n\n---\n\n",
    "###### 2. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n```\n</div>\n\n- أ: `0 1 2` و `0 1 2` \n- ب: `0 1 2` و `3 3 3`\n- ج: `3 3 3` و `0 1 2`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة: ج\n\nالفنكشن اللي`setTimeout` بتشغلها بيتم تشغليها _بعد_ ما اللووب تخلص بسبب قائمة الاحداث `event queue` في جافاسكربت. بما ان اول لووب اتعملت كان المتغير بتاعها معمول بكلمة `var` اذا كان `global` وبالتالي في اللوب احنا كل شوية كنا بنزود `i` لحد ما وصل ل 3 و _بعد_ كده قامت الفنكشن اللي جوا `setTimeout` اشتغلت. ده كده اول لووب. \n\nاما بقى في تاني لووب المتغير `i` كان معمول بكلمة `let` و بالتالي المنظور بتاعه `scope` محدد بالاقواس المحيطة بيه `block` وبالتالي في كل مره اللوب هتزيد هيكون في قيمة جديدة تماماً للمتغير `i` و كل قيمة من دول موجوده جوا ال`block scope` اللي هي حصلت فيه, و بالتالي هيبقى كأن البرنامج شايف 3 قيم للمتغير `i` في 3 اماكن مختلفه!\n\n</p>\n</details>\n\n---\n\n",
    "###### 3. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nconst shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n};\n\nshape.diameter();\nshape.perimeter();\n```\n</div>\n\n- أ: `20` و `62.83185307179586`\n- ب: `20` و `NaN`\n- ج: `20` و `63`\n- د: `NaN` و `63`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة: ب\n\nخلي بالك من نوعية الفنكشن `diameter` و هي `regular`و نوعية الفنكشن `perimeter` واللي هي `arrow function`.\n\nفي النوع الاخير, الكلمة الدالة `this` بتشاور الى المحيط بالدالة دي. وده معناه اننا لما بنشغل `perimeter` احنا مش بنشاور ب`this` على `shape` بل بنشاور على المحيط و هو `window` مثلاً! \n\nوبالتالي مفيش قيمة `radius` في النطاق ده, و بالتالي البرنامج بيدينا `undefined`.\n</p>\n</details>\n\n---\n\n",
    "###### 4. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\n+true;\n!\"Lydia\";\n```\n</div>\n\n- أ: `1` و `false` \n- ب: `NaN` و `false`\n- ج: `false` و `false`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nعلامة الجمع تحاول دائما ان تغير قيم من قيم مدخلاتها الى رقم باعتبار ان اي قيمة حقيقية ايجابية `true` يتم تحويلها لرقم `1` و القيم السالبية `false` تتحول الى `0`. \nThe unary plus tries to convert an operand to a number. `true` is `1`, and `false` is `0`.\n\nو في الحالة دي القيمة الكتابية `'Lydia'` تعتبر ايجابية. هنا بقى السؤال: \"هل القيمه الايجابيه دي سالبيه؟ و بالتالي الاجابة لا اللي هي `false`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 5. اختر الاجابة الصحيحة\n<div dir=\"ltr\">\n\n```javascript\nconst bird = {\n  size: \"small\"\n};\n\nconst mouse = {\n  name: \"Mickey\",\n  small: true\n};\n```\n</div>\n\n- أ: `mouse.bird.size` متنفعش\n- ب: `mouse[bird.size]` متنفعش\n- ج: mouse[bird[\"size\"]]` متنفعش\n- د: كلهم ينفعوا\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nفي جافاسكربت كل مفاتيح العناصر `object keys` من النوع `string` الا في حالة الـ `symbol`. وعلى الرغم من اننا ممكن منكتبهمش في شكل `string` فهما دايماً بيتحولوا ل`string`\nبص المثال: \n<div dir=\"ltr\">\n\n```javascriptlet obj = {\n  size: 'big'\n}\n```\n</div>\n\nفي المثال ده احنا عملنا عنصر و كان ليه مفتاح اسمه size. شكل size احنا عاملينه من غير علامة التنصيص `\"\"` ولكن لما البرنامج بيشتغل بيتم تحويلها الى سترنج و بالتالي بتكون في شكل `\"size\"`\n\nغير بقى ان جافاسكربت بتفك كل جمله لوحدها. ده معناه انها لما بنستعمل علامات ال `[]` واسمها `bracket notation` هتفضل تمشي من اول `[` لحد ما توصل للي يقفله اللي هو `]`. و بعد كده هتقوم مشغله الجمله بعد ما تعرف ان الجمله دي مفيهاش اخطاء. \n\nفا عشان كده عندنا `mouse[bird.size]` الاول هتجيب `bird.size` اللي قيمته `\"small\"` وبالتالي تبقى الجمله `mouse[\"small\"]` هترجع `true` \n\nولكن لما بنستعمل ال `dot notation` مبيحصلش كده. `mouse` ملوش مفتاح اسمه `bird` و بالتالي احنا بنطلب قيمه موجوده جوا حاجه مش موجودة اصلاً و بالتالي بيرجعلنا خطأ `cannot read property of undefined`.\n\n</p>\n</details>\n\n---\n\n---\n\n",
    "###### 6. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nlet c = { greeting: \"Hey!\" };\nlet d;\n\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);\n```\n</div>\n\n- أ: `Hello`\n- ب: `Hey`\n- ج: `undefined`\n- د: `ReferenceError`\n- هـ: `TypeError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nفي جافاسكربت كل العناصر `objects` بيتعاملوا بالـ`reference` لما بنساويهم ببعض. ده معناه ان الاوبجكت مش بيتعمل منه نسخه جديدة و انما بيتم الاشارة اليه بأسم جديد مش اكتر. \n\nفي الاول المتغير `c` جواه قيمة اوبجكت و بعد كده بنقوم عاملين اشارة للاوبجكت ده عن طريق المتغير `d` \n.\n\n<img src=\"https://i.imgur.com/ko5k0fs.png\" width=\"200\">\n\nوبالتالي لما بتغير متغير واحد منهم انت بتغير الاتنين لان الاتنين بيشيروا لنفس العنصر في الميموري.\n\n</p>\n</details>\n\n---\n\n",
    "###### 7. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nlet a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n```\n</div>\n\n- أ: `true` `false` `true`\n- ب: `false` `false` `true`\n- ج: `true` `false` `false`\n- د: `false` `true` `true`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\n`new Number()` ده `constructor` مبني في اللغه و على الرغم من ان شكل القيمه اللي هتطلع منه مجرد رقم `primitive` لكن الحقيقه ان القيمة اللي هتيجي `object` وهيكون فيه زيادات زي ال`methods` وهكذا.\n\nلما بنستعمل علامة المساواه `==` احنا بنشوف بس لو القيمتين اللي بنقارنهم ليهم نفس **القيمة** فقط ولا لا. الاتنين ليهم قيمة `3` وبالتالي هترجع `true`\n\nاما بقى لما بنستعمل المساواة `===` احنا بنشوف **القيمة** و **النوع** و بالتالي بما ان الاتنين `object` بس موجودين في اماكن مختلفه في الميموري اذاً احنا مش عاملين اشارة لنفس العنصر و بالتالي هترجع `false`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 8. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nclass Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = \"green\" } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: \"purple\" });\nfreddie.colorChange(\"orange\");\n```\n</div>\n\n- أ: `orange`\n- ب: `purple`\n- ج: `green`\n- د: `TypeError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: د\n\nالدالة `colorChange` من نوع `static` و بالتالي هي مموجوده فقط في ال`constructor` اللي بتتعمل فيه و مش بتروح لأي عنصر بيتعمل من ال`class` ده و بما ان `freddie` ده عنصر معمول من الكلاس ده فا الدالة `colorChange` مش بتروحله و بالتالي مش موجوده معاه و عشان كده هتدينا `TypeError`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 9. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nlet greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);\n```\n</div>\n\n- أ: `{}`\n- ب: `ReferenceError: greetign is not defined`\n- ج: `undefined`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nبتطبع العنصر الفاضي لأننا عملنا الاوبجكت ده من نوع `global` لما كتبنا `greetign` بدل `greeting` و بالتالي البرنامج شاف `greetign` على انها `window.greetign={}` لو في المتصفح. \n\nعشان نبعد عن المشكلة دي نقدر نستعمل `\"use strict\"` و اللي بدورها بتتأكد ان انت عملت المتغير قبل ما تحاول تتعامل معاه.\n\n</p>\n</details>\n\n---\n\n",
    "###### 10. ايه اللي هيحصل لما نعمل كده؟\n<div dir=\"ltr\">\n\n```javascript\nfunction bark() {\n  console.log(\"Woof!\");\n}\n\nbark.animal = \"dog\";\n```\n</div>\n\n- أ: مش هيحصل اي حاجه غلط, الكود ده صحيح تماماً!\n- ب:  `SyntaxError`\n- ج: `undefined`\n- د: `ReferenceError`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nكل حاجه في جافاسكربت عبارة عن `object` حتى الدوال و بالتالي نقدر بكل سهولة اننا نعمل اللي احنا عملناه في الكود و نضيف مفاتيح و قيم للداله على انها عنصر اوبجكت عادي جداً.\n\n</p>\n</details>\n\n---\n\n",
    "###### 11. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());\n```\n</div>\n\n- أ: `TypeError`\n- ب: `SyntaxError`\n- ج: `Lydia Hallie`\n- د: `undefined` `undefined`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nمينفعش تضيف قيم لـ `constructor`بالشكل ده. لو عايز تضيف قيمة لكل الاوبجكتس اللي معمولين من الـ`constructor` ده لازم تستعمل الـ `prototype` \n\nبص  المثال ده:\n<div dir=\"ltr\">\n\n```js\nPerson.prototype.getFullName = function() {\n  return `${this.firstName} ${this.lastName}`;\n};\n```\n</div>\n\nفي المثال ده هنقدر نضيف القيمه لكل العناصر اللي معموله من الـ`constructor` ده. ايه الفايده من ده بقى؟ تخيل معايا ان احنا عملنا كوبي من دالة دي جوا كل عنصر لوحدة --مع التغاضي عن اعتبار ان بعضهم ممكن ميكونوش محتاجينها اصلاً-- احنا كده بنستخدم ميموري كتير جداً على الفاضي بينما عن طريق الـ`prototype` بنقدر اننا نعملها مره واحدة فقط و بتكون موجوده لكل العناصر اللي معموله منها! \n\n\n</p>\n</details>\n\n---\n\n",
    "###### 12. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person(\"Lydia\", \"Hallie\");\nconst sarah = Person(\"Sarah\", \"Smith\");\n\nconsole.log(lydia);\nconsole.log(sarah);\n```\n</div>\n\n- أ: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` و `undefined`\n- ب: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` و `Person {firstName: \"Sarah\", lastName: \"Smith\"}`\n- ج: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` و `{}`\n- د: `Person {firstName: \"Lydia\", lastName: \"Hallie\"}` و `ReferenceError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nكلمة `new` بتشير الى الاوبجكت الفاضي الجديد اللي احنا بنعمله قبل ما يتم اضافة اي قيم ليه. لكن لما مش بتستعمل `new` بيتم الاشارة الى الـ`global` او `window` على حسب انت بتشغل الكود فين و بالتالي لما عملنا `this.firstName = \"Sarah\"` احنا كده كأننا قولنا `window.firstName = \"Sarah\"` وبالتالي الاوبجكت `sarah نفسه فضل `undefined` \n\n</p>\n</details>\n\n---\n\n",
    "###### 13. ايه  الـ3 مراحل بتوع الـ `event propagation`؟\n\n- أ: Target > Capturing > Bubbling\n- ب: Bubbling > Target > Capturing\n- ج: Target > Bubbling > Capturing\n- د: Capturing > Target > Bubbling\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: د\n\nفي مرحلة الـ`capturing` الحدث بيمر الاول خلال العناصر الكبيره المحتوية على العنصر اللي حصلت فيه الحدث اصلاً لحد ما توصل للعنصر ده. بعد كده بتوصل لـ `target` واللي هو العنصر اللي عمل الحدث و بعد كده بترد تاني لفوق في مرحلة الـ`bubbling`\n\n\n<img src=\"https://i.imgur.com/N18oRgd.png\" width=\"200\">\n\n</p>\n</details>\n\n---\n\n",
    "###### 14. كل العناصر `objects` ليهم `prototype`. هذه العبارة: \n\n- أ: صحيحة\n- ب: خطأ\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\nكل العناصر في جافاسكربت ليها `prototype` ما عدا الـ**base object** و اللي كل العناصر بتاخد منه الدوال بتاعته. ده السبب اللي بيخليك تقدر تستعمل الدوال دي في اي عنصر تعمله.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 15. ايه اللي هيتطبع؟\n<div dir=\"ltr\">\n\n```javascript\nfunction sum(a, b) {\n  return a + b;\n}\n\nsum(1, \"2\");\n```\n</div>\n\n- أ: `NaN`\n- ب: `TypeError`\n- ج: `12`\n- د: `3`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nجافاسكربت `dynamic` و بالتالي احنا مش بنحدد نوع المتغير لما بنعمله و المتغير نوعه بيتغير عادي جداً و ممكن ده يحصل من غير ما تعرف حتى و ده اسمه `implicit coercion`. \n\nفي المثال ده بقى جافاسكربت هتحول رقم `1` الى `string` عشان الدالة تقدر تتعامل معاه و ترجع قيمة. و في عملية الجمع مابين القيمة العددية `1` و السترنج `\"2\"` الرقم هيتحول الى سترنج و بعد كده هيقوم متضاف الى السترنج التانية عشان يعمل سترنج `\"12\"`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 16. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nlet number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);\n```\n</div>\n\n- أ: `1` `1` `2`\n- ب: `1` `2` `2`\n- ج: `0` `2` `2`\n- د: `0` `1` `2`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nالعامل البعدي `x++` بيرجع القيمة الاصلية الاول بعد كده يزود واحد على المتغير\n\nاما العامل القبلي `++x` بيعدل القيمة الاول و يرجع القيمة المعدلة\n\n</p>\n</details>\n\n---\n\n",
    "###### 17. ايه اللي هيتطبع؟ (جرب تشغل السؤال ده عشان تفهمه كويس)\n\n<div dir=\"ltr\">\n\n```javascript\nfunction getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = \"Lydia\";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;\n```\n</div>\n\n- أ: `\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`\n- ب: `[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`\n- ج: `\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\n\nلو بتستعمل `tagged template literals` اول قيمة داخله للدالة دايماً هتكون `array` مليانه بالسترنج اللي داخله فقط من غير اي متغيرات و الباقي هياخدوا القيم اللي داخله بالترتيب. \n\n</p>\n</details>\n\n---\n\n",
    "###### 18. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nfunction checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log(\"You are an adult!\");\n  } else if (data == { age: 18 }) {\n    console.log(\"You are still an adult.\");\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });\n```\n</div>\n\n- أ: `You are an adult!`\n- ب: `You are still an adult.`\n- ج: `Hmm.. You don't have an age I guess`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nلما بنقارن في جافاسكربت, القيم الـ`primitive` زي الارقام و السترنج البسيطة بيتم مقارنة قيمتها فقط بينما الاوبجكتس بيتم مقارنة الاشارة ليهم `reference`. يعني لما بنقارن اوبجكتس ببعض جافاسكربت بتشوف هل الاتنين بيشاوروا لنفس المكان في الرام ولا لا.\n\nو بما ان الاوبجكتس اللي بنقارنهم احنا هنا داخلين على انهم قيمتين مختلفتين للداله وبالتالي مش بيشيروا لنفس المكان ف الرام يبقى مش متساويين و ده السبب اللي بيخلي الاجابة بالشكل ده. المقارنه عشان تتم بشكل صحيح بقى ممكن تحولهم ل سترنج او تشوف القيم اللي جوا كل اوبجكت.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 19. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nfunction getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n```\n</div>\n\n\n- أ: `\"number\"`\n- ب: `\"array\"`\n- ج: `\"object\"`\n- د: `\"NaN\"`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nمعامل التفكيك `spread operator ...args` بيرجع `array` فيها الـقيم اللي داخله للدالة. و بما ان كل حاجه في جافاسكربت عبارة عن اوبجكت بما فيها الـ`array` يبقى القيمه اللي هترجع `\"object\"`\n\n</p>\n</details>\n\n---\n\n",
    "###### 20. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nfunction getAge() {\n  \"use strict\";\n  age = 21;\n  console.log(age);\n}\n\ngetAge();\n```\n</div>\n\n\n- أ: `21`\n- ب: `undefined`\n- ج: `ReferenceError` \n- د: `TypeError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n####  الاجابة الصحيحة: ج\n\nلما بنستعمل `\"use strict\"` تقدر تتأكد ان انت مش بتعمل متغيرات `global` عن طريق الخطأ. احنا هنا عمرنا ما عملنا `declare` للمتغير `age` اصلاً و بما اننا بنستعمل `\"use strict\"` البرنامج هيدينا خطأ من نوع `ReferenceError`.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 21. ايه قيمة `sum`?\n\n<div dir=\"ltr\">\n\n```javascript\nconst sum = eval(\"10*10+5\");\n```\n</div>\n\n- أ: `105`\n- ب: `\"105\"`\n- ج: `TypeError`\n- د: `\"10*10+5\"`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nالدالة `eval` بتشغل الكود اللي داخلها على هيئة `string`. لو السترنج دي بتعبر عن عملية حسابية مثلاً هتقوم مشغله العملية دي و بالتالي `10 * 10 + 5` هيرجع القيمة العددية `105`.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 22. cool_secret هتفضل موجوده قد ايه؟\n\n<div dir=\"ltr\">\n\n```javascript\nsessionStorage.setItem(\"cool_secret\", 123);\n```\n</div>\n\n- أ: للأبد, عمرها ما هتتمسح \n- ب: لما المستخدم يقفل التبويب\n- ج: لما المستخدم يقفل نافذة المتصفح كلها\n- د: لما المستخدم يطفي الكمبيوتر بتاعه\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\nاي معلومات بيتم تخزينها في الـ`sessionStorage` بتتمسح مجرد ما المستخدم يقفل التبويب.\n\nلو استخدمت `localStorage` المعلومات هتفضل موجوده للأبد او لحد ما تمسحها انت بنفسك في الكود.\n\n</p>\n</details>\n\n---\n\n",
    "###### 23. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nvar num = 8;\nvar num = 10;\n\nconsole.log(num);\n```\n</div>\n\n- أ: `8`\n- ب: `10`\n- ج: `SyntaxError`\n- د: `ReferenceError`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\nمع كلمة `var` احنا بنعمل المتغير من اول و جديد بنفس الاسم و بقيم مختلفه و بالتالي اخر قيمه بس هي اللي هتكون موجودة. مش بيحصل كده مع `let` و `const`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 24. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconst obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(\"1\");\nobj.hasOwnProperty(1);\nset.has(\"1\");\nset.has(1);\n```\n</div>\n\n- أ: `false` `true` `false` `true`\n- ب: `false` `true` `true` `true`\n- ج: `true` `true` `false` `true`\n- د: `true` `true` `true` `true`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nكل مفاتيح العناصر `object keys` ما عدا اللي من نوع `Symbol` عبارة عن قيم `string` حتى لو انت مش كاتبها كسترنج. و ده السبب ان `obj.hasOwnProperty('1')` برضه بترجع `true`\n\nاما بالنسبه لنوع `set` فا اللي معانا حالياً جواها قيم عددية فقط و بالتالي الـ`string` `'1'` مش موجوده.\n\n</p>\n</details>\n\n---\n\n",
    "###### 25. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconst obj = { a: \"one\", b: \"two\", a: \"three\" };\nconsole.log(obj);\n```\n</div>\n\n\n- أ: `{ a: \"one\", b: \"two\" }`\n- ب: `{ b: \"two\", a: \"three\" }`\n- ج: `{ a: \"three\", b: \"two\" }`\n- د: `SyntaxError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nلو عندك في العنصر اكتر من قيمة `object key` بنفس الاسم, هيتم استبدال القيم اللي موجوده بآخر قيمة تم تسجيلها.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 26. في جافاسكربت, بنلاقي حاجتين موجودين دايماً وهما الـ `global` و كلمة ال `this` المفتاحية. العبارة دي: \n\n- أ: صحيحة\n- ب: خاطئة\n- ج: تعتمد\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n####  الاجابة الصحيحة: أ\n\nو دي حاجه اسمها `global execution context` واللي يمكن اعتباره عن محيط او البيئة اللي الكوود بيشتغل فيه و بيكون فيه المتغيرات الـ`global` كلها.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 27. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nfor (let i = 1; i < 5; i++) {\n  if (i === 3) continue;\n  console.log(i);\n}\n```\n</div>\n\n- أ: `1` `2`\n- ب: `1` `2` `3`\n- ج: `1` `2` `4`\n- د: `1` `3` `4`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nكلمة `continue` بتخلي اللووب تكمل لو الشرط اللي هي جواه اتحقق. \n\n</p>\n</details>\n\n---\n\n",
    "###### 28. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nString.prototype.giveLydiaPizza = () => {\n  return \"Just give Lydia pizza already!\";\n};\n\nconst name = \"Lydia\";\n\nname.giveLydiaPizza();\n```\n</div>\n\n\n\n- أ: `\"Just give Lydia pizza already!\"`\n- ب: `TypeError: not a function`\n- ج: `SyntaxError`\n- د: `undefined`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\n`String` هو فنكشن `constructor` واللي بنقدر نضيف خواص و قيم ليه. انا هنا ضيفت دالة للـ`prototype` بتاعه. المتغيرات البدائية `primitive` بيتم تحويلها بطريقة تلقائياً الى عنصر `object` وبالتالي بيكون ليها القدره انها تشغل الدوال الخاصه بالنوع ده. \n\n</p>\n</details>\n\n---\n\n",
    "###### 29. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconst a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n```\n</div>\n\n- أ: `123`\n- ب: `456`\n- ج: `undefined`\n- د: `ReferenceError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\nمفاتيح العناصر `Object keys` بيتم تحويلهم تلقائياً الى string. احنا هنا بنحاول نحط اوبجكت على انه مفتاح لأوبجكت تاني. بس المشكلة ان لما نعمل كده مش بيترجم لأسمه او لمحتوياته بل بيتحول الى `[object Object] و بالتالي احنا كنا كأننا بالظبط عاملين `a[\"object Object\"]=123` و بنكرر كده مع `c` و بعد كده بنقوم طابعين `a[b]` اللي احنا لسه مخليين مفتاحها من شوية `a[\"object Object\"]` و خلينا القيمة بتاعته 456 و بالتالي دي اللي بتطبع.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 30. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconst foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"));\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();\n```\n</div>\n\n- أ: `First` `Second` `Third`\n- ب: `First` `Third` `Second`\n- ج: `Second` `First` `Third`\n- د: `Second` `Third` `First`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\nعندنا دالة `setTimeout` و المفروض تشتغل الاول و لكن اللي جواها اتشغل اخر حاجه. ايه اللي حصل؟ \n\nفي المتصفحات محرك الجافاسكربت مش لوحده اللي موجود, بل موجود كمان معاه حاجه اسمها `Web Application APIs` واختصارها `WebAPIs` ودي بتديلك شوية دوال و حاجات زيادة عن اللغه الاساسية زي `setTimeout` اللي مش في اللغه اصلاً. \n\nاللي بيحصل بقى ان الدالة اللي جوا `setTimeout` اللي هي الـ `callback` بتتجهز عشان تشتغل, و `setTimeout` نفسها بتخلص, و بعد كده البرنامج بينط على طول على الدالة اللي بعدها و بتشغلها و اللي بعدها و بتشغلها لحد ما ميتبقاش حاجه شاغله المتصفح بعد كده يقوم البرنامج مشغل الـ`callback` اللي كانت متجهزه. \n\n<img src=\"https://i.imgur.com/X5wsHOg.png\" width=\"200\">\n\n<img src=\"https://i.imgur.com/Pvc0dGq.png\" width=\"200\">\n\n<img src=\"https://i.imgur.com/WhA2bCP.png\" width=\"200\">\n\n<img src=\"https://i.imgur.com/NSnDZmU.png\" width=\"200\">\n\n<img src=\"https://i.imgur.com/uyiScAI.png\" width=\"200\">\n\n</p>\n</details>\n\n---\n\n",
    "###### 31. ايه قيمة `event.target` لما تدوس على الزرار؟ \n<div dir=\"ltr\">\n\n```html\n<div onclick=\"console.log('first div')\">\n  <div onclick=\"console.log('second div')\">\n    <button onclick=\"console.log('button')\">\n      Click!\n    </button>\n  </div>\n</div>\n```\n</div>\n\n- أ: Outer `div`\n- ب: Inner `div`\n- ج: `button`\n- د: اراي جواها كل العناصر اللي جوا الزرار\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nهدف الحدث بيكون اخر عنصر في سلسلة الابناء و تقدر تمنع ده عن طريق `event.stopPropagation`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 32. لما تدوس على البرجراف ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```html\n<div onclick=\"console.log('div')\">\n  <p onclick=\"console.log('p')\">\n    Click here!\n  </p>\n</div>\n```\n</div>\n\n- أ: `p` `div`\n- ب: `div` `p`\n- ج: `p`\n- د: `div`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nلما تدوس على البرجراف هتلاقي حاجتين ظهروا: `p` و `div`. و اثناء ما الحدث بيتم التعامل معاه بيحصل 3 مراحل زي ما قولنا في سؤال قبل كده. الاساسي ان الدوال اللي انت بتحددها عشان تتعامل مع الاحداث بتشتغل في اخر مرحله و هي الـ`Bubbling` و بالتالي هيتشغل من اعمق عنصر الى اكبر عنصر.\n\n</p>\n</details>\n\n---\n\n",
    "###### 33. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconst person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);\n```\n</div>\n\n- أ: `undefined is 21` `Lydia is 21`\n- ب: `function` `function`\n- ج: `Lydia is 21` `Lydia is 21`\n- د: `Lydia is 21` `function`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: د\n\nفي الحالتين بنقدر نحدد احنا عايزين كلمة `this` تشير لأيه بالظبط. بس الفرق ان `call` بتشتغل على طول اما `bind` بترجع نسخة جديدة من الدالة اللي دخلتلها قيمة `this` بتاعتها اللي احنا محددينها بس مش بتشتغل على طول.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 34. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nfunction sayHi() {\n  return (() => 0)();\n}\n\ntypeof sayHi();\n```\n</div>\n\n- أ: `\"object\"`\n- ب: `\"number\"`\n- ج: `\"function\"`\n- د: `\"undefined\"`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\nالدالة `sayHi` بترجع القيمة اللي بتيجي من الدالة ذاتية التشغيل (IIFE) و اللي بدورها بترجع قيمة نوعها `\"number\"`. \n\nولمعلومات القارئ: في 3 انواع فقط في الجافاسكربت: `null`, `undefined`, `boolean`, `number`, `string`, `object` و `symbol`. الدوال ليست نوع و انما هما عناصر من نوع `object`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 35. انهي قيمة من دول سالبية `false`؟\n\n<div dir=\"ltr\">\n\n```javascript\n0;\nnew Number(0);\n(\"\");\n(\" \");\nnew Boolean(false);\nundefined;\n```\n</div>\n\n- أ: `0`, `''`, `undefined`\n- ب: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`\n- ج: `0`, `''`, `new Boolean(false)`, `undefined`\n- د: كلهم\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n####  الاجابة الصحيحة: أ\n\nموجود في اللغه 6 قيم سالبية `false` فقط:\n\n- `undefined`\n- `null`\n- `NaN`\n- `0`\n- `''` (empty string)\n- `false`\n\nاي `constructor` بيكون ايجابي `truthy` علشان بيرجع قيمة مش واحدة من اللي 6 دول.\n\n</p>\n</details>\n\n---\n\n",
    "###### 36. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconsole.log(typeof typeof 1);\n```\n</div>\n\n- أ: `\"number\"`\n- ب: `\"string\"`\n- ج: `\"object\"`\n- د: `\"undefined\"`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\n`typeof 1` هترجع `\"number\"` و لاحظ ان دي مابين `\"\"` يعني سترنج و بالتالي لما تدخل في الـ `typeof \"number\"` هترجع `\"string\"`\n\n</p>\n</details>\n\n---\n\n",
    "###### 37. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n```\n</div>\n\n- أ: `[1, 2, 3, 7 x null, 11]`\n- ب: `[1, 2, 3, 11]`\n- ج: `[1, 2, 3, 7 x empty, 11]`\n- د: `SyntaxError`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nلما بتحط قيمة في مكان في `array` و المكان ده بيتعدى عدد المساحات الموجوده في الاراي (طولها) بتقوم جافاسكربت بعمل حاجه اسمها \"مساحات فارغه\" \"empty slots\" واللي بيكونوا قيمهم `undefined` ولكن لما تبص في الكونسول بتاعت المتصفح مثلاً هتلاقي الشكل طالعلك كده: \n\n`[1, 2, 3, 7 x empty, 11]`\n\nو الشكل بيعتمد على حسب انت بتشغل الكود فين. كل متصفح بيطلعها بشكل مختلف, و تقدر تجربها بنفسك.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 38. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\n(() => {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n```\n</div>\n\n- أ: `1` `undefined` `2`\n- ب: `undefined` `undefined` `undefined`\n- ج: `1` `1` `2`\n- د: `1` `undefined` `undefined`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nجزء الـ`catch` بيستلم متغير `x` بس الفرق ان الاكس في الحاله دي مش بتاعت الداله و انما ده متغير موجود فقط لجزء الـ `catch`. بعد كده احنا قومنا مغيرين القيمة بتاعته الى `1` و غيرنا قيمة المتغير `y` الى `2`. بعد كده قومنا طابعين القيم اللي موجودة جوا جزء الـ`catch` فقط. \n\nبرا الجزء بتاع الـ`catch` اكس هيفضل برضه `undefined` و `y` بما ان مفيش الا واحدة بس و هي بتاعت الدالة الاساسية واحنا غيرنا قيمتها بالتالي هتفضل على القيمة المتغيره اللي هي `2`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 39. كل حاجه في جافاسكربت ...\n\n- أ: primitive او  عنصر `object`\n- ب: function او عنصر `object`\n- ج: عناصر `object` بس!\n- د: رقم او عنصر `object`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nجافاسكربت فيها انواع بدائية\\بسيطة `primitives` و عناصر `object` فقط. الانواع البسيطة هما:  `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, و `symbol` \n\nالفرق بين البسيطة و العناصر ان البسيطة مفيهاش اي دوال `methods` ولكن بنلاحظ ان لما مثلاُ بنحاول نشغل دالة على نوع بسيط زي `'foo'.toUpperCase()` الداله بتشتغل عادي جداً من غير ما تدينا خطأ `TypeError` و ده لأن زي ما قولنا في اجابة سابقه ان لما بنحاول نستغل الدوال دول جافاسكربت بتقوم تلقائياً بتحويل القيم البدائية اللي بنحاول نشغل عليها الدوال دي الى قيم من نوع `object` عشان تقدر تشغل الدوال دول و بعد كده ترجعها زي ما كانت. كل الانواع البسيطة بينطبق عليها الكلام ده ما عدا `undefined` و `null`.\n\n</p>\n</details>\n\n---\n\n",
    "###### 40. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\n[[0, 1], [2, 3]].reduce(\n  (acc, cur) => {\n    return acc.concat(cur);\n  },\n  [1, 2]\n);\n```\n</div>\n\n- أ: `[0, 1, 2, 3, 1, 2]`\n- ب: `[6, 1, 2]`\n- ج: `[1, 2, 0, 1, 2, 3]`\n- د: `[1, 2, 6]`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ج\n\nالاراي `[1,2]` هي القيمه الاساسية اللي معانا و اللي هنبدأ بيها و هي برضه اول قيمة للمتغير `acc`. في الدورة الاولى المتغير `acc` قيمته `[1,2]` و المتغير `cur` قيمته `[0,1]` و لما نجمعهم سوا بيكون الناتج `[1,2,0,1]` و بعد كده المتغير `acc` بياخد القيمة دي و يقوم دامجها مع `[2,3]` اللي هي قيمة `cur` في الدورة التانية و اللي بدوره بيدي الناتج النهائي `[1, 2, 0, 1, 2, 3]`.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 41. ايه اللي هيتطبع؟\n\n<div dir=\"ltr\">\n\n```javascript\n!!null;\n!!\"\";\n!!1;\n```\n</div>\n\n\n- أ: `false` `true` `false`\n- ب: `false` `false` `true`\n- ج: `false` `true` `true`\n- د: `true` `true` `false`\n\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: ب\n\n`null` قيمة سالبية `falsy` و بالتالي `!null` هترجع قيمة ايجابية `true` و بعد كده بتخش `!true` فا تتحول `false` \n\nوزي ما قولنا `\"\"` دي قيمة سالبية لما نجيب عكسها هتتحول هي لـ`false` و بعد كده السالب بتاعها هيكون `true` و بعد كده تدخل في سالب تاني فتبقى `false`\n\nبعد كده عندنا رقم `1` اللي هو قيمة ايجابية و بدوره بيتحول مره يبقى سالبية و بعد كده يبقى ايجابية `true`.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 42. دالة `setInterval` بترجع ايه في المتصفح؟\n\n<div dir=\"ltr\">\n\n```javascript\nsetInterval(() => console.log(\"Hi\"), 1000);\n```\n</div>\n\n\n- أ: اسم تعريفي فريد من نوعه `unique id`\n- ب: الوقت المحدد\n- ج: الداله المدخله معاها\n- د: `undefined`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nدالة `setInterval` بترجع اسم تعريفي فريد تقدر تستعمله في `clearInterval` عشان توقف بيه التكرار.\n\n\n</p>\n</details>\n\n---\n\n",
    "###### 43. ايه القيمة اللي هتطلع هنا؟\n\n<div dir=\"ltr\">\n\n```javascript\n[...\"Lydia\"];\n```\n</div>\n\n\n- أ: `[\"L\", \"y\", \"d\", \"i\", \"a\"]`\n- ب: `[\"Lydia\"]`\n- ج: `[[], \"Lydia\"]`\n- د: `[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`\n\n<details><summary><b>الاجابة</b></summary>\n<p>\n\n#### الاجابة الصحيحة: أ\n\nالقيم اللي من نوع `string` بنقدر نعدي عليها عادي و بالتالي بنقدر نستعمل الـ Spread operator `...x` عشان نحول كل حرف الى عنصر في اراي.\n\n\n</p>\n</details>\n</div>\n"
]